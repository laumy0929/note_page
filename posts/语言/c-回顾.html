<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>C++回顾 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/laumy.github.io/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/laumy.github.io/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/laumy.github.io/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">单例模式</a><ul></ul></li><li><a href="#_2">智能指针</a><ul></ul></li><li><a href="#lambda">Lambda 表达式</a><ul></ul></li><li><a href="#stdmove">移动语义std::move</a><ul></ul></li><li><a href="#_3">模版</a><ul><li><a href="#_4">函数模版</a></li><li><a href="#_5">类模版</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>C++回顾</h1>
  <div class="meta">2025-03-27 · 语言</div>
  <div class="post-content"><p>平时用C++比较少，最近项目需要用到C++,现简单再回顾一下。</p>
<h2 id="_1">单例模式</h2>
<p>在某些场景下，一个类只需要有一个实例就足够了，例如配置管理类、日志记录器、数据库连接池等。使用单例模式可以避免创建多个实例导致的资源浪费、数据不一致等问题。</p>
<p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。在程序运行期间，这个类的实例始终只有一个，所有对该类实例的访问都通过这个全局访问点进行。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="n">class</span><span class="w"> </span><span class="n">Board</span><span class="w"> </span><span class="p">{</span>
<span class="n">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// 私有构造函数，防止外部实例化</span>
<span class="w">    </span><span class="n">Board</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="c1">// 禁止拷贝构造函数</span>
<span class="w">    </span><span class="n">Board</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Board</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delete</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 禁止赋值运算符</span>
<span class="w">    </span><span class="n">Board</span><span class="o">&amp;</span><span class="w"> </span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Board</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delete</span><span class="p">;</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Board</span><span class="o">*</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span>

<span class="n">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// 静态方法，用于获取唯一实例</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Board</span><span class="o">&amp;</span><span class="w"> </span><span class="n">GetInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Board</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">printMessage</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"This is the Board instance."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 初始化静态成员变量</span>
<span class="n">Board</span><span class="o">*</span><span class="w"> </span><span class="n">Board</span><span class="o">::</span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Board</span><span class="o">&amp;</span><span class="w"> </span><span class="n">board</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Board</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">();</span>
<span class="w">    </span><span class="n">board</span><span class="p">.</span><span class="n">printMessage</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_2">智能指针</h2>
<p>在传统的 C++ 中，使用 new 运算符手动分配内存，需要使用 delete 运算符手动释放内存。如果忘记释放内存，就会导致内存泄漏。使用智能指针可以自动管理对象的生命周期，避免内存泄漏的问题。</p>
<p>std::make_unique 是 C++14 引入的一个函数模板，用于创建 std::unique_ptr 对象。std::unique_ptr 是一种智能指针，它对所指向的对象拥有唯一所有权，即同一时间只能有一个 std::unique_ptr 指向同一个对象。当 std::unique_ptr 被销毁时，它所指向的对象也会被自动销毁。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"MyClass constructor"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"MyClass destructor"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">doSomething</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Doing something..."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 使用 std::make_unique 创建 std::unique_ptr</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// 当 ptr 离开作用域时，MyClass 对象会自动销毁</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="lambda">Lambda 表达式</h2>
<p>Lambda 表达式的主要优点是简洁性和灵活性。在一些场景下，我们只需要一个简单的函数，而且这个函数只在某个特定的地方使用一次，使用 Lambda 表达式可以避免定义一个单独的命名函数，使代码更加简洁。 Lambda 表达式是 C++11 引入的一种匿名函数机制，它允许在代码中定义一个临时的、没有名称的函数。Lambda 表达式可以捕获外部变量，从而在函数内部使用这些变量。</p>
<div class="codehilite"><pre><span></span><code><span class="p">[</span><span class="n">capture</span><span class="w"> </span><span class="n">list</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">parameter</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="k">mutable</span><span class="p">(</span><span class="n">可选</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">(</span><span class="n">可选</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>实例，lambda一般用于设置回调函数。</p>
<div class="codehilite"><pre><span></span><code><span class="n">codec</span><span class="o">-&gt;</span><span class="n">OnInputReady</span><span class="p">([</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">codec</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 捕获列表 [this, codec] 表示捕获当前对象和 codec 变量</span>
<span class="w">    </span><span class="n">xEventGroupSetBitsFromISR</span><span class="p">(...);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">...;</span>
<span class="p">});</span>
</code></pre></div>
<h2 id="stdmove">移动语义std::move</h2>
<p>在某些情况下，对象的拷贝操作可能会非常昂贵，例如对象包含大量的数据或者动态分配的内存。使用移动语义可以避免这些不必要的拷贝操作，提高程序的性能。</p>
<p>移动语义是 C++11 引入的一个重要特性，它允许将对象的资源所有权从一个对象转移到另一个对象，避免不必要的拷贝操作。std::move 是一个标准库函数，用于将左值转换为右值引用，从而触发移动构造函数或移动赋值运算符。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyVector</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">MyVector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">\</span><span class="s">"Copy constructor called</span><span class="se">\"</span><span class="s"> &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 移动构造函数</span>
<span class="w">    </span><span class="n">MyVector</span><span class="p">(</span><span class="n">MyVector</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">\</span><span class="s">"Move constructor called</span><span class="se">\"</span><span class="s"> &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">printSize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">\</span><span class="s">"Size: </span><span class="se">\"</span><span class="s"> &lt;&lt; data.size() &lt;&lt; std::endl;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="w">    </span><span class="n">MyVector</span><span class="w"> </span><span class="n">v1</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 使用 std::move 调用移动构造函数</span>
<span class="w">    </span><span class="n">MyVector</span><span class="w"> </span><span class="n">v2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v1</span><span class="p">));</span>
<span class="w">    </span><span class="n">v2</span><span class="p">.</span><span class="n">printSize</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>在上述代码中，std::move(v1) 将 v1 转换为右值引用，从而调用 MyVector 的移动构造函数。移动构造函数将 v1 的 data 资源所有权转移到 v2，避免了不必要的拷贝操作。</p>
<h2 id="_3">模版</h2>
<p>C++ 模板（Template）是一种强大的编程特性，它允许你编写泛型代码，使得代码能够在不同数据类型上重复使用。模板支持函数模板和类模板，它们能在编译时根据具体类型生成代码，从而提高代码的复用性和灵活性。</p>
<h3 id="_4">函数模版</h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//template &lt;typename T&gt;：这是函数模板的声明。T 是类型参数，表示函数可以处理任何类型。</span>
<span class="c1">//T add(T a, T b)：定义了一个接受两个 T 类型参数并返回一个 T 类型结果的函数。</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 调用模板函数，类型为 int</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="w"> </span><span class="mf">5.5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 调用模板函数，类型为 double</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_5">类模版</h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setValue</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">//template &lt;typename T&gt;：定义类模板，T 是类型参数。</span>
<span class="c1">//T value：类中的成员变量 value 是类型 T。</span>
<span class="c1">//setValue(T v) 和 getValue()：成员函数也使用模板类型 T。</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">;</span>
<span class="w">    </span><span class="n">intBox</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">intBox</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 输出：5</span>

<span class="w">    </span><span class="n">Box</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doubleBox</span><span class="p">;</span>
<span class="w">    </span><span class="n">doubleBox</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">doubleBox</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 输出：3.14</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
  <div class="post-nav">
    <a class="prev" href="/laumy.github.io/posts/ai/小智ai语音交互简要分析.html">← 小智Ai语音交互简要分析</a>
    <a class="next" href="/laumy.github.io/posts/调试/裁剪脚本.html">裁剪脚本 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/laumy.github.io/assets/site.js"></script>
  </body>
  </html>

