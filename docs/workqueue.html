<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>workqueue - Laumyçš„æŠ€æœ¯æ ˆ</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJaxæ”¯æŒLaTeXæ•°å­¦å…¬å¼ -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumyçš„æŠ€æœ¯æ ˆ</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="è¾“å…¥å…³é”®è¯å›è½¦æœç´¢">
        </div>
        <div class="theme-toggle" title="åˆ‡æ¢ä¸»é¢˜" id="theme-toggle">â˜¾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">é¦–é¡µ</a></div>
          <div class="nav-item site-link">
            <a href="https://www.laumy.tech" target="_blank" title="è®¿é—®ä¸»ç«™">ä¸»ç«™ç‚¹:www.laumy.tech</a>
          </div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">æ–‡ç« ç›®å½•</div>
          <nav id="toc"><ul><li><a href="#api">APIæ¥å£</a><ul></ul></li><li><a href="#_1">æ•°æ®ç»“æ„</a><ul></ul></li><li><a href="#_2">åˆå§‹åŒ–</a><ul><li><a href="#workqueue-early-init">workqueue early init</a></li><li><a href="#workqueue-init">workqueue init</a></li></ul></li><li><a href="#_3">åˆ›å»ºå·¥ä½œé˜Ÿåˆ—</a><ul></ul></li><li><a href="#_4">è°ƒåº¦å·¥ä½œè¿è¡Œ</a><ul><li><a href="#_5">è§¦å‘è°ƒåº¦</a></li><li><a href="#_6">æ‰§è¡Œè°ƒåº¦</a></li></ul></li><li><a href="#_7">çº¿ç¨‹æ± åŠ¨æ€ç®¡ç†</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>workqueue</h1>
  <div class="meta">
    <span class="meta-item">
      <i class="icon">ğŸ•’</i>
      2023-03-05
    </span>
    <span class="meta-item">
      <i class="icon">ğŸ“‚</i>
      linux
    </span>
    <span class="meta-item">
      <i class="icon">ğŸ‘¤</i>
      laumy
    </span>
  </div>
  <div class="post-content"><h2 id="api">APIæ¥å£</h2>
<p>åˆå§‹åŒ–</p>
<table>
<thead>
<tr>
<th>å‡½æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td>DECLARE_WORK(n, f)</td>
<td>é™æ€å®šä¹‰ä¸€ä¸ªworkï¼Œå®é™…å°±æ˜¯å®šä¹‰ä¸€ä¸ªstruct work_structçš„å…¨å±€å˜é‡ã€‚</td>
</tr>
<tr>
<td>DECLARE_DELAYED_WORK(_work, _func)</td>
<td>é™æ€å®šä¹‰ä¸€ä¸ªworkï¼Œä¸ä¸Šé¢çš„åŒºåˆ«å°±æ˜¯workå¯ä»¥åœ¨æŒ‡å®šæ—¶é—´ä¹‹åå†ç”±çº¿ç¨‹æ¥æ‰§è¡Œã€‚</td>
</tr>
<tr>
<td>INIT_WORK(_work, _func)</td>
<td>å¯ä»¥åŠ¨æ€çš„åˆ†é…ä¸€ä¸ªstruct work_structï¼Œä½†æ˜¯è°ƒç”¨è¯¥å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ã€‚</td>
</tr>
<tr>
<td>INIT_DELAYED_WORK(_work, _func)</td>
<td>åŠ¨æ€åˆ†é…ï¼Œå»¶è¿Ÿworkæ‰§è¡Œã€‚</td>
</tr>
</tbody>
</table>
<p>è§¦å‘æ‰§è¡Œ</p>
<table>
<thead>
<tr>
<th>å‡½æ•°</th>
<th>è¯´æ˜</th>
</tr>
</thead>
<tbody>
<tr>
<td>schedule_work(struct work_struct *work)</td>
<td>è°ƒåº¦ä¸€ä¸ªworkè¿è¡Œï¼Œä¼šå°†workæŒ‚å…¥åˆ°é»˜è®¤workqueue(system_wq)ä¸­è¿è¡Œã€‚</td>
</tr>
<tr>
<td>queue_work(struct workqueue_struct *wq,struct work_struct *work)</td>
<td>è°ƒåº¦ä¸€ä¸ªworkåœ¨æŒ‡å®šçš„workqueueä¸Šè¿è¡Œã€‚</td>
</tr>
<tr>
<td>queue_delayed_work(struct workqueue_struct*wq,struct delayed_work *dwork,unsigned long delay)</td>
<td>å»¶è¿Ÿä¸€æ®µæ—¶é—´è°ƒåº¦ä¸€ä¸ªworkåœ¨æŒ‡å®šçš„workqueueä¸Šè¿è¡Œã€‚</td>
</tr>
</tbody>
</table>
<p>schedule_workå®é™…ä¸Šä¹Ÿæ˜¯è°ƒç”¨queue_workï¼Œå°†å…¶wqæŒ‡å®šä¸ºsystem_wqï¼Œåœ¨workqueue_init_earlyè¿›è¡Œåˆå§‹åŒ–å·¥ä½œé˜Ÿåˆ—æ—¶ä¼šé»˜è®¤åˆ›å»ºå‡ ä¸ªworkqueueã€‚</p>
<p>åˆ›å»ºworkqueue</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>create_workqueue(name)</td>
<td>åˆ›å»ºä¸€ä¸ªæ™®é€šçš„workqueueï¼Œè¯¥workqueueå°†åœ¨æ¯ä¸ªcpuä¸Šéƒ½åˆ›å»ºä¸€ä¸ªworker threadï¼Œåæ–‡ä¼šæè¿°ã€‚</td>
</tr>
<tr>
<td>create_freezable_workqueue(name)</td>
<td>åœ¨suspendçš„æ—¶å€™ä¸å†»ç»“å†…æ ¸çº¿ç¨‹çš„worker thread</td>
</tr>
<tr>
<td>create_singlethread_workqueue(name)</td>
<td>åªæœ‰ä¸€ä¸ªthreadï¼Œæ‰€æœ‰çš„workåœ¨threadä¸­æ’é˜Ÿè¿è¡Œã€‚</td>
</tr>
<tr>
<td>cstruct workqueue_struct *alloc_workqueue(const char *fmt,unsigned int flags,int max_active, ...)</td>
<td>æœ€åŸå§‹çš„åˆ†é…å‡½æ•°ï¼Œä¸Šé¢ä¸‰ä¸ªå‡½æ•°éƒ½ä¼šè°ƒç”¨åˆ°è¯¥å‡½æ•°ï¼Œå…¶ä¸­ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯å·¥ä½œé˜Ÿåˆ—ä¸­å½“å‰èƒ½å¤Ÿè¿è¡Œçš„æœ€å¤§workæ•°é‡ï¼Œå½“å¤§äºè¯¥å€¼å…¶workå°†ä¼šè¢«æ·»åŠ åˆ°æœªæ¿€æ´»çš„é“¾è¡¨ä¸­ç­‰å¾…è¿è¡Œçš„workå®Œæˆåæ‰èƒ½è¿è¡Œã€‚ä¸Šé¢ä¸‰ä¸ªå‡½æ•°çš„max_activeéƒ½æ˜¯1,å› æ­¤workéƒ½æ˜¯æ’é˜Ÿè¿è¡Œçš„ï¼Œå› æ­¤è¦å¹¶è¡Œworkä½¿ç”¨alloc_workqueueæ¥åˆ›å»ºã€‚</td>
</tr>
</tbody>
</table>
<p>é™¤äº†ç³»ç»Ÿå®šä¹‰çš„å‡ ä¸ªé»˜è®¤workqueueï¼Œç”¨æˆ·å¯ä»¥è°ƒç”¨ä¸Šé¢çš„å‡½æ•°è‡ªå·±åˆ›å»ºworkqueueï¼Œå¯¹äºqueue_workæ¥è¯´ä¸€èˆ¬ç”¨å°±å¯ä»¥æŒ‡å®šä½¿ç”¨è‡ªå·±åˆ›å»ºçš„workqueueã€‚</p>
<h2 id="_1">æ•°æ®ç»“æ„</h2>
<p><a href="http://8.134.108.235/wp-content/uploads/2023/11/wp_editor_md_c819144f78a2488094de7ae1c6fcde74.jpg"><img alt="" src="images/wp_editor_md_c819144f78a2488094de7ae1c6fcde74.jpg"/></a></p>
<p>workqueueæ¶‰åŠåˆ°å‡ ä¸ªé‡è¦çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç»“åˆä¸‹é¢çš„å›¾æ¥è¿›è¡Œç†è§£ã€‚</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_66ba0133a9799ad0f14a278b7a3d6358.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_66ba0133a9799ad0f14a278b7a3d6358.jpg"/></a></p>
<ul>
<li>work_struct: â€œä»»åŠ¡é¡¹â€ï¼Œä¹Ÿå¯ä»¥ç§°ä¸ºå·¥ä½œï¼Œå¡«å……äº†ç”¨æˆ·å®é™…è¦å¤„ç†å‡½æ•°ä»»åŠ¡ã€‚åˆå§‹åŒ–åçš„workå°†ä¼šè¢«æ·»åŠ åˆ°worker_poolä¸­é“¾è¡¨ä¸Šã€‚</li>
<li>workqueue_structï¼šâ€œé¡¹ç›®â€ï¼›ä»»åŠ¡ç”±é‚£ä¸ªå·¥ä½œé˜Ÿåˆ—è´Ÿè´£è¿è¡Œï¼Œå³å¯ç†è§£ä¸ºä»»åŠ¡æ‰€å±â€œé¡¹ç›®â€ï¼Œâ€œé¡¹ç›®â€æ˜¯å¤šä¸ªä»»åŠ¡çš„é›†åˆã€‚ä¸€ä¸ªå·¥ä½œé˜Ÿåˆ—å¯ä»¥å¤„ç†å¤šä¸ªä»»åŠ¡ã€‚ç³»ç»Ÿåœ¨åˆå§‹åŒ–æ—¶é»˜è®¤åˆ›å»ºäº†ä¸€äº›å·¥ä½œé˜Ÿåˆ—å¦‚system_wq,system_highpri_wqç­‰ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥è°ƒç”¨alloc_workqueueæ¥åˆ›å»ºä¸€ä¸ªå·¥ä½œé˜Ÿåˆ—ã€‚ç³»ç»Ÿå®šä¹‰äº†ä¸€ä¸ªå…¨å±€çš„é“¾è¡¨workqueuesï¼Œæ‰€æœ‰çš„å·¥ä½œé˜Ÿåˆ—éƒ½è¿æ¥åˆ°è¯¥é“¾è¡¨ä¸Šã€‚</li>
<li>worker:â€œå·¥äººâ€ï¼›æ¯ä¸€ä¸ªworkerå¯¹åº”ä¸€ä¸ªtaskï¼Œè¯¥workerä¸Šå¯èƒ½æŒ‚æ¥ç€å¤šä¸ªç­‰å¾…å¤„ç†çš„ä»»åŠ¡ã€‚</li>
<li>worker_pool:â€œå·¥å‚â€ï¼›ä¸€ä¸ªâ€œå·¥å‚â€é‡Œé¢å¤šä¸ªâ€œå·¥äººâ€ï¼Œå·¥å‚è¿˜æ²¡è¢«è§¦å‘çš„ä»»åŠ¡éƒ½æŒ‚åœ¨worklisté“¾è¡¨ä¸Šã€‚</li>
<li>pool_workqueue:â€œå‚é•¿â€ï¼›å»ºç«‹workqueue_structå’Œpool_workqueueçš„è”ç³»ã€‚</li>
</ul>
<p>workqueueæ˜¯æŠŠworkæ¨è¿Ÿåˆ°ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ä¸­å»æ‰§è¡Œï¼Œç»“åˆä¸Šé¢çš„æ•°æ®ç»“æ„å…³ç³»å…·ä½“æè¿°å°±æ˜¯ï¼šä¸€ä¸ªé¡¹ç›®ï¼ˆworkqueueï¼‰ä¸Šå¯ä»¥å¤„ç†å¾ˆå¤šä¸ªå·¥ä½œï¼ˆwork)ï¼Œè¿™äº›é¡¹ç›®ï¼ˆworkqueueï¼‰çš„å·¥ä½œï¼ˆwork)äº¤ç»™å·¥å‚è´Ÿè´£äººï¼ˆpool_wokerqueueï¼‰åè°ƒåˆ°ä¸€ä¸ªå·¥å‚ï¼ˆwoker_poolï¼‰å»ç”Ÿäº§ï¼Œå·¥å‚ï¼ˆworker_poolï¼‰ä¸­å½“æ”¶åˆ°è¦å¯åŠ¨å¤„ç†å·¥ä½œï¼ˆworkï¼‰æ—¶ï¼Œå°±å®‰æ’ä¸€ä¸ªå·¥äººï¼ˆworkerï¼‰å»æ‰§è¡Œå·¥ä½œï¼ˆworkï¼‰ã€‚</p>
<p>worker_poolæ˜¯ç®¡ç†äº†å¤šä¸ªworker,æ¯ä¸ªworkerå¯¹åº”ä¸€ä¸ªtaskã€‚å› æ­¤æˆ‘ä»¬ä¹Ÿç§°worker_poolä¸ºçº¿ç¨‹æ± ã€‚çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°é‡æ˜¯å¯ä»¥åŠ¨æ€åˆ†é…æˆ–ç§»é™¤ã€‚çº¿ç¨‹æ± å¯ä»¥åˆ†ä¸ºä¸ç‰¹å®šCPUç»‘å®šçš„çº¿ç¨‹æ± å’Œæ²¡æœ‰ç»‘å®šçš„çº¿ç¨‹æ± ä¸¤ç±»ã€‚</p>
<ul>
<li>Bound çº¿ç¨‹æ± ï¼šè¿™ç§çº¿ç¨‹æ± æ ¹æ®ä¼˜å…ˆçº§åˆ†ä¸ºé«˜ä½ä¸¤ç±»ï¼Œåˆ†åˆ«ç”¨æ¥å¤„ç†é«˜ä¼˜å…ˆçº§å’Œä½ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚ç»‘å®šçš„çº¿ç¨‹æ± åœ¨ç³»ç»Ÿä¸­ä½¿ç”¨å…¨å±€æ•°ç»„å®šä¹‰å¥½äº†ï¼ŒDEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools), å–å†³äºcpuçš„æ•°é‡ï¼Œæ ¹æ®é«˜ä½ä¼˜å…ˆçº§é‚£ä¹ˆå¦‚æœæœ‰nä¸ªcpuï¼Œé‚£ä¹ˆå°±å¯¹åº”æœ‰2nä¸ªworker_poolã€‚</li>
<li>Unboundçº¿ç¨‹æ± ï¼šè¿™ç±»çº¿ç¨‹æ± å¯ä»¥è¿è¡Œåœ¨ä»»æ„cpuä¸Šï¼Œå…¶worker_poolæ˜¯åŠ¨æ€åˆ›å»ºçš„ï¼Œåˆ›å»ºworker_poolæ—¶ä¼šåˆ¤æ–­å…¶çº¿ç¨‹æ± ç†Ÿæ‚‰ï¼Œå¦‚çº¿ç¨‹ä¼˜å…ˆçº§niceï¼Œå¦‚æœå±æ€§ä¸€æ ·å°±å†é‡å¤åˆ›å»ºï¼Œå…±æœ‰ä¸€ä¸ªçº¿ç¨‹æ± ã€‚</li>
</ul>
<p>worker_poolçº¿ç¨‹æ± ä¸workqueueæ˜¯æ²¡æœ‰ç›´æ¥è”ç³»çš„ï¼Œå½“ç”¨æˆ·åˆ›å»ºä¸€ä¸ªworkqueueåªæ˜¯é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹æ± è€Œå·²ï¼Œå¯¹äºboundç±»å‹çš„çº¿ç¨‹æ± ï¼Œæ¯ä¸ªcpuæœ‰ä¸¤ä¸ªçº¿ç¨‹æ± å¯¹äºé«˜ä½ä¼˜å…ˆçº§ï¼›å¯¹åº”unboundç±»å‹çº¿ç¨‹æ± ï¼Œæ ¹æ®å±æ€§åŠ¨æ€åˆ›å»ºçº¿ç¨‹æ± ã€‚åˆ›å»ºçº¿ç¨‹æ± åï¼Œé»˜è®¤æƒ…å†µä¸‹çº¿ç¨‹æ± ä¼šåˆ›å»ºä¸€ä¸ªworker çº¿ç¨‹æ¥å¤„ç†workï¼Œéšç€workæ•°é‡çš„æäº¤ï¼Œwoker_poolåŠ¨æ€çš„è°ƒæ•´workeræ¥åº”å¯¹workæ•°é‡ã€‚ åç»­çº¦å®šworkqueueç®€å†™wqï¼›worker_poolç®€å†™poolï¼Œä¹Ÿç§°ä¸ºçº¿ç¨‹æ± ï¼›pool_workqueueç®€å†™pwqï¼›</p>
<h2 id="_2">åˆå§‹åŒ–</h2>
<p>workqueueåˆå§‹åŒ–åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œåˆ†åˆ«ä¸ºæ—©æœŸworkqueue_init_earlyå’Œworkqueue_initã€‚</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b3c939d6f6f43c427a05211704227723.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_b3c939d6f6f43c427a05211704227723.jpg"/></a></p>
<h3 id="workqueue-early-init">workqueue early init</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">workqueue_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">std_nice</span><span class="p">[</span><span class="n">NR_STD_WORKER_POOLS</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-20</span><span class="w"> </span><span class="p">};</span>
<span class="n">pwq_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">pool_workqueue</span><span class="p">,</span><span class="w"> </span><span class="n">SLAB_PANIC</span><span class="p">);</span>

<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_unbound_cpumask</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">));</span>
<span class="w">    </span><span class="n">cpumask_copy</span><span class="p">(</span><span class="n">wq_unbound_cpumask</span><span class="p">,</span><span class="w"> </span><span class="n">housekeeping_cpumask</span><span class="p">(</span><span class="n">hk_flags</span><span class="p">));</span>

<span class="w">    </span><span class="c1">//é™æ€ä¸ºæ¯ä¸ªcpuåˆ›å»ºä¸¤ä¸ªçº¿ç¨‹æ± ï¼Œç”¨äºå¤„ç†é«˜ä¼˜å…ˆçº§å’Œæ™®é€šä¼˜å…ˆçº§çš„workã€‚</span>
<span class="w">    </span><span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="p">;</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//ä¸ºæ¯ä¸ªcpuå®šä¹‰äº†ä¸€ä¸ªé™æ€çš„worker_pool[2]ï¼Œè¿™é‡Œéå†æ•°ç»„è¿›è¡Œåˆå§‹åŒ–ï¼Œè®¾å®šçº¿ç¨‹æ± è¿è¡Œçš„cpuã€niceå€¼ä»¥åŠæ‰€å±nodeèŠ‚ç‚¹ã€‚å…¶ä¸­niceå€¼ä¼šæœ‰å·®åˆ«ï¼Œä¾æ¬¡ä¸º0å’Œ-20ï¼Œè¿™å°±å†³å®šäº†ï¼Œè¿™ä¸¤ä¸ªçº¿ç¨‹æ± çš„ä¼˜å…ˆçº§è¿è¡Œä¼˜å…ˆçº§æ˜¯ä¸åŒçš„ã€‚</span>
<span class="w">        </span><span class="n">for_each_cpu_worker_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">init_worker_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span><span class="w"> </span>
<span class="c1">//åˆå§‹åŒ–worker_poolï¼Œåˆ†é…struct workqueue_attrs</span>
<span class="w">            </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpumask_copy</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="o">-&gt;</span><span class="n">cpumask</span><span class="p">,</span><span class="w"> </span><span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="w">            </span><span class="c1">//è®¾ç½®è¦è¿è¡Œçš„cpuï¼Œçº¿ç¨‹æ± æ˜¯ç»‘å®šåœ¨cpuä¸Šçš„ã€‚</span>
<span class="w">            </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">attrs</span><span class="o">-&gt;</span><span class="n">nice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std_nice</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w"> </span><span class="c1">//è®¾ç½®çº¿ç¨‹çš„ä¼˜å…ˆçº§</span>
<span class="w">            </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span><span class="w"> </span><span class="c1">//è®¾ç½®æ‰€å±nodeèŠ‚ç‚¹</span>

<span class="w">            </span><span class="c1">//åˆ†é…worker pool id</span>
<span class="w">            </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_pool_mutex</span><span class="p">);</span>
<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">worker_pool_assign_id</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>
<span class="w">            </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_pool_mutex</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//é™¤äº†é™æ€ä¸ºæ¯ä¸ªcpuåˆ›å»ºä¸¤ä¸ªçº¿ç¨‹æ± å¤–ï¼Œè¿˜å¯ä»¥åˆ›å»ºè·Ÿcpuä¸ç»‘å®šçš„çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± å°†ä¼š//åŠ¨æ€çš„åˆ›å»ºï¼Œè¿™é‡Œå…ˆåˆ†é…çº¿ç¨‹æ± çš„å±æ€§ã€‚</span>

<span class="w">    </span><span class="c1">//åŠ¨æ€åˆ›å»ºçš„çº¿ç¨‹æ± åˆåˆ†ä¸ºä¸¤ç±»ï¼Œåˆ†åˆ«æ˜¯è·ŸnodeèŠ‚ç‚¹ç»‘å®šçš„çº¿ç¨‹æ± å’Œè·ŸnodeèŠ‚ç‚¹ä¸ç»‘å®š</span>
<span class="c1">//ä¸”çº¿ç¨‹æ± ä¸­ä»»åŠ¡è¿è¡ŒæŒ‰é¡ºåºæ‰§è¡Œçš„å·¥ä½œé˜Ÿåˆ—ã€‚</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NR_STD_WORKER_POOLS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">workqueue_attrs</span><span class="w"> </span><span class="o">*</span><span class="n">attrs</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//ç”¨äºPer-node çº¿ç¨‹æ± çš„å±æ€§åˆ›å»º</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue_attrs</span><span class="p">()));</span><span class="w"> </span><span class="c1">//åˆ†é…ä¸€ä¸ªworkqueue_attrsã€‚</span>
<span class="w">        </span><span class="n">attrs</span><span class="o">-&gt;</span><span class="n">nice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std_nice</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">//ä¹Ÿæœ‰ä¸¤ä¸ªä¼˜å…ˆçº§ï¼Œå› æ­¤æ¯ä¸ªèŠ‚ç‚¹è‡³å°‘ä¹Ÿä¼šåˆ›å»ºä¸¤ä¸ªçº¿ç¨‹æ± </span>
<span class="w">        </span><span class="n">unbound_std_wq_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attrs</span><span class="p">;</span><span class="c1">//å±æ€§èµ‹å€¼åˆ°å…¨å±€å˜é‡ä¸­ä¿å­˜ã€‚</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * An ordered wq should have only one pwq as ordering is</span>
<span class="cm">         * guaranteed by max_active which is enforced by pwqs.</span>
<span class="cm">         * Turn off NUMA so that dfl_pwq is used for all nodes.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="c1">//ç”¨äºå·¥ä½œé˜Ÿåˆ—ä¸­ä»»åŠ¡é¡ºåºæ‰§è¡Œçº¿ç¨‹æ± å±æ€§åˆ›å»º</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue_attrs</span><span class="p">()));</span>
<span class="w">        </span><span class="n">attrs</span><span class="o">-&gt;</span><span class="n">nice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std_nice</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">//é«˜ä½ä¼˜å…ˆçº§çš„çº¿ç¨‹æ± </span>
<span class="w">        </span><span class="n">attrs</span><span class="o">-&gt;</span><span class="n">no_numa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">//ä¸èŠ‚ç‚¹æ— å…³</span>
<span class="w">        </span><span class="n">ordered_wq_attrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attrs</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//ç³»ç»Ÿå°†é»˜è®¤åˆ›å»ºå‡ ä¸ªå·¥ä½œé˜Ÿåˆ—ã€‚</span>
<span class="w">    </span><span class="n">system_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events"</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_highpri_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_highpri"</span><span class="p">,</span><span class="w"> </span><span class="n">WQ_HIGHPRI</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_long_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_long"</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_unbound_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_unbound"</span><span class="p">,</span><span class="w"> </span><span class="n">WQ_UNBOUND</span><span class="p">,</span>
<span class="w">                        </span><span class="n">WQ_UNBOUND_MAX_ACTIVE</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_freezable_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_freezable"</span><span class="p">,</span>
<span class="w">                          </span><span class="n">WQ_FREEZABLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_power_efficient_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_power_efficient"</span><span class="p">,</span>
<span class="w">                          </span><span class="n">WQ_POWER_EFFICIENT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">system_freezable_power_efficient_wq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">"events_freezable_power_efficient"</span><span class="p">,</span>
<span class="w">                          </span><span class="n">WQ_FREEZABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WQ_POWER_EFFICIENT</span><span class="p">,</span>
<span class="w">                          </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">system_wq</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">system_highpri_wq</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">system_long_wq</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="o">!</span><span class="n">system_unbound_wq</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">system_freezable_wq</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="o">!</span><span class="n">system_power_efficient_wq</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="o">!</span><span class="n">system_freezable_power_efficient_wq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>åœ¨workqueue_init_earlyçš„åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œå…ˆåˆå§‹åŒ–æ¯ä¸ªcpuä¸Šçš„çº¿ç¨‹æ± ï¼Œåœ¨ç³»ç»Ÿä¸­ä¸ºæ¯ä¸ªcpuä¸Šé™æ€å®šä¹‰æ¯ä¸ªcpuä¸Šå®šä¹‰äº†ä¸€ä¸ªstruct worker_pool cpu_worker_pools[2]çš„æ•°ç»„(DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools))ï¼Œå³æ¯ä¸ªcpuä¸Šæœ‰ä¸¤ä¸ªçº¿ç¨‹æ± ï¼Œåˆ†åˆ«ç”¨äºé«˜ä¼˜å…ˆçº§å’Œä½ä¼˜å…ˆçº§ã€‚ é™¤äº†ä¸ºæ¯ä¸ªCPUç»‘å®šä¸¤ä¸ªé«˜ä½ä¼˜å…ˆçº§çš„çº¿ç¨‹æ± å¤–ï¼Œè¿˜å¯ä»¥åŠ¨æ€çš„åˆ›å»ºçº¿ç¨‹æ± ï¼ŒåŠ¨æ€åˆ›å»ºçš„çº¿ç¨‹æ± å¯åˆ†ä¸ºè·Ÿå†…å­˜nodeç»‘å®šå’Œè·ŸnodeèŠ‚ç‚¹ä¸ç»‘å®šä¸”å·¥ä½œé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡é¡ºåºæ‰§è¡Œï¼Œæ‰€ä»¥ç³»ç»Ÿå…ˆä¸ºæ²¡æœ‰ç»‘å®šcpuç±»å‹çš„çº¿ç¨‹æ± å…ˆåˆ†é…å¥½å±æ€§ï¼Œå­˜å‚¨åœ¨unbound_std_wq_attrs[2]å’Œordered_wq_attrs[2]ä¸­ï¼Œä»å±æ€§çš„æ•°ç»„å®šä¹‰ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæ¯ä¸€ç±»ä¹Ÿæœ‰ä¸¤ä¸ªçº¿ç¨‹æ± å¯¹åº”çš„æ˜¯é«˜ä¼˜å…ˆçº§å’Œæ™®é€šä¼˜å…ˆçº§ã€‚</p>
<h3 id="workqueue-init">workqueue init</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">workqueue_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">workqueue_struct</span><span class="w"> </span><span class="o">*</span><span class="n">wq</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">bkt</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * It\'d be simpler to initialize NUMA in workqueue_init_early() but</span>
<span class="cm">     * CPU to node mapping may not be available that early on some</span>
<span class="cm">     * archs such as power and arm64. As per-cpu pools created</span>
<span class="cm">     * previously could be missing node hint and unbound pools NUMA</span>
<span class="cm">     * affinity, fix them up.</span>
<span class="cm">     *</span>
<span class="cm">     * Also, while iterating workqueues, create rescuers if requested.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//å¯¹numaçš„wqåˆå§‹åŒ–ï¼ŒåµŒå…¥å¼è®¾å¤‡ä¸€èˆ¬åªæœ‰ä¸€ä¸ªnodeï¼Œæ‰€ä»¥å¯¹äºnumaçš„æˆ‘ä»¬æš‚ä¸æ·±å…¥</span>
<span class="w">    </span><span class="n">wq_numa_init</span><span class="p">();</span>

<span class="w">    </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_pool_mutex</span><span class="p">);</span>

<span class="w">    </span><span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">for_each_cpu_worker_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">workqueues</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">wq_update_unbound_numa</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span><span class="w"> </span><span class="n">smp_processor_id</span><span class="p">(),</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">        </span><span class="n">WARN</span><span class="p">(</span><span class="n">init_rescuer</span><span class="p">(</span><span class="n">wq</span><span class="p">),</span>
<span class="w">             </span><span class="err">\</span><span class="s">"workqueue: failed to create early rescuer for %s</span><span class="se">\"</span><span class="s">,</span>
<span class="w">             </span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_pool_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">éå†CPU</span><span class="err">ï¼Œ</span><span class="n">ä¸ºæ¯ä¸ªç»‘å®šcpuçš„çº¿ç¨‹æ± åˆ›å»ºä¸€ä¸ªworker</span>
<span class="w">    </span><span class="cm">/* create the initial workers */</span>
<span class="w">    </span><span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">for_each_cpu_worker_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">POOL_DISASSOCIATED</span><span class="p">;</span>
<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">create_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">   </span><span class="c1">//ä¸ºunboundç±»å‹çš„åˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ± ï¼Ÿ</span>
<span class="w">    </span><span class="n">hash_for_each</span><span class="p">(</span><span class="n">unbound_pool_hash</span><span class="p">,</span><span class="w"> </span><span class="n">bkt</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">hash_node</span><span class="p">)</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">create_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>

<span class="w">    </span><span class="n">wq_online</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">wq_watchdog_init</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_3">åˆ›å»ºå·¥ä½œé˜Ÿåˆ—</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_1ccdb0e599edf5672277bbf0d36a0714.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_1ccdb0e599edf5672277bbf0d36a0714.jpg"/></a></p>
<p>åˆ›å»ºå·¥ä½œé˜Ÿåˆ—ä¸»è¦çš„å·¥ä½œå°±æ˜¯ç¡®å®šå¥½å·¥ä½œé˜Ÿåˆ—ä½¿ç”¨çš„çº¿ç¨‹æ± ï¼ˆworker_poolï¼‰ï¼Œå·¥ä½œé˜Ÿåˆ—åˆ†ä¸ºBOUND CPUç±»å‹å’ŒUNBOUND CPUç±»å‹ã€‚ç”¨æˆ·å¯ä»¥è°ƒç”¨create_workqueueã€create_freezable_workqueueä»¥åŠcreate_singlethread_workqueueç­‰APIæ¥å£æ¥åˆ›å»ºé˜Ÿåˆ—ï¼Œè¿™äº›APIæ¥å£æœ€ç»ˆéƒ½ä¼šè°ƒç”¨alloc_workqueueæ¥å®ç°ï¼Œåªä¸è¿‡æ¯ä¸ªå‡½æ•°ä¼ å…¥çš„å‚æ•°æ˜¯ä¸ä¸€æ ·çš„ï¼Œå¯¹äºåä¸¤ä¸ªå‡½æ•°å°±æ˜¯UNBOUNDç±»å‹ï¼ŒåŒæ—¶create_singlethread_workqueueè¿˜æ˜¯ORDEREDç±»å‹ï¼Œè¯¥ç±»å‹çš„å·¥ä½œé˜Ÿåˆ—è¡¨ç¤ºå…¶æ‰€å¤„ç†çš„å·¥ä½œéƒ½æ˜¯æŒ‰é¡ºåºæ’é˜Ÿè¿è¡Œçš„ã€‚ åœ¨è§£é‡Šåˆ›å»ºå·¥ä½œé˜Ÿåˆ—çš„æµç¨‹å‰æˆ‘ä»¬å†æ¥è¯´æ˜ä¸‹workqueueã€pool_workqueueã€worker_poolä¹‹é—´çš„å…³ç³»ã€‚worker_poolæ˜¯çº¿ç¨‹çš„é›†åˆï¼Œå¯ä»¥å®é™…å¤„ç†ä»»åŠ¡çš„ï¼ŒæŒ‚åœ¨workqueueä¸Šçš„å·¥ä½œæœ€ç»ˆéƒ½ä¼šäº¤ç”±worker_poolæ¥å¤„ç†ï¼Œä½†æ˜¯workqueueå’Œworker_poolå¹¶æ²¡æœ‰ç›´æ¥ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œè€Œæ˜¯å¤šå¯¹å¤šçš„å…³ç³»ï¼Œå¯ä»¥ç†è§£è¦ç”Ÿäº§çš„äº§å“å’Œå·¥å‚æ˜¯è§£è€¦çš„ï¼Œå·¥å‚æ˜¯ä¸€ä¸ªå…±äº«çš„æ± å­ï¼Œå› æ­¤è¦åšä¸€ä¸ªäº§å“ï¼ˆworkqueueï¼‰å’Œå·¥å‚äº§çº¿ç”Ÿäº§ï¼ˆworker_poolï¼‰ä¹‹é—´çš„è”ç³»éœ€è¦ä¸ªä¸­é—´äººæ¥å¼ ç½—ï¼Œæ‰€ä»¥pool_workqueueå°±æ˜¯è¿™ä¸­é—´äººï¼Œç”¨äºç¡®å®šåˆ¶ä½œè¿™ä¸ªäº§å“é€‰æ‹©é‚£ä¸ªå·¥å‚ã€‚ Workqueueå¦‚ä½•è·å–åˆ°worker_pool? ï¼ˆ1ï¼‰å¯¹äºbound workqueueï¼Œæ˜¯æ¯ä¸ªcpuéƒ½ç»‘å®šäº†ä¸¤ä¸ªé«˜ä¼˜å…ˆçº§å’Œæ™®é€šä¼˜å…ˆçº§çš„çº¿ç¨‹æ± ï¼Œè¿™äº›cpuä¸Šçš„çº¿ç¨‹æ± éƒ½æ˜¯å…±äº«çš„ï¼Œå› æ­¤å¯¹äºworkqueueéœ€è¦ä¸ºæ¯ä¸ªcpuçš„æ¯ä¸ªçº¿ç¨‹æ± åˆ†é…ä¸€ä¸ªpool_workqueueæ¥å¯¹åº”åˆ°çº¿ç¨‹æ± ï¼Œå³è¯¥workqueueéœ€è¦åˆ†é…2*cpuä¸ªæ•°çš„pool_workqueueï¼Œpool_workqueueä¸worker_poolæ˜¯ä¸€ä¸€å¯¹åº”çš„å…³ç³»ã€‚åœ¨alloc_workqueueè°ƒç”¨alloc_percpuæ¥åˆ†é…pwqï¼Œç„¶åéå†æ¯ä¸ªcpuè·å–åˆ°worker_poolï¼Œå»ºç«‹å™¨pwq,wq,poolä¹‹é—´çš„è”ç³»ã€‚ ï¼ˆ2ï¼‰å¯¹äºunbound workqueueï¼Œå°±ç¨å¾®å¤æ‚äº›å› ä¸ºworkqueueè¦æ‰¾çš„çº¿ç¨‹æ± æ²¡æœ‰ä¸cpuè¿›è¡Œç»‘å®šï¼Œä¸åƒbound workqueueå®šä¹‰å¥½äº†worker_poolï¼Œæ‰€ä»¥äº†workqueueéœ€è¦åŠ¨æ€çš„åˆ†é…åˆ›å»ºpwqï¼Œpoolã€‚è€Œunbound workqueueåˆåˆ†ä¸ºä¸¤ç§ç±»å‹æ’é˜Ÿè¿è¡Œçš„å·¥ä½œé˜Ÿåˆ—å’Œæ ‡å‡†çš„å·¥ä½œé˜Ÿåˆ—ï¼Œæ’é˜Ÿè¿è¡Œçš„å·¥ä½œé˜Ÿåˆ—æ‰€æœ‰çš„å·¥ä½œå°†æ’é˜Ÿä¾æ¬¡è¿è¡Œè€Œæ ‡å‡†çš„å·¥ä½œé˜Ÿåˆ—æ„å‘³è¿™å¯å¹¶å‘ã€‚ä¸¤ç§ç±»å‹çš„é˜Ÿåˆ—å±æ€§åˆ†åˆ«å­˜å‚¨åœ¨ordered_wq_attrs[]å’Œunbound_std_wq_attrs[]ä¸¤ä¸ªæ•°ç»„ä¸­ã€‚å½“æ£€æŸ¥åˆ°workqueueæ˜¯unboundç±»å‹åï¼Œå°±è°ƒç”¨apply_workqueue_attrsåˆ†åˆ«ä¼ å…¥ä¸åŒçš„å±æ€§åˆ›å»ºçº¿ç¨‹æ± ã€‚ A.unbound stdç±»å‹ï¼šä¸å†…å­˜èŠ‚ç‚¹nodeæœ‰å…³è”ï¼Œå°†ä¼šä¸ºæ¯ä¸ªnodeèŠ‚ç‚¹åˆ›å»ºé«˜ä¼˜å…ˆçº§å’Œæ™®é€šä¼˜å…ˆçº§çš„çº¿ç¨‹æ± ï¼Œä¹‹æ‰€ä»¥è¿™ä¹ˆåšæ˜¯å› ä¸ºä¸åŒçš„nodeèŠ‚ç‚¹ä¹‹é—´åˆ‡ä¼šå¸¦æ¥æ€§èƒ½æŸè€—ï¼Œå› æ­¤æ¯ä¸ªnodeéƒ½åˆ›å»º2ä¸ªçº¿ç¨‹æ± ã€‚ B.unbound orderedç±»å‹ï¼šä¸å†…å­˜èŠ‚ç‚¹nodeæ²¡æœ‰å…³è”äº†ï¼Œå¤šä¸ªåŒä¸€ä¼˜å…ˆçº§çš„workqueueå…±äº«ä¸€ä¸ªworker_poolã€‚</p>
<p><a href="http://8.134.108.235/wp-content/uploads/2023/11/wp_editor_md_66ba0133a9799ad0f14a278b7a3d6358.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_66ba0133a9799ad0f14a278b7a3d6358.jpg"/></a></p>
<h2 id="_4">è°ƒåº¦å·¥ä½œè¿è¡Œ</h2>
<h3 id="_5">è§¦å‘è°ƒåº¦</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_287cf369c9fc86074e86585182ac7c09.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_287cf369c9fc86074e86585182ac7c09.jpg"/></a></p>
<p>è§¦å‘è°ƒåº¦æœ€åéƒ½ä¼šè°ƒç”¨åˆ°_queue_workæ¥æ‰§è¡Œï¼Œåªæ˜¯æ ¹æ®ä¸åŒçš„åœºæ™¯æœ‰ä¸åŒçš„å‚æ•°å¯é€‰æ‹©é…ç½®ã€‚å¯¹äºå¸¸ç”¨çš„queue_work(struct workqueue_struct *wq,struct work_struct *work)æ¥è¯´æ˜¯å°†worké€’äº¤åˆ°æŒ‡å®šçš„wqæ¥è¿è¡Œï¼Œä¸€èˆ¬ç”¨æˆ·è‡ªå·±åˆ›å»ºçš„wqï¼Œè€Œschedule_work(struct work_struct *work)åªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œå°†worké€’äº¤åˆ°é»˜è®¤çš„system_wqæ¥è¿è¡Œï¼Œqueue_workå’Œschedule_worké€’äº¤çš„workåœ¨wqä¸­å¤„ç†ï¼Œéƒ½ä¸ç»‘å®šcpuï¼Œè¿™é‡Œçš„ç»‘å®šä¸æ˜¯WQ_UNBOUND,WQ_UNBOUNDå’ŒWORK_CPU_UNBOUNDæ˜¯æœ‰åŒºåˆ«çš„ï¼ŒWQ_UNBOUNDç¡®å®šWQçš„ç±»å‹æ˜¯normal Per-CPU worker_poolè¿˜æ˜¯unbound worker_poolï¼Œç¡®å®šäº†WQçš„ç±»å‹æ‰ä½¿ç”¨WORK_CPU_UNBOUNDè¿›ä¸€éƒ¨åˆ†ç¡®å®šworkæ˜¯å¦è¦ç»‘å®šcpuè¿è¡Œã€‚</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__queue_work</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">workqueue_struct</span><span class="w"> </span><span class="o">*</span><span class="n">wq</span><span class="p">,</span>
<span class="w">             </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pool_workqueue</span><span class="w"> </span><span class="o">*</span><span class="n">pwq</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">last_pool</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">worklist</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">work_flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">req_cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * While a work item is PENDING &amp;&amp; off queue, a task trying to</span>
<span class="cm">     * steal the PENDING will busy-loop waiting for it to either get</span>
<span class="cm">     * queued or lose PENDING.  Grabbing PENDING and queueing should</span>
<span class="cm">     * happen with IRQ disabled.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">lockdep_assert_irqs_disabled</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* if draining, only works from the same workqueue are allowed */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">__WQ_DRAINING</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">is_chained_work</span><span class="p">(</span><span class="n">wq</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">retry</span><span class="p">:</span>
<span class="cm">/* pwq which will be used unless @work is executing elsewhere */</span>
<span class="c1">//å…ˆåˆ¤æ–­wq unboundè¿˜æ˜¯boundï¼Œå¦‚æœæ˜¯unboundï¼Œé‚£ä¹ˆcpué€‰æ‹©çš„èŒƒå›´éœ€è¦æ ¹æ®node</span>
<span class="c1">//èŠ‚ç‚¹æ¥é™åˆ¶ï¼Œå¦‚æœæ˜¯boundé‚£ä¹ˆcpuå°±é™å®šäº†ã€‚</span>
<span class="c1">//WQ_UNBOUNDç”¨äºåŒºåˆ†æ˜¯wqæ˜¯boundç±»å‹è¿˜æ˜¯æœªboundç±»å‹ï¼ŒWORK_CPU_UNBOUND</span>
<span class="c1">//ç”¨äºè¿›ä¸€æ­¥é™å®šwoker_poolçº¿ç¨‹æ± æ˜¯å¦æŒ‡å®šé€‰æ‹©é‚£ä¸€ä¸ªcpuã€‚</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_UNBOUND</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">req_cpu</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wq_select_unbound_cpu</span><span class="p">(</span><span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="w">        </span><span class="c1">//unboundç±»å‹ï¼Œcpuä¹Ÿæ²¡æœ‰ç»‘å®šï¼Œåˆ™é€‰æ‹©ä¸€ä¸ªcpuï¼Œä¼˜å…ˆé€‰æ‹©æœ¬åœ°cpuã€‚</span>
<span class="w">        </span><span class="n">pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unbound_pwq_by_node</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">req_cpu</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WORK_CPU_UNBOUND</span><span class="p">)</span>
<span class="w">            </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">raw_smp_processor_id</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//å¦‚æœreq_cpuç±»å‹æ˜¯WORK_CPU_UNBOUND,é‚£ä¹ˆä¹Ÿæ˜¯é€‰æ‹©å½“å‰ä»£ç è¿è¡Œçš„cpu</span>
<span class="w">        </span><span class="n">pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">cpu_pwqs</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * If @work was previously on a different pool, it might still be</span>
<span class="cm">     * running there, in which case the work needs to be queued on that</span>
<span class="cm">     * pool to guarantee non-reentrancy.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//æŸ¥è¯¢workæ˜¯å¦å·²ç»åœ¨çº¿ç¨‹æ± å†…äº†</span>
<span class="n">last_pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_work_pool</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="c1">//å¦‚æœworkå·²ç»åœ¨çº¿ç¨‹æ± ä¸­ï¼Œä¸”å½“å‰æ‰€åœ¨çš„worker_poolä¸è·å–çš„worker_poolä¸æ˜¯åŒä¸€ä¸ª</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">last_pool</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">last_pool</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker</span><span class="w"> </span><span class="o">*</span><span class="n">worker</span><span class="p">;</span>

<span class="w">        </span><span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//æŸ¥è¯¢workå¯¹åº”çš„æŒ‚åˆ°é‚£ä¸ªworkerä¸Š</span>
<span class="w">        </span><span class="n">worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">last_pool</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//å¦‚æœå½“å‰çš„workeræ‰€åœ¨çš„wqå’Œè¯·æ±‚çš„wqç›¸åŒï¼Œåˆ™è·å–å½“å‰è¿è¡Œworkerçš„pwqï¼Œ//ç›¸å½“äºå‰é¢è·å–çš„pwqè¢«è¦†ç›–æ›´æ–°äº†ï¼Œè¿™æ ·åšçš„ç›®çš„æ˜¯é˜²æ­¢workè¢«é‡å¤æ”¾åˆ°ä¸åŒçš„</span>
<span class="w">        </span><span class="c1">//çº¿ç¨‹æ± ä¸­å¤„ç†ï¼Œä¹Ÿå°±æ˜¯è¯´å½“ä¸€ä¸ªworkè¢«æŸä¸€ä¸ªçº¿ç¨‹æ± ä¸­æ¥å—å¤„ç†åï¼Œä¸€ç›´éœ€è¦ç­‰å¾…//å…¶å¤„ç†å®Œæ¯•ï¼Œä¸èƒ½æ›´æ¢å¦å¤–å¦å¤–ä¸€ä¸ªçº¿ç¨‹æ± worker_poolã€‚</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">worker</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_pwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">wq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_pwq</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* meh... not running there, queue here */</span>
<span class="w">            </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * pwq is determined and locked.  For unbound pools, we could have</span>
<span class="cm">     * raced with pwq release and it could already be dead.  If its</span>
<span class="cm">     * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span>
<span class="cm">     * without another pwq replacing it in the numa_pwq_tbl or while</span>
<span class="cm">     * work items are executing on it, so the retrying is guaranteed to</span>
<span class="cm">     * make forward-progress.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_UNBOUND</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="n">cpu_relax</span><span class="p">();</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">retry</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* oops */</span>
<span class="w">        </span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="s">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt</span><span class="se">\"</span><span class="s">,</span>
<span class="w">              </span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* pwq determined, queue */</span>
<span class="w">    </span><span class="n">trace_workqueue_queue_work</span><span class="p">(</span><span class="n">req_cpu</span><span class="p">,</span><span class="w"> </span><span class="n">pwq</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>

<span class="w">    </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">nr_in_flight</span><span class="p">[</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">work_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work_color_to_flags</span><span class="p">(</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">work_color</span><span class="p">);</span>
<span class="c1">//å¦‚æœworkè¿è¡Œçš„æ•°é‡è¿˜æ²¡æœ‰è¶…è¿‡é™åˆ¶ï¼Œåˆ™è·å–pwqå¯¹åº”poolçš„worklistï¼Œä¹Ÿå°±æ˜¯è¯´åé¢</span>
<span class="c1">//ä¼šå°†workåŠ å…¥åˆ°è¯¥workä¸­ï¼Œå¦‚æœæ•°é‡è¶…äº†åˆ™æŒ‚åˆ°ä¸´æ—¶pwqæœªæ¿€æ´»çš„é“¾è¡¨ä¸Šã€‚</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">max_active</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">trace_workqueue_activate_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">        </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">nr_active</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">worklist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//è·å–åˆ°çš„worklistå¦‚æœä¸Šé¢æ²¡æœ‰å·¥ä½œï¼Œåˆ™æ›´æ–°æ—¶é—´ã€‚</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">worklist</span><span class="p">))</span>
<span class="w">            </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">watchdog_ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">work_flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">WORK_STRUCT_INACTIVE</span><span class="p">;</span>
<span class="w">        </span><span class="n">worklist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">inactive_works</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">debug_work_activate</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="c1">//å°†workæ’å…¥åˆ°worklistä¸Šã€‚</span>
<span class="w">    </span><span class="n">insert_work</span><span class="p">(</span><span class="n">pwq</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="n">worklist</span><span class="p">,</span><span class="w"> </span><span class="n">work_flags</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
<span class="w">    </span><span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">insert_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pool_workqueue</span><span class="w"> </span><span class="o">*</span><span class="n">pwq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">,</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">extra_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* record the work call stack in order to print it in KASAN reports */</span>
<span class="w">    </span><span class="n">kasan_record_aux_stack_noalloc</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//è®¾ç½®flagï¼Œå¹¶å°†workæ·»åŠ åˆ°worklisté“¾è¡¨ä¸Š</span>
<span class="w">    </span><span class="cm">/* we own @work, set data and link */</span>
<span class="w">    </span><span class="n">set_work_pwq</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="n">pwq</span><span class="p">,</span><span class="w"> </span><span class="n">extra_flags</span><span class="p">);</span>
<span class="w">    </span><span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="p">);</span>
<span class="w">    </span><span class="n">get_pwq</span><span class="p">(</span><span class="n">pwq</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Ensure either wq_worker_sleeping() sees the above</span>
<span class="cm">     * list_add_tail() or we see zero nr_running to avoid workers lying</span>
<span class="cm">     * around lazily while there are works to be processed.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">smp_mb</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//å¦‚æœæ²¡æœ‰ç©ºé—²çš„workeräº†ï¼Œåˆ™å”¤é†’ä¸€ä¸ªæ–°çš„workerè¿è¡Œã€‚</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__need_more_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
<span class="w">        </span><span class="n">wake_up_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wake_up_worker</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">//ä»poolçš„idle_listä¸Šè·å–ä¸€ä¸ªworkerï¼Œè§¦å‘è¿è¡Œã€‚</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker</span><span class="w"> </span><span class="o">*</span><span class="n">worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_idle_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
<span class="w">        </span><span class="n">wake_up_process</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_6">æ‰§è¡Œè°ƒåº¦</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_67df566b6acca29b854416345bba05f5.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_67df566b6acca29b854416345bba05f5.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">worker_thread</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__worker</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker</span><span class="w"> </span><span class="o">*</span><span class="n">worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__worker</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>

<span class="cm">/* tell the scheduler that this is a workqueue worker */</span>
<span class="c1">//é€šçŸ¥è°ƒåº¦å™¨ï¼Œè¿™æ˜¯ä¸€ä¸ªworker</span>
<span class="w">    </span><span class="n">set_pf_worker</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="nl">woke_up</span><span class="p">:</span>
<span class="w">    </span><span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="cm">/* am I supposed to die? */</span>
<span class="c1">//åˆ¤æ–­è¯¥workeræ˜¯å¦è¦é€€å‡ºï¼Ÿ</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WORKER_DIE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">));</span>
<span class="w">        </span><span class="n">set_pf_worker</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="w">        </span><span class="n">set_task_comm</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="s">"kworker/dying</span><span class="se">\"</span><span class="s">);</span>
<span class="w">        </span><span class="n">ida_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">worker_ida</span><span class="p">,</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="n">worker_detach_from_pool</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="w">        </span><span class="n">kfree</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//ç¦»å¼€idleçŠ¶æ€ï¼Œè¢«å”¤é†’ä¹‹å‰éƒ½æ˜¯idleçŠ¶æ€</span>
<span class="w">    </span><span class="n">worker_leave_idle</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="nl">recheck</span><span class="p">:</span>
<span class="c1">//æ£€æŸ¥çº¿ç¨‹æ± ä¸Šæ˜¯å¦æœ‰workè¦å¤„ç†å¹¶ä¸”å½“å‰æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„workeräº†åˆ™è¿›è¡Œå¤„ç†ï¼Œå¦åˆ™</span>
<span class="c1">//è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚</span>
<span class="w">    </span><span class="cm">/* no more worker necessary? */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">need_more_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">sleep</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//å¦‚æœpoolä¸Šçš„idle workeræ•°é‡ä¸º0ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªworkerå¤‡ç”¨</span>
<span class="w">    </span><span class="cm">/* do we need to manage? */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">may_start_working</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">manage_workers</span><span class="p">(</span><span class="n">worker</span><span class="p">))</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">recheck</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * -&gt;scheduled list can only be filled while a worker is</span>
<span class="cm">     * preparing to process a work or actually processing it.</span>
<span class="cm">     * Make sure nobody diddled with it while I was sleeping.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Finish PREP stage.  We\'re guaranteed to have at least one idle</span>
<span class="cm">     * worker or that someone else has already assumed the manager</span>
<span class="cm">     * role.  This is where @worker starts participating in concurrency</span>
<span class="cm">     * management if applicable and concurrency management is restored</span>
<span class="cm">     * after being rebound.  See rebind_workers() for details.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="n">WORKER_PREP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">WORKER_REBOUND</span><span class="p">);</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//ä»çº¿ç¨‹æ± pool-&gt;worklistä¸Šçš„è·å–ä¸€ä¸ªwork</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">worklist</span><span class="p">,</span>
<span class="w">                     </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="p">,</span><span class="w"> </span><span class="n">entry</span><span class="p">);</span>

<span class="w">        </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">watchdog_ts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jiffies</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//å¦‚æœworkä¸æ˜¯linkedï¼Œè¿™é‡Œçš„linkæŒ‡çš„æ˜¯æœ‰å…³è”çš„workï¼Ÿ</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WORK_STRUCT_LINKED</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* optimization path, not strictly necessary */</span>
<span class="w">            </span><span class="c1">//å¤„ç†work</span>
<span class="w">            </span><span class="n">process_one_work</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">)))</span>
<span class="w">                </span><span class="n">process_scheduled_works</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//ç‰¹æ®Šçš„workï¼Œå…ˆå°†å…¶æ’å…¥åˆ°worker-&gt;scheduledä¸Šï¼Œç„¶åè°ƒåº¦ä¸€èµ·è¿è¡Œã€‚</span>
<span class="w">            </span><span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">            </span><span class="n">process_scheduled_works</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">keep_working</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>
<span class="c1">//ä¸€ç›´å¾ªç¯ï¼Œç›´åˆ°pool-&gt;worklistä¸Šé“¾è¡¨çš„workå¤„ç†å®Œæˆã€‚</span>

<span class="w">    </span><span class="n">worker_set_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="n">WORKER_PREP</span><span class="p">);</span>
<span class="nl">sleep</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * pool-&gt;lock is held and there\'s no work to process and no need to</span>
<span class="cm">     * manage, sleep.  Workers are woken up only while holding</span>
<span class="cm">     * pool-&gt;lock or from local cpu, so setting the current state</span>
<span class="cm">     * before releasing pool-&gt;lock is enough to prevent losing any</span>
<span class="cm">     * event.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//å¤„ç†å®Œäº†ï¼Œç»§ç»­è¿›å…¥idleçŠ¶æ€</span>
<span class="w">    </span><span class="n">worker_enter_idle</span><span class="p">(</span><span class="n">worker</span><span class="p">);</span>
<span class="w">    </span><span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_IDLE</span><span class="p">);</span>
<span class="w">    </span><span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="n">schedule</span><span class="p">();</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">woke_up</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">process_one_work</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">worker</span><span class="w"> </span><span class="o">*</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">work_struct</span><span class="w"> </span><span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pool_workqueue</span><span class="w"> </span><span class="o">*</span><span class="n">pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_work_pwq</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker_pool</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">cpu_intensive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">WQ_CPU_INTENSIVE</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">work_data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">worker</span><span class="w"> </span><span class="o">*</span><span class="n">collision</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * It is permissible to free the struct work_struct from</span>
<span class="cm">     * inside the function that is called from it, this we need to</span>
<span class="cm">     * take into account for lockdep too.  To avoid bogus \"held</span>
<span class="cm">     * lock freed\" warnings as well as problems when looking into</span>
<span class="cm">     * work-&gt;lockdep_map, make a copy and use that here.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lockdep_map</span><span class="w"> </span><span class="n">lockdep_map</span><span class="p">;</span>

<span class="w">    </span><span class="n">lockdep_copy_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="cm">/* ensure we\'re on the correct CPU */</span>
<span class="w">    </span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">POOL_DISASSOCIATED</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">             </span><span class="n">raw_smp_processor_id</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * A single work shouldn\'t be executed concurrently by</span>
<span class="cm">     * multiple workers on a single cpu.  Check whether anyone is</span>
<span class="cm">     * already processing the work.  If so, defer the work to the</span>
<span class="cm">     * currently executing one.</span>
<span class="cm">     */</span>
<span class="w">   </span><span class="c1">//æ£€æŸ¥workå·²ç»åœ¨å…¶ä»–workerä¸Šæ‰§è¡Œï¼Œåˆ™å°†workæ”¾å…¥å¯¹åº”çš„worker-&gt;scheduledä¸­å»¶åæ‰§è¡Œ</span>
<span class="w">    </span><span class="n">collision</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_worker_executing_work</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">collision</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">move_linked_works</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">collision</span><span class="o">-&gt;</span><span class="n">scheduled</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//å°†è¦æ‰§è¡Œçš„workæ›´æ–°ä¸ºå½“å‰è¦è¿è¡Œçš„work</span>
<span class="w">    </span><span class="cm">/* claim and dequeue */</span>
<span class="w">    </span><span class="n">debug_work_deactivate</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="n">hash_add</span><span class="p">(</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">busy_hash</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="p">;</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pwq</span><span class="p">;</span>
<span class="w">    </span><span class="n">work_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">work_data_bits</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_work_color</span><span class="p">(</span><span class="n">work_data</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Record wq name for cmdline and debug reporting, may get</span>
<span class="cm">     * overridden through set_worker_desc().</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">strscpy</span><span class="p">(</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">WORKER_DESC_LEN</span><span class="p">);</span>

<span class="w">    </span><span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * CPU intensive works don\'t participate in concurrency management.</span>
<span class="cm">     * They\'re the scheduler\'s responsibility.  This takes @worker out</span>
<span class="cm">     * of concurrency management and the next code block will chain</span>
<span class="cm">     * execution of the pending work items.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//å¦‚æœå½“å‰cpuæ˜¯å¯†é›†å‹ï¼Œåˆ™è®¾ç½®ä¸€ä¸ªæ ‡å¿—ä½</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_intensive</span><span class="p">))</span>
<span class="w">        </span><span class="n">worker_set_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="n">WORKER_CPU_INTENSIVE</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Wake up another worker if necessary.  The condition is always</span>
<span class="cm">     * false for normal per-cpu workers since nr_running would always</span>
<span class="cm">     * be &gt;= 1 at this point.  This is used to chain execution of the</span>
<span class="cm">     * pending work items for WORKER_NOT_RUNNING workers such as the</span>
<span class="cm">     * UNBOUND and CPU_INTENSIVE ones.</span>
<span class="cm">     */</span>
<span class="c1">//å†æ¬¡æ£€æŸ¥ï¼Œæ˜¯å¦éœ€è¦wake upå¦å¤–çš„workerï¼Œå¯¹äºnormal per-cpu workeræ€»ä¸ä¼šè§¦å‘ï¼Œ</span>
<span class="c1">//ä¸»è¦é’ˆå¯¹unbound å’Œ cpu å¯†é›†å‹</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">need_more_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span>
<span class="w">        </span><span class="n">wake_up_worker</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Record the last pool and clear PENDING which should be the last</span>
<span class="cm">     * update to @work.  Also, do this inside @pool-&gt;lock so that</span>
<span class="cm">     * PENDING and queued state changes happen together while IRQ is</span>
<span class="cm">     * disabled.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">set_work_pool_and_clear_pending</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="w">    </span><span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Strictly speaking we should mark the invariant state without holding</span>
<span class="cm">     * any locks, that is, before these two lock_map_acquire()\'s.</span>
<span class="cm">     *</span>
<span class="cm">     * However, that would result in:</span>
<span class="cm">     *</span>
<span class="cm">     *   A(W1)</span>
<span class="cm">     *   WFC(C)</span>
<span class="cm">     *      A(W1)</span>
<span class="cm">     *      C(C)</span>
<span class="cm">     *</span>
<span class="cm">     * Which would create W1-&gt;C-&gt;W1 dependencies, even though there is no</span>
<span class="cm">     * actual deadlock possible. There are two solutions, using a</span>
<span class="cm">     * read-recursive acquire on the work(queue) \'locks\', but this will then</span>
<span class="cm">     * hit the lockdep limitation on recursive locks, or simply discard</span>
<span class="cm">     * these locks.</span>
<span class="cm">     *</span>
<span class="cm">     * AFAICT there is no possible deadlock scenario between the</span>
<span class="cm">     * flush_work() and complete() primitives (except for single-threaded</span>
<span class="cm">     * workqueues), so hiding them isn\'t a problem.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">lockdep_invariant_state</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">trace_workqueue_execute_start</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="c1">//æ‰§è¡Œworkå‡½æ•°</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * While we must be careful to not use \"work\" after this, the trace</span>
<span class="cm">     * point will only record its address.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">trace_workqueue_execute_end</span><span class="p">(</span><span class="n">work</span><span class="p">,</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockdep_map</span><span class="p">);</span>
<span class="w">    </span><span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">lockdep_map</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_atomic</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">lockdep_depth</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="err">\</span><span class="s">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span>
<span class="w">               </span><span class="err">\</span><span class="s">"     last function: %ps</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">               </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n">preempt_count</span><span class="p">(),</span><span class="w"> </span><span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
<span class="w">               </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="p">);</span>
<span class="w">        </span><span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="w">        </span><span class="n">dump_stack</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * The following prevents a kworker from hogging CPU on !PREEMPTION</span>
<span class="cm">     * kernels, where a requeueing work item waiting for something to</span>
<span class="cm">     * happen could deadlock with stop_machine as such work item could</span>
<span class="cm">     * indefinitely requeue itself while all other CPUs are trapped in</span>
<span class="cm">     * stop_machine. At the same time, report a quiescent RCU state so</span>
<span class="cm">     * the same condition doesn\'t freeze RCU.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">cond_resched</span><span class="p">();</span>

<span class="w">    </span><span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* clear cpu intensive status */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_intensive</span><span class="p">))</span>
<span class="w">        </span><span class="n">worker_clr_flags</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="n">WORKER_CPU_INTENSIVE</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* tag the worker for identification in schedule() */</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">last_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* we\'re done with it, release */</span>
<span class="w">    </span><span class="n">hash_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">hentry</span><span class="p">);</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_pwq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">current_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">;</span>
<span class="n">pwq_dec_nr_in_flight</span><span class="p">(</span><span class="n">pwq</span><span class="p">,</span><span class="w"> </span><span class="n">work_data</span><span class="p">);</span>
<span class="c1">//pwq-&gt;nr_active--,åˆ¤æ–­æ˜¯å¦è¦å¤„ç†å»¶æ—¶é˜Ÿåˆ—ï¼Œ</span>
<span class="c1">//å°†æ­¤å‰pwq-&gt;inactive_worksæ·»åŠ åˆ°pool-&gt;worklist</span>
<span class="p">}</span>
</code></pre></div>
<p>æ€»ç»“ï¼šå·¥ä½œé˜Ÿåˆ—å¯ä»¥åˆ†ä¸º3ç§ï¼ŒPer CPUï¼ŒUnboundï¼ŒOrderedï¼ˆå±äºunboundçš„ä¸€ç§ï¼‰ - Per CPUï¼š create_workequeue(name)ï¼Œåˆ›å»ºçš„WQä½¿ç”¨çš„çº¿ç¨‹æ± æ˜¯ä½¿ç”¨Per - CPUé™æ€å®šä¹‰çš„çº¿ç¨‹æ± ï¼Œæ¯ä¸ªCPUæœ‰ä¸¤ä¸ªçº¿ç¨‹æ± ï¼Œåˆ†åˆ«å¯¹äºé«˜ä¼˜å…ˆçº§å’Œä½ä¼˜å…ˆçº§ã€‚å½“è§¦å‘queue_workæ—¶ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šcpuï¼Œåˆ™å°†worké€’äº¤ç»™å½“å‰è¿è¡Œcpuçš„çº¿ç¨‹æ± ã€‚è¯¥ç±»å‹çš„wqï¼ŒåŒä¸€ä¸ªworkä¸èƒ½åŒæ—¶é€’äº¤åˆ°å¤šä¸ªçº¿ç¨‹æ± ä¸Šè¿è¡Œï¼ŒåŒæ—¶åœ¨ä¸€ä¸ªçº¿ç¨‹æ± ä¸­ä¹Ÿä¸èƒ½åŒæ—¶æœ‰å¤šä¸ªworkeræ¥è¿è¡Œï¼Œworkä¸€æ—¦é€‰å®šworkerå°†éœ€è¦åœ¨è¯¥workerä¸Šè¿è¡Œç»“æŸï¼›ä¸åŒçš„workå¯ä»¥é€’äº¤åˆ°ä¸åŒçš„çº¿ç¨‹æ± ï¼Œè¿™æ ·ä¼šåœ¨ä¸åŒçš„cpuä¸Šå¹¶å‘æ‰§è¡Œã€‚ - Unboundï¼šcreate_freezable_workqueue(name)ï¼Œåˆ›å»ºçš„WQä½¿ç”¨çš„çº¿ç¨‹æ± åŠ¨æ€åˆ›å»ºçš„ï¼Œä¼šä¼˜å…ˆé€‰æ‹©å½“å‰ä»£ç è¿è¡Œçš„cpuï¼Œè·å–åˆ°å¯¹åº”çš„nodeèŠ‚ç‚¹ï¼Œç„¶åæŸ¥è¯¢å½“å‰nodeèŠ‚ç‚¹ä¸Šæ˜¯å¦æœ‰çº¿ç¨‹æ± ï¼Œå¦‚æœæœ‰åˆ™é€’äº¤åˆ°è¯¥çº¿ç¨‹æ± å¤„ç†ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ªçº¿ç¨‹æ± ã€‚å¯¹åº”è¿™ç§ç±»å‹çš„wqæ˜¯éœ€è¦è€ƒè™‘åŠŸè€—çš„ï¼Œåœ¨é€‰æ‹©cpuæ—¶ä¼šå°½å¯èƒ½çš„é€‰æ‹©å½“å‰è¿è¡Œçš„cpuï¼Œè®©å·²ç»ä¼‘çœ çš„cpuå°½å¯èƒ½çš„ä¿æŒä¼‘çœ ï¼Œæ¯•ç«Ÿcpuä»ä¼‘çœ åˆ°å”¤é†’ä¼šæœ‰æ›´å¤§åŠŸè€—æ¶ˆè€—ã€‚å¦‚æœæ²¡æœ‰NUMAçš„æ¶æ„ï¼Œé‚£ä¹ˆå°±åªæœ‰ä¸€ä¸ªdflé»˜è®¤çš„çº¿ç¨‹æ± ã€‚ - Orderedï¼šcreate_singlethread_workqueue(name)ï¼Œè¯¥ç±»å‹çš„wqä¹Ÿæ˜¯unboundçš„ä¸€ç§ï¼Œåªä¸è¿‡è¯¥å·¥ä½œé˜Ÿåˆ—åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œè¿™æ ·å¯ä»¥ä¿è¯å·¥ä½œé˜Ÿåˆ—çš„å·¥ä½œå¯ä»¥é¡ºåºè¿è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨è¯¥wqä¸Šçš„workæ˜¯æ²¡æ³•å¹¶å‘è¿è¡Œçš„ï¼Œåªèƒ½æ’é˜Ÿè¿è¡Œã€‚</p>
<h2 id="_7">çº¿ç¨‹æ± åŠ¨æ€ç®¡ç†</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_f99de8b370923ccfa3fe2f769611a779.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_f99de8b370923ccfa3fe2f769611a779.jpg"/></a></p>
<p>çº¿ç¨‹æ± å°†è¿›è¡ŒåŠ¨æ€çš„å¢å‡ç®¡ç†workerï¼Œå½“åˆ›ä¸€ä¸ªæ–°çš„wqåï¼Œçº¿ç¨‹æ± è‡³å°‘ä¼šåˆ›å»ºä¸€ä¸ªworkerï¼Œè¯¥workerä¼šæŒ‚åˆ°pool-&gt;idle_listé“¾è¡¨ä¸Šï¼Œå½“ç”¨æˆ·è°ƒç”¨queue_workæˆ–è€…æœ‰å¦å¤–ä¸€ä¸ªworkerå¤„ç†workå¯¼è‡´è¿›å…¥ä¼‘çœ å°†ä¼šè§¦å‘workerä»idleè½¬åˆ°runningçŠ¶æ€è¿›è¡Œå¤„ç†workï¼Œå½“workerä»idleè¿›å…¥runningä¸­çŠ¶æ€æ—¶æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å‰©ä½™çš„workerï¼Œå¦‚æœæ²¡æœ‰äº†éœ€è¦åŠ¨æ€å†åˆ›å»ºè¦ç»™workerï¼Œä»¥å¤‡åç»­å…¶ä»–workçš„è¿è¡Œã€‚å¤„äºrunningçŠ¶æ€çš„workerå¦‚æœåœ¨æ‰§è¡Œworkå›è°ƒå‡½æ•°æ—¶é‡åˆ°é˜»å¡è¯¥workerå°†è¿›å…¥åˆ°ä¼‘çœ çŠ¶æ€ï¼Œå”¤é†’åå†æ¬¡è¿”å›åˆ°è¿è¡ŒçŠ¶æ€ã€‚å½“workerå¤„ç†å®Œçº¿ç¨‹æ± pool-&gt;worklistä¸Šçš„æ‰€æœ‰workæ—¶å°†ä¼šè¿›å…¥åˆ°idleçŠ¶æ€ï¼Œåå°ä¼šæœ‰ä¸€ä¸ªå®šæ—¶å™¨æ£€æŸ¥å¤„äºidleçŠ¶æ€çš„workerï¼Œå¦‚æœå¤§äº1ä¸ªå°±è¿›è¡Œé”€æ¯ã€‚ ä¸‹é¢æ˜¯running-&gt;sleepè§¦å‘å¦å¤–ä¸€ä¸ªworkerè¿è¡Œå’Œworkeré”€æ¯çš„æµç¨‹ã€‚</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_35b1f784722e9865850a7109043de85d.jpg"><img alt="" src="assets/doc/01-linux/ä¸­æ–­ç®¡ç†/workqueueä¹‹apiä¸æ•°æ®ç»“æ„/images/wp_editor_md_35b1f784722e9865850a7109043de85d.jpg"/></a></p></div>
  <div class="post-nav">
    <a class="prev" href="ä¸­æ–­å°ç»“.html">â† ä¸­æ–­å°ç»“</a>
    <a class="next" href="è½¯ä¸­æ–­å’Œtasklet.html">è½¯ä¸­æ–­å’Œtasklet â†’</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright Â©2022-2025 laumy ç‰ˆæƒæ‰€æœ‰</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

