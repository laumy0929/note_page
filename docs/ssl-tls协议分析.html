<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SSL/TLS协议分析 - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">首页</a></div>
          <div class="nav-item site-link">
            <a href="https://www.laumy.tech" target="_blank" title="访问主站">主站点:www.laumy.tech</a>
          </div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#tls">什么是TLS</a><ul></ul></li><li><a href="#_1">对称加密与非对称加密</a><ul><li><a href="#_2">对称加密</a></li><li><a href="#_5">非对称加密</a></li></ul></li><li><a href="#_6">数字证书</a><ul></ul></li><li><a href="#tls_1">TLS协议</a><ul><li><a href="#tlsv12">TLSv1.2 握手过程</a></li><li><a href="#tlsv13">TLSv1.3握手过程</a></li></ul></li><li><a href="#tls_2">TLS应用编程</a><ul><li><a href="#_7">创建连接</a></li><li><a href="#_8">收发数据</a></li><li><a href="#_9">断开连接</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>SSL/TLS协议分析</h1>
  <div class="meta">
    <span class="meta-item">
      <i class="icon">🕒</i>
      2024-11-22
    </span>
    <span class="meta-item">
      <i class="icon">📂</i>
      网络
    </span>
    <span class="meta-item">
      <i class="icon">👤</i>
      laumy
    </span>
  </div>
  <div class="post-content"><h2 id="tls">什么是TLS</h2>
<ul>
<li>1994: SSL 1.0 NetScape公司提出SSL第一版，未公开。</li>
<li>1995: SLL 2.0 公开发布了第二版，与2011年弃用。</li>
<li>1996: SSL 3.0 第三版得到大规模应，于2015年弃用。</li>
<li>1999: TLS 1.0 RFC2246，被IETF纳入标准化，没太大改动，改名TLS。</li>
<li>2006: TLS 1.1 RFC4346，修复bug，增加参数。</li>
<li>2008: TLS 1.2 RFC,更多扩展和算法该节。</li>
<li>2018: TLS 1.3 减少时延，完全前向安全。</li>
</ul>
<p>传输层安全性协议（英语：Transport Layer Security，缩写：TLS），前身称为安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。TLS（Transport Layer Security）是计算机网络通信用于安全加密的协议，HTTP+TLS后后即HTTPS。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_e9f9ffc568940f68b439583170b3103a.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_e9f9ffc568940f68b439583170b3103a.jpg"/></a></p>
<p>TLS介于网络传输层和应用层之间，TLS主要用于数据加密过程，保证数据的安全传输。TLS是一套混合加密系统，使用了对称加密和非对称加密两种方式。非对称加密相对对称加密更安全，但是其复杂的加解密会使得通信效率降低，为了解决这种场景。先使用“非对称加密”的方式传输用于数据的“对称加密密钥”，以保证双方的对称加密秘钥是安全传输的，后续就可以直接使用对称加密秘钥进行传输了。关于非对称加密和对称加密接下来简单说明一下。</p>
<h2 id="_1">对称加密与非对称加密</h2>
<h3 id="_2">对称加密</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_54da987c3ff7c93a92589c1c65878ce5.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_54da987c3ff7c93a92589c1c65878ce5.jpg"/></a></p>
<p>对称加密双方使用相同的秘钥进行加解密，秘钥被称为共享秘钥和对称秘钥。常见的对称加密算法有AES、DES、3DES等等，下面简要说明一下常用的AES算法。</p>
<h4 id="aes">AES加解密</h4>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_3531839093318f8c9c696b8e87eb96d2.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_3531839093318f8c9c696b8e87eb96d2.jpg"/></a></p>
<p>AES是秘钥长度有128/192/256，其秘钥长度用于指定将明文转换为密文所需要的变化轮数，如当秘钥长度128位是，轮数是10；秘钥长度为192位时，轮数为12；秘钥长度为256时，轮数为14。</p>
<p>由于AES算法单次只能加解密固定长度的分组数据，如AES 单次只能加解密128位数据，而实际场景中的AES加解密长度并不是128位的整数倍，为了解决这个问题，使用AES可以使用分组密码模式配合消息填充的方法来解决。</p>
<h4 id="_3">分组密码模式</h4>
<h5 id="ecb">ECB模式</h5>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_decf8d1758e13be4c267884dcc12f153.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_decf8d1758e13be4c267884dcc12f153.jpg"/></a></p>
<p>将明文进行分组加密，加密结果为密文分组，最后一个明文分组需要必须要填充为128位。</p>
<h5 id="cbc">CBC模式</h5>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_fdc7c60b0e77a061bcc44cf15923afe7.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_fdc7c60b0e77a061bcc44cf15923afe7.jpg"/></a></p>
<p>依旧是对明文进行分组加密，最后一个分组需要填充满128位。每一组明文在加密前都与前面的密文分组进行异或操作。由于第一个明文分组前没有密文分组，所以需要准备一个与密文分组长度相等的比特序列来代替密文分组，这个比特序列被称作初始化向量，简称IV。</p>
<h5 id="ctr">CTR模式</h5>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_1406fd28e0cec64cad39912a8d3b40cd.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_1406fd28e0cec64cad39912a8d3b40cd.jpg"/></a></p>
<p>CTR模式使用用于分组长度相同的计数值参与运算，通过对逐次累加的计数器进行加密来生成密钥流，通过加密计数器得到的密钥流与明文分组进行异或运算，得到密文分组。若明文长度不是分组长度的整数倍，假设最后一个明文分组N的 长度为L位，那么最后一个明文分组N只需与计数器N加密结果的左侧 L位异或，获得的密文分组N的长度也是N位。这种算法结构使得CTR 模式不需要对明文进行填充。</p>
<h4 id="_4">分组明文的填充</h4>
<p>使用ECB/CBC模式，当加密明文不是分组密码长度的整数倍是，通常需要对明文进行填充，常用的填充方案是PKCS7。</p>
<p>以AES-CBC算法为例，若分组的长度是16字节，当加密明文是28字节是，则需要在明文末尾填充4字节，使其达到分组长度的整数倍；若待加密数据恰好是16字节，需要在明文后面额外填充16字节，并将其全部填充为16。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_48995a950eec731b8ca2a927ce221683.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_48995a950eec731b8ca2a927ce221683.jpg"/></a></p>
<h4 id="mbedtls-aes">Mbedtls AES示例</h4>
<div class="codehilite"><pre><span></span><code><span class="kt">uint8_t</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mh">0x06</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa9</span><span class="p">,</span><span class="w"> </span><span class="mh">0x21</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="mh">0x36</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb8</span><span class="p">,</span>
<span class="w">     </span><span class="mh">0xa1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x5b</span><span class="p">,</span><span class="w"> </span><span class="mh">0x51</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2e</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">,</span><span class="w"> </span><span class="mh">0xd5</span><span class="p">,</span><span class="w"> </span><span class="mh">0x34</span><span class="p">,</span><span class="w"> </span><span class="mh">0x12</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x06</span><span class="w"> </span><span class="p">};</span>

<span class="kt">uint8_t</span><span class="w"> </span><span class="n">iv</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mh">0x3d</span><span class="p">,</span><span class="w"> </span><span class="mh">0xaf</span><span class="p">,</span><span class="w"> </span><span class="mh">0xba</span><span class="p">,</span><span class="w"> </span><span class="mh">0x42</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9d</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9e</span><span class="p">,</span><span class="w"> </span>
<span class="w">     </span><span class="mh">0xb4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x30</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x22</span><span class="p">,</span><span class="w"> </span><span class="mh">0xda</span><span class="p">,</span><span class="w"> </span><span class="mh">0x80</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2c</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9f</span><span class="p">,</span><span class="w"> </span><span class="mh">0xac</span><span class="p">,</span><span class="w"> </span><span class="mh">0x41</span><span class="w"> </span><span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">cipher</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">olen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="n">mbedtls_cipher_context_t</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">mbedtls_cipher_info_t</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">;</span>

<span class="w">    </span><span class="n">mbedtls_cipher_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
<span class="w">    </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_cipher_info_from_type</span><span class="p">(</span><span class="n">type</span><span class="p">);</span><span class="w">  </span><span class="c1">//获取加密模式</span>

<span class="w">    </span><span class="n">mbedtls_cipher_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">);</span><span class="w"> </span><span class="c1">//设置cipher结构体，内部是赋值的过程</span>
<span class="w">    </span><span class="n">mbedtls_cipher_setkey</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_ENCRYPT</span><span class="p">);</span><span class="w"> </span><span class="c1">//设置密钥</span>
<span class="w">    </span><span class="n">mbedtls_cipher_set_iv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">iv</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">iv</span><span class="p">));</span><span class="w"> </span><span class="c1">//设置IV，CBC/CTR都需要IV，第一组的异或</span>
<span class="w">    </span><span class="n">mbedtls_cipher_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">ptx</span><span class="p">),</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">len</span><span class="p">);</span><span class="c1">//更新cipher</span>
<span class="w">    </span><span class="n">olen</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">    </span><span class="n">mbedtls_cipher_finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">len</span><span class="p">);</span><span class="c1">//cipher完成</span>
<span class="w">    </span><span class="n">olen</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">mbedtls_cipher_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cipher</span><span class="p">(</span><span class="n">MBEDTLS_CIPHER_AES_128_CBC</span><span class="p">);</span>
<span class="w">    </span><span class="n">cipher</span><span class="p">(</span><span class="n">MBEDTLS_CIPHER_AES_128_CTR</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_5">非对称加密</h3>
<p>上一小节说了对称加密算法，其特点就是加密速度快，效率高，但是其缺点就是在于密钥的传输存在安全性问题，因为大部分通信都是通过网络来进行传输的，密钥容易在传输过程中被窃取，一旦获得密钥，那么后面的加密就毫无意义了。为了解决这种问题，非对称加密就产生了，非对称加密的特点就是把密钥进行分离，分成公钥和私钥两个部分。公钥是传输的双方公有的密钥，用于数据的加密，而私钥用于解密，双方的私钥不一样，各自保管。通过公钥加密、各自的私钥解密这样即使公钥被泄露，也不用担心，没有私钥是无法解密的。常见的非对称加密算法有RSA，DSA，ECC等。下面重点简要介绍RSA加密算法。</p>
<h4 id="rsa">RSA</h4>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_616fc5d8c31eedc9ff2812e54a761341.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_616fc5d8c31eedc9ff2812e54a761341.jpg"/></a></p>
<p>1） Bob按照RSA算法标准生成密钥对，这个密钥对包含公钥和私钥。 2） Bob将公钥发送给Alice，私钥则自己进行保存起来。 3） Alice收到Bob的公钥后，使用该公钥加密明文，接着发送给Bob。 4） Bob接收到Alice使用公钥加密的密文后，使用自己的私钥进行解密得到明文，解密正确后则后续Bob就使用这套密钥。</p>
<h4 id="mbedtls-rsa">mbedtls RSA示例</h4>
<div class="codehilite"><pre><span></span><code><span class="kt">size_t</span><span class="w"> </span><span class="n">olen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">2048</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span>
<span class="n">mbedtls_rsa_context</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span>
<span class="n">mbedtls_entropy_context</span><span class="w"> </span><span class="n">entropy</span><span class="p">;</span><span class="w"> </span>
<span class="n">mbedtls_ctr_drbg_context</span><span class="w"> </span><span class="n">ctr_drbg</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"simple_rsa"</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"Hello, World!"</span><span class="p">;</span>

<span class="n">mbedtls_platform_set_printf</span><span class="p">(</span><span class="n">printf</span><span class="p">);</span><span class="w"> </span>
<span class="n">mbedtls_platform_set_snprintf</span><span class="p">(</span><span class="n">snprintf</span><span class="p">);</span>

<span class="n">mbedtls_entropy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entropy</span><span class="p">);</span><span class="w"> </span><span class="c1">//初始化熵结构体</span>

<span class="n">mbedtls_ctr_drbg_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">);</span><span class="c1">//初始化随机数结构体</span>

<span class="n">mbedtls_rsa_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_RSA_PKCS_V21</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_MD_SHA256</span><span class="p">);</span><span class="w"> </span><span class="c1">//初始化RSA结构体</span>

<span class="n">mbedtls_entropy_add_source</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entropy</span><span class="p">,</span><span class="w"> </span><span class="n">entropy_source</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_ENTROPY_MAX_GATHER</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_ENTROPY_SOURCE_STRONG</span><span class="p">);</span><span class="w"> </span><span class="c1">//添加熵源接口，设置熵源属性</span>

<span class="n">mbedtls_ctr_drbg_seed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_entropy_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entropy</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">pers</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">pers</span><span class="p">));</span><span class="w"> </span><span class="c1">//根据个性化字符串更新种子</span>

<span class="n">mbedtls_rsa_gen_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_ctr_drbg_random</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">,</span><span class="w"> </span><span class="mi">2048</span><span class="p">,</span><span class="w"> </span><span class="mi">65537</span><span class="p">);</span><span class="c1">//RSA生成密钥对</span>

<span class="n">mbedtls_rsa_pkcs1_encrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_ctr_drbg_random</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_RSA_PUBLIC</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span><span class="c1">//RSA加密操作，通过指定公钥进行加密</span>

<span class="n">mbedtls_rsa_pkcs1_decrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_ctr_drbg_random</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_RSA_PRIVATE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">olen</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span><span class="c1">//RSA解密操作，通过制定参数私钥解密</span>

<span class="n">out</span><span class="p">[</span><span class="n">olen</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="n">memcmp</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">olen</span><span class="p">);</span>

<span class="n">mbedtls_ctr_drbg_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctr_drbg</span><span class="p">);</span><span class="w"> </span>

<span class="n">mbedtls_entropy_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entropy</span><span class="p">);</span>

<span class="n">mbedtls_rsa_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span><span class="w"> </span>

<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<h2 id="_6">数字证书</h2>
<p>使用非对称加密的好处就是，通过公钥加密、私钥解密，私钥是各自私有这样相比于对称加密就更安全了。一般情况下，公钥需要通过网络进行传输，而且公钥都是公开的。假设有这么一个场景，A和B在首次建立通信连接的时候，A发送给B公钥，但是在发送公钥的过程中被C劫持了，换成了C自己的公钥发送给B，那么B就误认为C的公钥是A发送的，那么后续C就可以作为中间人获取到通信内容，传输链路A-&gt;C-B。 <a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_1d2a1e52824660e6f2d95cdae8ec3c4e.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_1d2a1e52824660e6f2d95cdae8ec3c4e.jpg"/></a></p>
<p>为了解决这种在初次建立连接是被中间人中继的问题，因为非对称加密公私钥可以分离，所以可以找个大家信得过的机构来专门颁发公钥，这个机构颁发的就是数字证书，相当于就是身份证。让A和B的公钥是值得信赖的，不要让B误认为公钥是C的公钥。</p>
<p>签发证书的机构被称为 CA（ Certificate Authority），理论上每个人都可以成为CA，因为每个人都可以自己签发证书，但是只有极少数的权威CA颁发的证书才会被承认。</p>
<p>一般来说数字证书可以按照安全程度分为以下三类：</p>
<p>EV：<strong>EV证书(Extended Validation Certificate)</strong>是一种根据一系列特定标准颁发的X.509电子证书，根据要求，在颁发证书之前，证书颁发机构(CA)必须验证申请者的身份。不同机构根据证书标准发行的扩展验证证书并无太大差异，但是有时候根据一些具体的要求，特定机构发行的证书可以被特定的软件识别 OV：<strong>OV证书(Organization Validation SSL)</strong>，指需要验证网站所有单位的真实身份的标准型SSL证书，此类证书不仅能够起到网站信息加密的作用，而且能向用户证明网站的真实身份 DV：<strong>DV证书(Domain Validation SSL)</strong>，指需要验证域名的有效性。该类证书只提供基本的加密保障，不能提供域名所有者的信息</p>
<h2 id="tls_1">TLS协议</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_e8cb6eead7f66c0de612f800ebf78251.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_e8cb6eead7f66c0de612f800ebf78251.jpg"/></a></p>
<p>TLS协议可以分为记录层和握手层</p>
<ul>
<li>记录层：负责对数据进行加密、压缩、分段，并保证数据的完整性和安全传输。</li>
<li>握手层：负责建立安全通信，完成密钥交换、身份认证以及协商加密算法等，确保双方通信的安全性。</li>
</ul>
<p>握手层有3个协议，握手协议（Handshake Protocol）、更换加密规约协议（Change Cipher Spec Protocol）、告警协议（Alert Protocol）。</p>
<h3 id="tlsv12">TLSv1.2 握手过程</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_478e96f04b345888d2ad686217c45939.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_478e96f04b345888d2ad686217c45939.jpg"/></a></p>
<p><strong>步骤1</strong>：客户端通过明文的方式发送Client Hello 消息到服务器，消息中主要包含了客户端支持的ciphersuites， TLS 版本信息和客户端随机数。 <a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_8a16af48187c398c9d7edc8cd0cb37bc.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_8a16af48187c398c9d7edc8cd0cb37bc.jpg"/></a></p>
<p><strong>步骤2</strong>：服务器接收到消息后，明文发送一个Server Hello给客户端，包括自己支持的ciphersuites， TLS 版本，自己的<strong>数字证书</strong>（证书中包含了公钥）和服务器端生成的随机数。在包的交互上，证书、随机数等可能是不包含在Server Hello一个包中单独进行发送，示服务器具体的行为。下图是Server Hello， <a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_1a66f3f876ae76777bf5bce5b82b7015.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_1a66f3f876ae76777bf5bce5b82b7015.jpg"/></a></p>
<p>当客户端需要对服务器的身份进行验证时，服务器端发送 Certificate消息。该消息中包含证书清单，证书清单是一组X.509 v3证书列表。证书列表包含服务器证书、中间证书和根证书。通常情况下服务器并不会发送根证书，这就需要客户端提前导入根证书。通过Certificate消息，客户端将获得服务器的公钥，并通过根证书中的公钥验证服务器公钥的合法 性。下图是服务器证书Ceriticate，证书中包含了公钥。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_c5e2519b166fa1c73348d2a68f25d622.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_c5e2519b166fa1c73348d2a68f25d622.jpg"/></a></p>
<p>如果服务器没有证书或者服务器的证书仅用来签名（如DSS证书、签名RSA证书），或者使用的是FORTEZZA KEA密钥交换算法，那么就需要发送Server Key Exchange。服务器会在 server Certificate 消息之后发送 Server Key Exchange 消息。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_b0af68f119ff372778ff248ea60cbb50.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_b0af68f119ff372778ff248ea60cbb50.jpg"/></a></p>
<p>服务器Hello阶段结束后，一般会附上一条简单的Server Hello Done表示结束。 <a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_5e749e6cc65f10ab6d448b81757ba803.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_5e749e6cc65f10ab6d448b81757ba803.jpg"/></a></p>
<p><strong>步骤3</strong>：客户端开始验证数字证书，可能会不断往上追溯 CA，直到一个可信任CA。验证证书合法之后，从证书中读取公钥信息。之后生成一个<strong>pre-master key</strong>（用来生成后续的对称秘钥），接着使用证书中的<strong>公钥来对pre-master key进行加密</strong>，然后发送给服务器。该过程是非对称加密传输。服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了pre-master key。注意此时是非对称加密传输，这样服务器就获得了后续对称加密的密钥。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_98b69be6641d25f6b292431a8d6f8d66.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_98b69be6641d25f6b292431a8d6f8d66.jpg"/></a></p>
<p>经过1）2）3）不走，服务器和客户端有了3组数据，分别是<strong>客户端的随机数、服务器的随机数和pre-master key</strong>。其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于pre-master key是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，这个密钥称为<strong>shared secert</strong>。也就是之后用来对称加密的密钥。</p>
<p><strong>步骤4</strong>：客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。注意此时是对称加密传输服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/11/wp_editor_md_f60fbc0472f89e7010da0f3981117f83.jpg"><img alt="" src="assets/doc/09-网络/tls/images/wp_editor_md_f60fbc0472f89e7010da0f3981117f83.jpg"/></a></p>
<p>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。总结一下SSL/TLS协议的基本过程，前两步又称为\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"握手阶段\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"（handshake）,是SSL/TLS加密通信的基础。</p>
<ul>
<li>
<p>通过CA体系交换公钥</p>
</li>
<li>
<p>使用非对称加密算法，交换用于对称加密的密钥</p>
</li>
<li>
<p>有效数据使用对称加密算法，进行密文传输</p>
</li>
</ul>
<h3 id="tlsv13">TLSv1.3握手过程</h3>
<p>待补充。</p>
<h2 id="tls_2">TLS应用编程</h2>
<h3 id="_7">创建连接</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">ssl_transport_connect</span><span class="p">(</span><span class="n">NetworkContext_t</span><span class="o">*</span><span class="w"> </span><span class="n">net_ctx</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">host</span><span class="p">,</span>
<span class="w">                          </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">port</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">cacert</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"ssl_client"</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="n">Address</span><span class="w"> </span><span class="n">resolved_addr</span><span class="p">;</span>

<span class="w">  </span><span class="n">mbedtls_ssl_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">);</span><span class="w"> </span><span class="c1">//初始化ssl结构体</span>
<span class="w">  </span><span class="n">mbedtls_ssl_config_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">);</span><span class="c1">//初始化ssl配置结构体</span>
<span class="w">  </span><span class="c1">// mbedtls_x509_crt_init(&amp;net_ctx-&gt;cacert);//初始化X.509证书结构体</span>
<span class="w">  </span><span class="n">mbedtls_ctr_drbg_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ctr_drbg</span><span class="p">);</span><span class="c1">//初始化随机数结构体</span>
<span class="w">  </span><span class="n">mbedtls_entropy_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">entropy</span><span class="p">);</span><span class="c1">//初始化熵结构体</span>
<span class="w">  </span><span class="c1">//初始化个性化字符串更新种子</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ctr_drbg_seed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ctr_drbg</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_entropy_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">entropy</span><span class="p">,</span>
<span class="w">                                   </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pers</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">pers</span><span class="p">)))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//加载ssl默认配置选项，可以指定端类型、传输协议等参数。</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_config_defaults</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">MBEDTLS_SSL_IS_CLIENT</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">MBEDTLS_SSL_TRANSPORT_STREAM</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">MBEDTLS_SSL_PRESET_DEFAULT</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LOGE</span><span class="p">(</span><span class="s">"ssl config error: -0x%x"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//配置认真方式，配置项包括</span>
<span class="w">  </span><span class="c1">// VERIFY_NONE：不对证书进行验证。</span>
<span class="w">  </span><span class="c1">// VERIFY_OPTIONAL：对证书进行验证，即使证书验证失败，继续完成握手操作</span>
<span class="w">  </span><span class="c1">// VERIFY_REQUIRED: 对证书进行验证，而且要求证书必须通过验证，否则总之握手过程</span>
<span class="w">  </span><span class="n">mbedtls_ssl_conf_authmode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">,</span><span class="w"> </span><span class="n">MBEDTLS_SSL_VERIFY_OPTIONAL</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/*</span>
<span class="cm">  XXX: not sure if this is needed</span>
<span class="cm">  ret = mbedtls_x509_crt_parse(&amp;net_ctx-&gt;cacert, (const unsigned char *) cacert, strlen(cacert) + 1);</span>
<span class="cm">  if (ret &lt; 0) {</span>
<span class="cm">    LOGE("ssl parse error: -0x%x", (unsigned int) -ret);</span>
<span class="cm">  }</span>
<span class="cm">  mbedtls_ssl_conf_ca_chain(&amp;net_ctx-&gt;conf, &amp;net_ctx-&gt;cacert, NULL);</span>
<span class="cm">  */</span>
<span class="w">  </span><span class="c1">//设置随机数生成器回调接口</span>
<span class="w">  </span><span class="n">mbedtls_ssl_conf_rng</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">,</span><span class="w"> </span><span class="n">mbedtls_ctr_drbg_random</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ctr_drbg</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//通过配置选项完成ssl的设置</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LOGE</span><span class="p">(</span><span class="s">"ssl setup error: -0x%x"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//配置ssl hostname</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_set_hostname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">,</span><span class="w"> </span><span class="n">host</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LOGE</span><span class="p">(</span><span class="s">"ssl set hostname error: -0x%x"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//创建socket，配置地址和端口，发起tcp连接</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resolved_addr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">resolved_addr</span><span class="p">));</span>
<span class="w">  </span><span class="n">tcp_socket_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">,</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">);</span>
<span class="w">  </span><span class="n">ports_resolve_addr</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resolved_addr</span><span class="p">);</span>
<span class="w">  </span><span class="n">addr_set_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resolved_addr</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_socket_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resolved_addr</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//配置 SSL 连接的接收超时时间</span>
<span class="w">  </span><span class="n">mbedtls_ssl_conf_read_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">,</span><span class="w"> </span><span class="n">SSL_RECV_TIMEOUT</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//设置 SSL 连接的 BIO（输入输出）接口，即定义 SSL/TLS 连接使用的网络 I/O 操作函数。</span>
<span class="w">  </span><span class="c1">//&amp;net_ctx-&gt;ssl：这是指向 mbedtls_ssl_context 结构体的指针，表示 SSL/TLS 会话上下文。</span>
<span class="w">  </span><span class="c1">//&amp;net_ctx-&gt;tcp_socket：这是指向 TCP 套接字的指针，表示底层的网络连接（通常是一个 TCP 套接字，用于在网络中传输加密数据）。</span>
<span class="w">  </span><span class="c1">//ssl_transport_mbedtls_send：这是一个自定义的发送数据函数，用于通过网络连接发送加密后的数据。mbedtls_ssl_write 函数最终会调用这个发送函数，将数据从应用层发送到网络层。</span>
<span class="w">  </span><span class="c1">//ssl_transport_mbedtls_recv_timeout：这是一个自定义的接收数据函数，用于在设置的超时限制下从网络接收数据。它会被 mbedtls_ssl_read 调用，接收经过加密的 SSL/TLS 数据并解密。</span>
<span class="w">  </span><span class="n">mbedtls_ssl_set_bio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">,</span>
<span class="w">                      </span><span class="n">ssl_transport_mbedlts_send</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">ssl_transport_mbedtls_recv_timeout</span><span class="p">);</span>

<span class="w">  </span><span class="n">LOGI</span><span class="p">(</span><span class="s">"start to handshake"</span><span class="p">);</span>
<span class="w"> </span><span class="c1">//执行handshake握手</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_handshake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MBEDTLS_ERR_SSL_WANT_READ</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MBEDTLS_ERR_SSL_WANT_WRITE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">LOGE</span><span class="p">(</span><span class="s">"ssl handshake error: -0x%x"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">LOGI</span><span class="p">(</span><span class="s">"handshake success"</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>mbedtls_ssl_set_bio传入的函数。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ssl_transport_mbedtls_recv_timeout</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">timeout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="n">fd_set</span><span class="w"> </span><span class="n">read_fds</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">tv</span><span class="p">;</span>
<span class="w">  </span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="w">  </span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">timeout</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="w">  </span><span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_fds</span><span class="p">);</span>
<span class="w">  </span><span class="n">FD_SET</span><span class="p">(((</span><span class="n">TcpSocket</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">read_fds</span><span class="p">);</span>

<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">select</span><span class="p">(((</span><span class="n">TcpSocket</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">read_fds</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// timeout</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(((</span><span class="n">TcpSocket</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">read_fds</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tcp_socket_recv</span><span class="p">((</span><span class="n">TcpSocket</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ssl_transport_mbedlts_send</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tcp_socket_send</span><span class="p">((</span><span class="n">TcpSocket</span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_8">收发数据</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">int32_t</span><span class="w"> </span><span class="nf">ssl_transport_recv</span><span class="p">(</span><span class="n">NetworkContext_t</span><span class="o">*</span><span class="w"> </span><span class="n">net_ctx</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int32_t</span><span class="w"> </span><span class="nf">ssl_transport_send</span><span class="p">(</span><span class="n">NetworkContext_t</span><span class="o">*</span><span class="w"> </span><span class="n">net_ctx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbedtls_ssl_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MBEDTLS_ERR_SSL_WANT_READ</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MBEDTLS_ERR_SSL_WANT_WRITE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">LOGE</span><span class="p">(</span><span class="s">"ssl write error: -0x%x"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_9">断开连接</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ssl_transport_disconnect</span><span class="p">(</span><span class="n">NetworkContext_t</span><span class="o">*</span><span class="w"> </span><span class="n">net_ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">mbedtls_ssl_config_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// mbedtls_x509_crt_free(&amp;net_ctx-&gt;cacert);</span>
<span class="w">  </span><span class="n">mbedtls_ctr_drbg_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ctr_drbg</span><span class="p">);</span>
<span class="w">  </span><span class="n">mbedtls_entropy_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">entropy</span><span class="p">);</span>
<span class="w">  </span><span class="n">mbedtls_ssl_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="p">);</span>

<span class="w">  </span><span class="n">tcp_socket_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_ctx</span><span class="o">-&gt;</span><span class="n">tcp_socket</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>参考： 1. 《密码技术与物联网安全》 2. <a href="https://tinychen.com/20200602-encryption-intro/">https://tinychen.com/20200602-encryption-intro/</a></p></div>
  <div class="post-nav">
    <a class="prev" href="mqtt协议分析.html">← MQTT协议分析</a>
    <a class="next" href="rtsp视频传输示例代码分析.html">RTSP视频传输示例代码分析 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

