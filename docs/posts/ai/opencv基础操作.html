<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>opencv基础操作 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/laumy.github.io/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/laumy.github.io/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/laumy.github.io/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">图像的读取和显示</a><ul><li><a href="#_2">读写图像</a></li><li><a href="#_3">显示</a></li><li><a href="#_4">示例</a></li></ul></li><li><a href="#_5">几何变换</a><ul><li><a href="#_6">裁剪与缩放</a></li><li><a href="#_7">旋转</a></li><li><a href="#_8">翻转</a></li></ul></li><li><a href="#_9">颜色变换</a><ul><li><a href="#_10">颜色空间转换</a></li><li><a href="#_11">通道分离</a></li></ul></li><li><a href="#_12">总结</a><ul><li><a href="#mat">Mat</a></li><li><a href="#scalar">Scalar</a></li><li><a href="#size">Size</a></li><li><a href="#cvtcolor">cvtColor</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>opencv基础操作</h1>
  <div class="meta">2025-05-27 · ai</div>
  <div class="post-content"><h2 id="_1">图像的读取和显示</h2>
<h3 id="_2">读写图像</h3>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image.jpg"</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_COLOR</span><span class="p">);</span>
</code></pre></div>
<p>使用imread函数读取图像，第一个参数是图像文件的路径，第二个参数是解释图像的颜色和格式（如彩色图像、灰度图像等）。第二个参数可省略，默认是cv::IMREAD_COLOR，以彩色图像读取。</p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">imwrite</span><span class="p">(</span><span class="s">"output.jpg"</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">);</span>
</code></pre></div>
<p>使用imwrite存储图像。</p>
<h3 id="_3">显示</h3>
<p><strong>使用imshow基于图像用户界面的显示方式</strong>，这种方式用于桌面的计算机，直接在屏幕上展示图像。</p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"Window title"</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待按键按下</span>
</code></pre></div>
<p><strong>通过/dev/fb0节点写入</strong>，这种方式一般应用在嵌入式平台上，写入屏幕的驱动中。</p>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="n">ofs</span><span class="p">(</span><span class="s">"/dev/fb0"</span><span class="p">);</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span>
<span class="n">定义一个存储图像像素数据的容器</span>

<span class="nf">cv::cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGR565</span><span class="p">);</span>
<span class="n">将图像格式进行转换为与驱动支持的格式BGR565</span>

<span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">total</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">elemSize</span><span class="p">());</span>

<span class="c1">//现将framebuffer强制转换为char*格式，确保内存数据按字节进行处理。</span>
<span class="c1">//framebuffer.total()返回的是像素总元素数量，如果framebuffer是多通道，那就返回总数</span>
<span class="c1">//framebuffer.elemSize()返回的是每个像素字节大小。</span>
<span class="c1">//需要注意的是使用一次性写入，要注意fb的位置，每次写需要重新定位</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">还有另外一种写法</span><span class="err">，</span><span class="n">每一行每一行的刷新</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Size2f</span><span class="w"> </span><span class="n">frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer_compat</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGR565</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ofs</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">framebuffer_width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//定位一行的位置，framebuffer_width是宽，即每行多少个像素</span>
<span class="w">    </span><span class="c1">//*2是每个像素多少个字节，BGR565是2个字节。</span>
<span class="w">    </span><span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">framebuffer_compat</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//写入一行数据，一行的数据量为frame_size.width * 2</span>
<span class="p">}</span>

<span class="n">下面是封装的示例函数</span>
<span class="kt">void</span><span class="w"> </span><span class="n">display_image</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">framebuffer_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">720</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="n">ofs</span><span class="p">(</span><span class="s">"/dev/fb0"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ofs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Error: Could not open framebuffer device!"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_GRAY2BGRA</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGRA</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">image</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Error: Unsupported image format!"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Size2f</span><span class="w"> </span><span class="n">frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frame_size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">framebuffer_width</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 计算新的宽高，保持图像的纵横比</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">aspect_ratio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">newWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">framebuffer_width</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">newHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">aspect_ratio</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 调整图像大小</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">;</span>
<span class="w">        </span><span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">newWidth</span><span class="p">,</span><span class="w"> </span><span class="n">newHeight</span><span class="p">));</span>
<span class="w">        </span><span class="n">framebuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">;</span>
<span class="w">        </span><span class="n">frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ofs</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">framebuffer_width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">        </span><span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span><span class="w"> </span><span class="n">frame_size</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_4">示例</h3>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">test_image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"test.jpg"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_image</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Could not open the image"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="n">ofs</span><span class="p">(</span><span class="s">"/dev/fb0"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ofs</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Failed to open framebuffer device."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将 BGR 图像转换为 BGRA 格式（RGB8888）</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">test_image</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGRA</span><span class="p">);</span>

<span class="w">    </span><span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"> </span>
<span class="w">        </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">total</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">elemSize</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_5">几何变换</h2>
<p>这里的变换指的是缩放、旋转、平移、翻转。</p>
<h3 id="_6">裁剪与缩放</h3>
<p>缩放</p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">newWidth</span><span class="p">,</span><span class="w"> </span><span class="n">newHeight</span><span class="p">));</span>
</code></pre></div>
<p>裁剪</p>
<div class="codehilite"><pre><span></span><code><span class="n">Rect</span><span class="w"> </span><span class="nf">roi</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span><span class="w"> </span><span class="c1">// (x, y, width, height)</span>
<span class="c1">//先于x,y坐标开始，再按照width，height定义一个矩形框。</span>
<span class="n">Mat</span><span class="w"> </span><span class="n">croppedImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">(</span><span class="n">roi</span><span class="p">);</span>
<span class="c1">//将矩形框作用在image上，得到一个新的图像croppedImage</span>
</code></pre></div>
<h3 id="_7">旋转</h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="c1">// cv::Point2f用于表示二维浮点坐标的类，下面是计算旋转中心点。</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 用于计算二维旋转的仿射变换矩阵，45是旋转角度，1.0是缩放比例。</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">rotationMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">getRotationMatrix2D</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="mf">45.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 声明存储旋转后图像的变量</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">rotatedImage</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 执行仿射变换进行图像旋转</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">rotatedImage</span><span class="p">,</span><span class="w"> </span><span class="n">rotationMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>
<h3 id="_8">翻转</h3>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">flippedImage</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">flip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">flippedImage</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1表示水平翻转，0表示垂直翻转</span>
</code></pre></div>
<h2 id="_9">颜色变换</h2>
<p>图像的颜色空间包括RGB、灰度和HSV等。</p>
<ul>
<li>RGB：RGB是最常见的颜色空间，表示红、绿、蓝三个通道。</li>
<li>灰度：灰度图像只有一个通道，表示亮度。</li>
<li>HSV：HSV颜色空间表示色调（Hue）、饱和度（Saturation）和亮度（Value）。</li>
</ul>
<h3 id="_10">颜色空间转换</h3>
<p><strong>RGB转灰度</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">grayImage</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">grayImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
</code></pre></div>
<p><strong>RGB转HSV</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">hsvImage</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">hsvImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2HSV</span><span class="p">);</span>
</code></pre></div>
<p><strong>RGB转RGB565</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">rgb565Image</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">rgb565Image</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGR565</span><span class="p">);</span>
</code></pre></div>
<h3 id="_11">通道分离</h3>
<p>这里的通道指的是图像通道比如RGB的R/G/B 3个通道。通道分离的场景是分析每个颜色通道的像素值，比如在检测红色物体时，可以单独分析红色通道。另外还可以用做图像增强，对不同通道应用不同的增强算法，然后再合并。</p>
<p><strong>通道分离</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span><span class="w"> </span><span class="n">channels</span><span class="p">;</span><span class="w"> </span><span class="c1">//分离出的通道存储到channels中</span>
<span class="n">cv</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">);</span>
</code></pre></div>
<p><strong>通道合并</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">mergedImage</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">merge</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="n">mergedImage</span><span class="p">);</span>
</code></pre></div>
<p>示例代码</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">test_image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"test.jpg"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_image</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Could not open the image"</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">90</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 计算旋转中心点</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span><span class="w"> </span><span class="n">center</span><span class="p">(</span><span class="n">test_image</span><span class="p">.</span><span class="n">cols</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="n">test_image</span><span class="p">.</span><span class="n">rows</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// 计算旋转矩阵</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">rotationMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">getRotationMatrix2D</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// 声明存储旋转后图像的变量</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">rotatedImage</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// 执行仿射变换进行图像旋转</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">test_image</span><span class="p">,</span><span class="w"> </span><span class="n">rotatedImage</span><span class="p">,</span><span class="w"> </span><span class="n">rotationMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">test_image</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="n">ofs</span><span class="p">(</span><span class="s">"/dev/fb0"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ofs</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Failed to open framebuffer device."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将 BGR 图像转换为 BGRA 格式（RGB8888）</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">rotatedImage</span><span class="p">,</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2BGRA</span><span class="p">);</span>

<span class="w">    </span><span class="n">ofs</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">framebuffer</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span><span class="w"> </span>
<span class="w">        </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">total</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">framebuffer</span><span class="p">.</span><span class="n">elemSize</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_12">总结</h2>
<p>本章节总结opencv操作常用的数据结构。</p>
<h3 id="mat">Mat</h3>
<p>Mat对象的用途主要为存储图像、创建和操作多维矩阵。Mat数据类型分为两部分：信息头+指向像素数据的矩阵指针，信息头存储的是图像的尺寸、存储方法、存储地址。指向像素的矩阵指针为字面意思，即指向存储所有像素值的矩阵指针。</p>
<div class="codehilite"><pre><span></span><code><span class="n">Mat</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w">  </span><span class="c1">//只创建信息头</span>
<span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">IMREAD_COLOR</span><span class="p">);</span><span class="w"> </span><span class="c1">//为矩阵开辟内存空间。</span>
<span class="n">Mat</span><span class="w"> </span><span class="nf">B</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w"> </span><span class="c1">// Use the copy constructor</span>
<span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assignment operator</span>
</code></pre></div>
<p>如果在读取图像的时候只想获取图像中的部分图像（感兴趣的区域ROI），可以使用Rect和Range来标中数据。</p>
<div class="codehilite"><pre><span></span><code><span class="n">Mat</span><span class="w"> </span><span class="nf">D</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// using a rectangle</span>
<span class="n">Mat</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">(),</span><span class="w"> </span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span><span class="w"> </span><span class="c1">// using row and column boundaries</span>
</code></pre></div>
<p>其中Rect(10,10,100,100)前两位是坐标，后两位指定宽高，示例如下。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2025/05/wp_editor_md_f2fcbb2b2eab15e13b085cd3f38d21ff.jpg"><img alt="" src="/laumy.github.io/assets/doc/04-ai/opencv/opencv基础操作/images/wp_editor_md_f2fcbb2b2eab15e13b085cd3f38d21ff.jpg"/></a></p>
<p>Range::all()选中所有的行，Range（1,3）选中1~3列。</p>
<p>Mat对象作为通用矩阵类和图像容器，容器中存储的是原始的像素值。在opencv中描述这些像素值有专门的数据格式。</p>
<div class="codehilite"><pre><span></span><code><span class="n">Mat</span><span class="w"> </span><span class="nf">Img</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="n">CV_8UC3</span><span class="p">);</span>
</code></pre></div>
<p>上述中640*640大小的图像，存储的数据类型是CV_U8C3,这里的CV_U8C3格式为基本数据类型+通道数。"CV_"表示前缀，"8"表示每个像素值的位深比特数，有8/16/32/64bits，"U"表示数据类型为无符号，"C3"表示通道数RGB。关于通道一般有几种，示例如下：</p>
<ul>
<li>1通道：灰度图像</li>
<li>3通道：RGB通道，图像由红、绿、蓝三色组成。</li>
<li>4通道：在RGB通道基础上，加一个透明通道。</li>
</ul>
<h3 id="scalar">Scalar</h3>
<p>Scalar用于表示颜色或像素的值，他是一个模板类，存储了4个值，每个值代表图像的颜色通道，如BGR或HSV。</p>
<div class="codehilite"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">_Tp</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Scalar_</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span><span class="n">_Tp</span><span class="w"> </span><span class="n">val</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="c1">// 颜色值，最多支持四个通道</span>
<span class="w">    </span><span class="p">....</span>
<span class="p">};</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span><span class="w"> </span><span class="c1">// 红色 BGR 颜色，表示 (蓝色 = 0, 绿色 = 0, 红色 = 255) cv::Scalar(255, 0, 0); // 蓝色 BGR 颜色，表示 (蓝色 = 255, 绿色 = 0, 红色 = 0) cv::Scalar(0, 255, 0); // 绿色 BGR 颜色，表示 (蓝色 = 0, 绿色 = 255, 红色 = 0)</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span><span class="w"> </span><span class="c1">// 半透明绿色</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span><span class="w"> </span><span class="c1">// 完全不透明的蓝色</span>
</code></pre></div>
<h3 id="size">Size</h3>
<p>Size类用来表示图像的大小、矩阵的尺寸。</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Size</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Size</span><span class="p">();</span>
<span class="w">    </span><span class="n">Size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">_width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_height</span><span class="p">);</span>
<span class="w">    </span><span class="n">Size</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">_width</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">_height</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="c1">// 图像宽度</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="c1">// 图像高度</span>
<span class="p">};</span>
</code></pre></div>
<p>下面是常用的用法。</p>
<div class="codehilite"><pre><span></span><code><span class="n">设置图像的尺寸</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image.jpg"</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="w"> </span><span class="nf">new_size</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="w"> </span><span class="mi">600</span><span class="p">);</span><span class="w"> </span><span class="c1">// 新的尺寸</span>
<span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">new_size</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将图像调整为新尺寸</span>

<span class="n">获取图像的尺寸</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image.jpg"</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="w"> </span><span class="n">image_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="c1">// 获取图像尺寸</span>

<span class="n">创建一个尺寸大小的矩阵</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">mat</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">),</span><span class="w"> </span><span class="n">CV_8UC1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 创建一个大小为 400x300 的单通道图像</span>
</code></pre></div>
<h3 id="cvtcolor">cvtColor</h3>
<p>cvtColor用于颜色空间的转化，图像的颜色空间一般有RGB,BGR（RGB存储顺序的不同）,HSV,Lab等，其可以将图像从一种颜色空间变换为另一种颜色空间。</p>
<div class="codehilite"><pre><span></span><code><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="nf">cv::cvtColor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dstCn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<ul>
<li>src： 输入图像</li>
<li>dst：输出图像</li>
<li>code:指定转化格式，如 cv::COLOR_BGR2GRAY，cv::COLOR_BGR2HSV。</li>
<li>dstCn:输出通道数，如果是0，表示通道数与目标颜色空间通道匹配。</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">RGB转BGR</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image.jpg"</span><span class="p">);</span><span class="w"> </span><span class="c1">// 读取 RGB 图像（如果图像是 RGB 格式的话）</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">bgr</span><span class="p">;</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">bgr</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_RGB2BGR</span><span class="p">);</span><span class="w"> </span><span class="c1">// 转换为 BGR 图像</span>

<span class="n">HSB转BRG</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">hsv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image_hsv.jpg"</span><span class="p">);</span><span class="w"> </span><span class="c1">// 读取 HSV 图像 </span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">bgr</span><span class="p">;</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span><span class="w"> </span><span class="n">bgr</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_HSV2BGR</span><span class="p">);</span><span class="w"> </span><span class="c1">// 转换为 BGR 图像</span>

<span class="n">BRG转灰度</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">"image.jpg"</span><span class="p">);</span><span class="w"> </span><span class="c1">// 读取 BGR 图像</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">gray</span><span class="p">;</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">gray</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2GRAY</span><span class="p">);</span><span class="w"> </span><span class="c1">// 转换为灰度图</span>
</code></pre></div></div>
  <div class="post-nav">
    <a class="prev" href="/laumy.github.io/posts/ai/opencv视频流.html">← opencv视频流</a>
    <a class="next" href="/laumy.github.io/posts/linux/perf工具使用.html">perf工具使用 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/laumy.github.io/assets/site.js"></script>
  </body>
  </html>

