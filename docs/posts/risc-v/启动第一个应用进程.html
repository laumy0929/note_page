<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>启动第一个应用进程 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/laumy.github.io/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/laumy.github.io/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/laumy.github.io/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#ramdisk">ramdisk方式</a><ul></ul></li><li><a href="#execute_command">execute_command方式</a><ul></ul></li><li><a href="#_1">默认方式</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>启动第一个应用进程</h1>
  <div class="meta">2024-07-07 · risc-v</div>
  <div class="post-content"><div class="codehilite"><pre><span></span><code><span class="n">start_kernel</span>
<span class="w">  </span><span class="p">......</span>
<span class="w">  </span><span class="n">arch_call_rest_init</span><span class="p">()</span>
<span class="w">  </span><span class="n">rest_init</span><span class="p">();</span>
<span class="w">  </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel_thread</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">CLONE_FS</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__ref</span><span class="w"> </span><span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="n">kernel_init_freeable</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* need to finish all async __init code before freeing the memory */</span>
<span class="w">    </span><span class="n">async_synchronize_full</span><span class="p">();</span>
<span class="w">    </span><span class="n">ftrace_free_init_mem</span><span class="p">();</span>
<span class="w">    </span><span class="n">free_initmem</span><span class="p">();</span>
<span class="w">    </span><span class="n">mark_readonly</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Kernel mappings are now finalized - update the userspace page-table</span>
<span class="cm">     * to finalize PTI.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">pti_finalize</span><span class="p">();</span>

<span class="w">    </span><span class="n">system_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SYSTEM_RUNNING</span><span class="p">;</span>
<span class="w">    </span><span class="n">numa_default_policy</span><span class="p">();</span>

<span class="w">    </span><span class="n">rcu_end_inkernel_boot</span><span class="p">();</span>
<span class="n">创建1号进程的3种方式</span><span class="err">，</span><span class="n">如下</span><span class="err">：</span>
<span class="mf">1.</span><span class="n">方式①</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_init_process</span><span class="p">(</span><span class="n">ramdisk_execute_command</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to execute %s (error %d)</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span>
<span class="w">               </span><span class="n">ramdisk_execute_command</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * We try each of these until one succeeds.</span>
<span class="cm">     *</span>
<span class="cm">     * The Bourne shell can be used instead of init if we are</span>
<span class="cm">     * trying to recover a really broken machine.</span>
<span class="cm">     */</span>
<span class="mf">2.</span><span class="n">方式②</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">execute_command</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_init_process</span><span class="p">(</span><span class="n">execute_command</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">"Requested init %s failed (error %d)."</span><span class="p">,</span>
<span class="w">              </span><span class="n">execute_command</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="mf">3.</span><span class="n">方式③</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/sbin/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/etc/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"No working init found.  Try passing init= option to kernel. "</span>
<span class="w">          </span><span class="s">"See Linux Documentation/admin-guide/init.rst for guidance."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>从上述代码种可知，启动1号进程init一共有3种方式，分别是ramdisk的方式、execute_command的方式、默认方式。第一种是基于ramdisk的方式，将ram作为启动盘挂载根文件系统。第二种通常用于用户指定第一个init进程启动在根文件系统的位置。如果第一个和第二都没有就会使用默认。</p>
<h2 id="ramdisk">ramdisk方式</h2>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">rdinit_setup</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">ramdisk_execute_command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* See "auto" comment in init_setup */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_INIT_ARGS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">"rdinit="</span><span class="p">,</span><span class="w"> </span><span class="n">rdinit_setup</span><span class="p">);</span>
</code></pre></div>
<p>__setup(str,fn)的作用是，在系统开机时解析cmdline中是否有str字段，如果有就会调用fn函数，因此上面的函数意思就是当cmdline中有rdinit=字段时，就会调用rdinit_setup函数，将rdinit=后面的内容赋值给ramdisk_execute_command。</p>
<h2 id="execute_command">execute_command方式</h2>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">init_setup</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">execute_command</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * In case LILO is going to boot us with default command line,</span>
<span class="cm">     * it prepends "auto" before the whole cmdline which makes</span>
<span class="cm">     * the shell think it should execute a script with such name.</span>
<span class="cm">     * So we ignore all arguments entered _before_ init=... [MJ]</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_INIT_ARGS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">argv_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">"init="</span><span class="p">,</span><span class="w"> </span><span class="n">init_setup</span><span class="p">);</span>
</code></pre></div>
<p>上述代码同理，当cmdline中存在\"init=\"时，调用init_setup，将参数赋值给execute_command。这种情况一般是可以让用户指定启动的第一个进程。</p>
<h2 id="_1">默认方式</h2>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__ref</span><span class="w"> </span><span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="p">......</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/sbin/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/etc/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/init"</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="o">!</span><span class="n">try_to_run_init_process</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">   </span><span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>当cmdline中既没有rdinit和init字段时，就是直接使用默认的方式。</p></div>
  <div class="post-nav">
    <a class="prev" href="/laumy.github.io/posts/risc-v/linux系统risc-v架构启动流程分析之概述.html">← Linux系统RISC-V架构启动流程分析之概述</a>
    <a class="next" href="/laumy.github.io/posts/risc-v/虚拟地址空间与物理地址空间完整映射.html">虚拟地址空间与物理地址空间完整映射 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/laumy.github.io/assets/site.js"></script>
  </body>
  </html>

