
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <title>搜索 - Laumy的技术栈</title>
    <link rel='stylesheet' href='assets/style.css'>
  </head>
  <body>
    <div class='container' style='padding:12px'>
      <input id='q' placeholder='输入关键词' style='width:100%;padding:10px;border:1px solid #d0d7de;border-radius:6px;'>
      <div id='list' class='post-list card' style='margin-top:12px'></div>
    </div>
    <script>
const data = [{"title": "一步步实现transformer", "url": "一步步实现transformer.html", "category": "04-ai", "summary": "概述 在https://www.laumy.tech/2458.html#h37章节中，介绍了transformer的原理，本章用pytorch来实现一个将\"我有一个苹果\"翻译为英文\"I have an apple\"的模型，直观体会transformer原理实现。 接下来先上图看"}, {"title": "dataset和DataLoader", "url": "dataset和dataloader.html", "category": "04-ai", "summary": "简介 Dataset和DataLoader在pytorch中主要用于数据的组织。这两个类通常一起搭配处理深度学习中的数据流。 Dataset 用于产出“单个样本”：定义怎么按索引取到一个样本，以及总共有多少个样本。 DataLoader 负责“成批取样”：决定批大小、是否打乱、多"}, {"title": "数据维度", "url": "数据维度.html", "category": "04-ai", "summary": "维度是什么 维度=数据需要“几个”索引才能定位到一个元素，也叫做轴数(axis)或阶(rank)。 可以看成\"套盒子\"的层数，盒子里面装盒子，再装数字。每多一层外括号/分类，就多一维。 0维=一个数；1维=一排数；2维=表格；3维=一摞表格；更高维=外面再套一层一层分类； 判断有"}, {"title": "再论transformer原理", "url": "再论transformer原理.html", "category": "04-ai", "summary": "概述 框架 以翻译作为例子，从宏观角度理解大模型，可以把大模型视为一个黑匣子，它可以输入一种语言然后输出另外一种翻译语言，如下图所示。 如果将模型稍微展开一下，模型分为encoders和decoders两部分。为什么要分为编码器和解码器了？主要是从以下动机考量。 条件生成需求：在"}, {"title": "lerobot ACT实现分析", "url": "lerobot-act实现分析.html", "category": "04-ai", "summary": "配置类ACTConfig @PreTrainedConfig.register_subclass(\"act\") @dataclass class ACTConfig(PreTrainedConfig): # 输入/输出结构 chunk_size: int = 100 # 动作块长"}, {"title": "具身智能ACT算法", "url": "具身智能act算法.html", "category": "04-ai", "summary": "基本原理 简单总结一下什么是ACT算法。传统的机器算法过程是观测关节位置J1经过模型预测动作A2然后执行，观测到J2预测数A3，观测到J3遇到A4依次类推，这样就有一个问题，假设预测出的A2跟实际相比偏差就比较大那么对应的观测到的J2就偏离比较大。如果要连续预测K步，就要连续采集"}, {"title": "lerobot策略优化器", "url": "lerobot策略优化器.html", "category": "04-ai", "summary": "torch.optim简介 在学校lerobot的策略优化器前，我们先再复习一下什么是优化器。 什么优化器 优化器官方解释就是在深度学习中让损失函数通过梯度下降思想逐步调整参数以达到最小损失。 简单理解优化器的就是更新计算参数的，根据损失函数的梯度方向调整模型权重和偏置值，公式为"}, {"title": "lerobot学习率调度器", "url": "lerobot学习率调度器.html", "category": "04-ai", "summary": "学习率调度器简介 是什么 学习率调度器（Learning Rate Scheduler）是深度学习训练中动态调整优化器学习率的工具（注意是在优化器的基础上动态调整学习率），通过优化收敛过程提升模型性能。 学习率（η）控制梯度更新步长，参数更新量 = -η × 梯度。过大步长导致震"}, {"title": "lerobot训练", "url": "lerobot训练.html", "category": "04-ai", "summary": "初始化 @parser.wrap() def train(cfg: TrainPipelineConfig): cfg.validate() # 验证配置合法性（如路径、超参数范围） init_logging() # 初始化日志系统（本地文件+控制台输出） if cfg.seed"}, {"title": "lerobot录制", "url": "lerobot录制.html", "category": "04-ai", "summary": "简介 lerobot record是关键核心流程，其包括了数据的采集和模型推理两部分。 如果是数据采集模式，命令启动如下 python -m lerobot.record \\ --robot.disable_torque_on_disconnect=true \\ --robot."}, {"title": "python补习", "url": "python补习.html", "category": "06-语言", "summary": "装饰器 函数装饰器 什么是装饰器 装饰器是python的一种高级语法，本质上是函数包装器，可以在不修改函数代码的前提下为函数添加额外功能如日志记录、性能计时、权限校验，也可以修改函数的输入和输出。装饰器通过@装饰器名语法应用与函数，也是一种语法糖，简化包装的代码。 基本语法与原理"}, {"title": "lerobot示教", "url": "lerobot示教.html", "category": "04-ai", "summary": "启动 示教的功能主要是主臂控制，从臂跟随，在数据采集是非常的一环。下面是模块启动的执行命令： python -m lerobot.teleoperate \\ --robot.type=so101_follower \\ --robot.port=/dev/ttyACM0 \\ --r"}, {"title": "lerobot设备标定", "url": "lerobot设备标定.html", "category": "04-ai", "summary": "why calibrate 先来看看标定后的数据 { \"shoulder_pan\": { #肩部旋转关节 \"id\": 1, \"drive_mode\": 0, \"homing_offset\": -1620, \"range_min\": 1142, \"range_max\": 2931 "}, {"title": "模型训练GPU跑飞", "url": "模型训练gpu跑飞.html", "category": "04-ai", "summary": "问题 当前使用的是魔改版的NVIDIA 2080 Ti 22G显卡，发现在模型训练过程中，跑着跑着就报错了，具体如下： raceback (most recent call last): File \"/home/laumy/lerobot/./src/lerobot/script"}, {"title": "手机给电脑配置代理", "url": "手机给电脑配置代理.html", "category": "10-其他", "summary": "手机设置 打开设置 设置IP地址，启用共享，注意这个ip地址设置跟电脑同一个局域网。 通过上面的步骤，手机的就启动的代理设置了代理服务为：192.168.0.29:1082。 电脑设置 以ubuntu为例，打开设置界面，打开代理。 将代理配置为手动模式，然后将所有的服务都代理到1"}, {"title": "安装unbuntu双系统", "url": "安装unbuntu双系统.html", "category": "10-其他", "summary": "准备 本文只作为个人安装简单记录，不做详细过程，如果是新手，可不必花时间再往下阅读。 准备一个16G以上的U盘，安装过程中跟实际的笔记本硬件会差异比较大。 下载ubuntu镜像 先下载ubuntu镜像：https://cn.ubuntu.com/download/desktop，"}, {"title": "lerobot搭建", "url": "lerobot搭建.html", "category": "04-ai", "summary": "设备查询 本文是记录ubuntu系统lerobot试验的快捷命令，方便开始负责执行设备，不会介绍为什么？ python -m lerobot.find_port python -m lerobot.find_cameras 机器标定 从臂标定 python -m lerobot."}, {"title": "pip install", "url": "pip-install.html", "category": "04-ai", "summary": "是什么 pip install 是python包管理器，用于python软件包的下载、安装、卸载等功能。 怎么用 在线安装 pip install 软件包名 pip install 软件包名==版本号 例如pip install requests，或pip install req"}, {"title": "ONNX Runtime C++端侧模型部署YOLOv5", "url": "onnx-runtime-c-端侧模型部署yolov5.html", "category": "04-ai", "summary": "加载准备 初始化ONNXRuntime环境 Ort::Env env(ORT_LOGGING_LEVEL_WARNING, \"YOLOv5Inference\"); Ort::Env 是 ONNX Runtime C++ API 中用于初始化运行环境的类，有多个重载的构造函数，下面"}, {"title": "ONNX Runtime Python端侧模型部署YOLOv5", "url": "onnx-runtime-python端侧模型部署yolov5.html", "category": "04-ai", "summary": "ONNX Runtime介绍 ONNX Runtime不依赖于Pytorch、tensorflow等机器学习训练模型框架。他提供了一种简单的方法，可以在CPU、GPU、NPU上运行模型。通常ONNX Runtime用于端侧设备模型的运行推理。要使用ONNX Runtime运行模型"}, {"title": "端侧vscode AI开发环境搭建", "url": "端侧vscode-ai开发环境搭建.html", "category": "02-risc-v", "summary": "PC上安装vscodium 下载安装vscodium，https://vscodium.com/ 安装Open Remote - SSH插件。 可能要等等比较久，跟网络有关系，如果还是安装不了，可以参考一下这个办法使用离线的方式，https://zhuanlan.zhihu.co"}, {"title": "llama.cpp部署大模型", "url": "llama-cpp部署大模型.html", "category": "04-ai", "summary": "安装llama.cpp 从GitHub上下载官方的源码。 git clone https://github.com/ggml-org/llama.cpp.git cd llama.cpp 使用camke进行编译，先创建build环境 cmake -B build 发现有报错cur"}, {"title": "自注意力机制", "url": "自注意力机制.html", "category": "04-ai", "summary": "运作原理 自注意力机制要解决的是让机器根据输入序列能根据上下文来理解。举个例子，输入句子为\"我有一个苹果手机\"，对于机器来说这里的\"苹果\"应该是指水果还是手机品牌了？所以要解决这个问题，就需要在上下文中去理解，那怎么在上下文中去理解了？那就是由句子中的其他词对于施加权重，让\"苹果"}, {"title": "transformer", "url": "transformer.html", "category": "04-ai", "summary": "模型结构 transform使用了自注意力机制，由编码器和解码器组成。 编码器 transformer的编码器输入一排向量，输出另外一排同样长度的向量。transformer的编码中加入了残差连接和层归一化，其中N X表示重复N此。首先在输入的地方需要加上位置编码，经过自注意力处"}, {"title": "YOLOv5端侧部署代码分析", "url": "yolov5端侧部署代码分析.html", "category": "04-ai", "summary": "模型流程 1. NPU初始化 NpuUint npu_uint; int ret = npu_uint.npu_init(); 2.根据传入的模型文件，创建网络 NetworkItem yolov5; status = yolov5.network_create(model_fi"}, {"title": "端侧部署YOLOv5模型", "url": "端侧部署yolov5模型.html", "category": "04-ai", "summary": "导出 ONNX模型 python export.py --weights runs/train/exp2/weights/ NPU不支持动态输入，使用onnxim工具进行转换为固定输入，先安装onnxsim工具。 pip install onnxsim -i https://py"}, {"title": "云服务器搭建YOLOv5训练环境", "url": "云服务器搭建yolov5训练环境.html", "category": "04-ai", "summary": "介绍 本文使用AutoDL云服务搭建YOLOv5的运行环境。 获取云服务器 在这个链接上https://www.autodl.com/home订阅服务，这里选择的是按量计费。 镜像选择基础镜像Mniconda最新ubuntu环境。 交钱订阅完成后就可以获取到登录的信息了。 这里使"}, {"title": "YOLOv2和YOLOv3", "url": "yolov2和yolov3.html", "category": "04-ai", "summary": "YOLOv2 回顾一下YOLOv1有哪些缺陷？ 边界框训练时回归不稳定，导致定位误差大。 每个网格只能预测两个边界框且只能识别一类目标。 小目标检测效果差。 针对以上的问题，YOLOv2进行了改进，下面从检测机制优化、网络结构优化、训练策略优化3个维度进行。 检测机制优化 锚框（"}, {"title": "YOLOv1目标检测原理", "url": "yolov1目标检测原理.html", "category": "04-ai", "summary": "介绍 YOLO在目标视觉检测应用广泛，You Only Look Once的简称。作者期望YOLO能像人一样只需要看一眼就能够立即识别其中的物体、位置及交互关系。能够达到快速、实时检测的效果。 YOLO检测系统可以简要分为3个步骤： Resize image：调整输入图像的大小为"}, {"title": "全连接层与卷积层参数计算", "url": "全连接层与卷积层参数计算.html", "category": "04-ai", "summary": "层的概念 在前面https://www.laumy.tech/2013.html有说明\"层与块\"概念，为了加深影响，本章再简要概括一下深度学习中常见的层。 在深度学习中，层（Layer)是神经网络的基本构建模块，负责对输入数据进行特定变换（如线性加权、非线性激活、特征提取等）。每"}, {"title": "opencv图像处理", "url": "opencv图像处理.html", "category": "04-ai", "summary": "图像滤波 图像的滤波核心是使用一个小的矩阵（滤波器或卷积核）在图像上进行滑动卷积，将计算得到的结果作为目标像素的值。 均值滤波 cv::blur(InputArray src, OutputArray dst, Size ksize, Point anchor = Point(-"}, {"title": "opencv视频流", "url": "opencv视频流.html", "category": "04-ai", "summary": "环境准备 本文通过采集USB摄像头来示例说明 export LD_LIBRARY_PATH=/mnt/extsd/usr/lib:$LD_LIBRARY_PATH #指定库的路径 cat /sys/devices/platform/soc/usbc0/usb_host #激活US"}, {"title": "opencv基础操作", "url": "opencv基础操作.html", "category": "04-ai", "summary": "图像的读取和显示 读写图像 cv::Mat image = cv::imread(\"image.jpg\", cv::IMREAD_COLOR); 使用imread函数读取图像，第一个参数是图像文件的路径，第二个参数是解释图像的颜色和格式（如彩色图像、灰度图像等）。第二个参数可省略"}, {"title": "perf工具使用", "url": "perf工具使用.html", "category": "01-linux", "summary": "perf介绍 perf 是一个强大的 Linux 性能分析工具，广泛用于分析程序的性能瓶颈，帮助开发者进行调优。perf 工具能够收集并分析多种硬件和软件事件，包括 CPU 的指令执行、缓存命中与失误、上下文切换等。 硬件事件驱：通过访问 CPU 的 PMU（性能监控单元）捕获硬"}, {"title": "优化算法", "url": "优化算法.html", "category": "04-ai", "summary": "局部最小与全局最小 对应任何目标函数f(x)，当然这里的目标函数可以是损失函数。如果在x处对应的f(x)小于x附近任意点的f(x)，那么f(x)是局部最小的。如果f(x)在x处的值是整个域中目标函数的最小值，那么f(x)是全局最小值。 除了局部最优解外，鞍点也是梯度为0的区域。什"}, {"title": "计算机视觉", "url": "计算机视觉.html", "category": "04-ai", "summary": "图像增广 什么是图像增广？图像增广（Image Augmentation）是通过对原始图像进行一系列随机变换（如旋转、裁剪、颜色调整等）生成多样化样本的数据增强技术，旨在扩充训练数据集、提升模型泛化能力。其核心逻辑是模拟真实场景中可能存在的多样性，使模型学习到更鲁棒的特征。 深度"}, {"title": "现代卷积神经网络", "url": "现代卷积神经网络.html", "category": "04-ai", "summary": "深度卷积神经网络AlexNet AlexNet相对LeNet的特点就是层数变得更深了，参数变得更多了。AlexNet由八层组成：五个卷积层、两个全连接隐藏层和一个全连接输出层。AlexNet使用ReLU而不是sigmoid作为其激活函数。 import torch from to"}, {"title": "卷积神经网络CNN", "url": "卷积神经网络cnn.html", "category": "04-ai", "summary": "图像卷积 图像卷积是有一个卷积核，这个卷积核对输入做相关运算。卷积核从输入的张量左上角开始、从左到右、从上到下进行滑动，每到一个位置时，在该窗口的部分张量与卷积核做点积得到一个输出。 为什么要使用卷积了，主要是要解决以下问题 参数爆炸问：传统全连接网络处理图像时参数规模过大（如1"}, {"title": "非暴力沟通", "url": "非暴力沟通.html", "category": "09-阅读", "summary": "非暴力沟通要素 观察： 不带评论的观察 感受：体会(对方)和表达（自己）感受（区分想法和感受） 需要：体会（对方）和表达（自己）需求 请求：体会（对方）和表达（自己）请求（一定是要具体的请求，不要含糊） 沟通的过程 观察实际发生了什么事实？ 表达出我们看到的这些行为的感受 表达出"}, {"title": "层与块", "url": "层与块.html", "category": "04-ai", "summary": "简单来说，如下图，第一个图中间5个神经元组成了一个层。第二图3个层组成了块。第三个图中3个块组成了整个模型。 层 层是神经网络的基本计算单元，负责对输入数据进行特定形式的变换，如线性映射、非线性激活等。其主要的功能是接收输入数据，生成输出结果。其中包含学习参数（如全连接层的权重和"}, {"title": "梯度计算", "url": "梯度计算.html", "category": "04-ai", "summary": "什么是梯度 梯度(Gradient)是用于描述多元函数在某一点的变化率最大的方向及其大小。在深度学习中，梯度被广泛用于优化模型参数(如神经网络的权重和偏置)，通过梯度下降等算法最小化损失函数。 对于多元函数 $f(x_1, x_2, \\dots, x_n)$，其梯度是一个向量，由"}, {"title": "前向传播、反向传播和计算图", "url": "前向传播-反向传播和计算图.html", "category": "04-ai", "summary": "前向传播（Forward Propagation） 前向传播是神经网络中从输入数据到输出预测值的计算过程。它通过逐层应用权重（W）和偏置（b），最终生成预测值 $y' $，并计算损失函数$L $。 模型定义 $$ y' = W \\cdot x + b $$ 损失函数（均方误差） "}, {"title": "激活函数", "url": "激活函数.html", "category": "04-ai", "summary": "概念 前面我们主要使用的是线性模型，但是线性模型有很多局限性，因为我们要建模的问题并不能单纯使用线性模型就能够拟合的，如下示例。 我们要拟合红色部分的函数，使用线性模型即使在怎么调整W和b都没法进行拟合出来，要拟合这样的函数，我们需要非线性的函数。 如上图，要拟合这样的模型，我们"}, {"title": "sotfmax回归实现", "url": "sotfmax回归实现.html", "category": "04-ai", "summary": "什么是sotfmax回归 Softmax回归（Softmax Regression），也叫多项逻辑回归，是一种用于多分类问题的分类算法。它是对逻辑回归（Logistic Regression）的一种扩展，适用于处理输出类别数大于2的情况。Softmax回归通过使用Softmax函"}, {"title": "线性回归实现", "url": "线性回归实现.html", "category": "04-ai", "summary": "线性回归 线性回归模型根据给定的数据集和对应的标签，通过一个函数模型来拟合数据集以及对应标签的映射关系。而这个模型可以设置为y=wx+b的一个函数，其中x和w是一个向量。目标就是找出权重w和偏执b的值，使得模型更逼近数据集合的规律，也就是能够预测的更准确。 线性回归示例实现 py"}, {"title": "小智Ai语音交互简要分析", "url": "小智ai语音交互简要分析.html", "category": "04-ai", "summary": "app start 主要是初始化板级、显示、WiFi连接、音频codec、编解码、协议、音效、唤醒几个环节。 auto& board = Board::GetInstance(); //获取板级实例 SetDeviceState(kDeviceStateStarting);//设"}, {"title": "C++回顾", "url": "c-回顾.html", "category": "06-语言", "summary": "平时用C++比较少，最近项目需要用到C++,现简单再回顾一下。 单例模式 在某些场景下，一个类只需要有一个实例就足够了，例如配置管理类、日志记录器、数据库连接池等。使用单例模式可以避免创建多个实例导致的资源浪费、数据不一致等问题。 单例模式是一种创建型设计模式，它确保一个类只有一"}, {"title": "裁剪脚本", "url": "裁剪脚本.html", "category": "07-调试", "summary": "查找当前目录大于指定大小 #!/bin/bash # 遍历当前目录及子目录中的所有文件 find . -type f -exec du -b {} + | while read size file; do # 如果文件大小为50KB（即50 * 1024字节） if [ \"$si"}, {"title": "2条命令本地部署deepseek", "url": "2条命令本地部署deepseek.html", "category": "04-ai", "summary": "环境是centos，下面是部署步骤。 命令1： 安装ollama 安装命令：curl -fsSL https://ollama.com/install.sh | sh 安装日志： >>> Cleaning up old version at /usr/local/lib/olla"}, {"title": "豆包大模型接入体验", "url": "豆包大模型接入体验.html", "category": "04-ai", "summary": "前置条件 需要先创建获得API key和创建推理接入点。 API key获取 https://www.volcengine.com/docs/82379/1361424#f79da451 创建推理接入点 https://www.volcengine.com/docs/82379/"}, {"title": "MacBook上ubuntu虚拟机共享", "url": "macbook上ubuntu虚拟机共享.html", "category": "10-其他", "summary": "步骤1： 安装paralles tools 步骤2：执行install安装 报错处理 一通操作还是不行，原因是paralles tools没有匹配当前的内核版本，只能升级parallel 版本了。或者升级一个parallel desktop版本获取到parallel tools安"}, {"title": "emqx通过REST API获取设备是否在线", "url": "emqx通过rest-api获取设备是否在线.html", "category": "10-其他", "summary": "本文通过emqx REST API的方式来进行配置 创建一个API密钥 记录密钥的名称 API key是用户名称，Secret KEY是密码 浏览器登录验证 用户名就是 API Key，密码就是Secret KEY. 登录上之后就可以获取到设备的信息了。 可以参考： http:/"}, {"title": "基于nodejs搭建jsonp环境", "url": "基于nodejs搭建jsonp环境.html", "category": "10-其他", "summary": "安装 安装 Node.js 和 npm：执行以下命令安装 Node.js 和 npm： yum install -y nodejs 创建工程 步骤1： 创建一个新的Node.js项目目录，并进入该目录： mkdir jsonp-server cd jsonp-server 步骤2"}, {"title": "webrtc网页代码分析一", "url": "webrtc网页代码分析一.html", "category": "10-其他", "summary": "文档结构 <!doctype html> <html lang=\"en\"> <head> ... </head> <body> ... </body> </html> 文档类型声明（）：声明文档使用HTML5标准。 html标签：设置文档的语言为英语（lang=\\\"en\\\"）。 "}, {"title": "webrtc网页代码分析二", "url": "webrtc网页代码分析二.html", "category": "10-其他", "summary": "交互流程 上图是完整的处理流程。 获取URL参数 const queryString = window.location.search; const urlParams = new URLSearchParams(queryString); const deviceId = ur"}, {"title": "javascript之dom", "url": "javascript之dom.html", "category": "10-其他", "summary": "什么是dom DOM（Document Object Model）是一个编程接口，它将 HTML 或 XML 文档呈现为一个由节点和对象（这些节点和对象其实是文档的各种元素、属性和文本内容等）组成的树形结构。这个树形结构允许开发者使用编程语言（如 JavaScript）来访问、修"}, {"title": "快速搭建一个可访问的网页", "url": "快速搭建一个可访问的网页.html", "category": "10-其他", "summary": "简介 搭建网站需要以下几个组件， Web服务器（如Apache、Nginx）：它是网页能够被访问的核心组件。当用户在浏览器中输入网站的域名或 IP 地址并请求访问网页时，Web 服务器软件会接收这些 HTTP 请求。负责从服务器的存储设备（如硬盘）中找到对应的网页文件（如 HTM"}, {"title": "openwrt规则编译cmake软件包", "url": "openwrt规则编译cmake软件包.html", "category": "10-其他", "summary": "软件包中有完整CMakelists.txt include $(TOPDIR)/rules.mk PKG_NAME:=usrsctp PKG_VERSION:=0.9.5.0 PKG_RELEASE:=3 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION"}, {"title": "Cmake构建模版", "url": "cmake构建模版.html", "category": "07-调试", "summary": "# 指定 CMake 的最低版本要求。它应该是 CMakeLists.txt 文件中的第一个命令。 cmake_minimum_required(VERSION 3.10) # 定义项目的名称 project(mpp_webrtc) # 要编译的源文件,先收集在SRCS变量中。 "}, {"title": "部署MQTT云服务", "url": "部署mqtt云服务.html", "category": "10-其他", "summary": "Centos安装 配置emqx的源 curl -s https://assets.emqx.com/scripts/install-emqx-rpm.sh | sudo bash NaN. 安装emqx sudo yum install emqx -y NaN. 启动emqx s"}, {"title": "coturn安装", "url": "coturn安装.html", "category": "10-其他", "summary": "安装 yum install coturn -y 配置 vim /etc/coturn/turnserver.conf listening-port=3478 #指定 coturn 监听的端口。默认的 TURN 协议端口是 3478，用于接收 TURN 客户端的连接请求。 tls"}, {"title": "STUN协议", "url": "stun协议.html", "category": "08-网络", "summary": "NAT墙 完全锥形 IP限制型锥形 端口限制型锥形 对称型 NAT穿透 STUN协议简介 STUN（Session Traversal Utilities for NAT）是一个用于帮助客户端发现其所在NAT之后的公网IP地址和端口号。通信的双方都能知道所在的公网IP，并且能够让"}, {"title": "libpeer分析", "url": "libpeer分析.html", "category": "08-网络", "summary": "关键数据结构 PeerConfiguration typedef struct PeerConfiguration { IceServer ice_servers[5]; MediaCodec audio_codec; MediaCodec video_codec; DataCh"}, {"title": "乌龟图分析法", "url": "乌龟图分析法.html", "category": "09-阅读", "summary": "结构形似乌龟，身体是主体，头尾脚代表着互相关联的六个要素。 身体：代表过程、活动。 头部：达标input，即过程的要求，是分析的关键。 左前脚：代表Procedure，指的操作的方法，怎么做？ 右前脚：达标Resources，是做成这件事需要的非人工资源。 右后脚：代表who，谁"}, {"title": "MQTT协议分析", "url": "mqtt协议分析.html", "category": "08-网络", "summary": "什么是MQTT MQTT是基于TCP/IP网络协议栈构建的异步通信消息协议，基于发布-订阅模式进行传输。实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中, MQTT协议中有三种身份: 发布者(Publish)、代理(Broker)(服务器)、订阅者(Subscribe)"}, {"title": "看wireshark报文技巧", "url": "看wireshark报文技巧.html", "category": "08-网络", "summary": "TCP握手与挥手 握手看SYNC与ACK 第一次握手[SYNC]标志, 第二次握手看[SYNC,ACK]标志，第三次ACK。 挥手看FIN 报文交互 正常交互 先看len，当长度为0,这个包是ack包，长度不为0表示是发送的数据包。 再看ack，表示该值以前的序号都收到了。ack"}, {"title": "SSL/TLS协议分析", "url": "ssl-tls协议分析.html", "category": "08-网络", "summary": "什么是TLS 1994: SSL 1.0 NetScape公司提出SSL第一版，未公开。 1995: SLL 2.0 公开发布了第二版，与2011年弃用。 1996: SSL 3.0 第三版得到大规模应，于2015年弃用。 1999: TLS 1.0 RFC2246，被IETF纳"}, {"title": "拍照示例代码分析", "url": "拍照示例代码分析.html", "category": "01-linux", "summary": "数据结构 待补充 初始化启动 启动MPP系统 MPP_SYS_CONF_S mSysConf; memset(&mSysConf, 0, sizeof(MPP_SYS_CONF_S)); mSysConf.nAlignWidth = 32; AW_MPI_SYS_SetConf("}, {"title": "RTSP视频传输示例代码分析", "url": "rtsp视频传输示例代码分析.html", "category": "01-linux", "summary": "数据流通路： CSI -> ISP -> VIPP -> VirChn -> VENC CSI：表示物理 Camera Signal Input Pasrse Device 的接口。CSI 可以选择连接任意一个 ISP。最多支持 3 个 CSI。 ISP：表示物理 ISP。ISP"}, {"title": "移动检测代码示例分析", "url": "移动检测代码示例分析.html", "category": "01-linux", "summary": "数据结构 VencMotionSearchParam typedef struct { int en_motion_search; // 移动侦测功能使能开关，1：开，0：关。 int dis_default_para; // 是否禁用默认参数，1：使用用户自定义参数，0：使用默"}, {"title": "SSL证书更新", "url": "ssl证书更新.html", "category": "10-其他", "summary": "获取免费证书 下载证书 下载证书文件 解压后的文件如下 安装证书 步骤1： 登录服务器，找到证书路径，可以使用nginx -t查找证书路径。 [root@laumy conf.d]# nginx -t nginx: the configuration file /etc/ngin"}, {"title": "Linux系统编译生成镜像流程", "url": "linux系统编译生成镜像流程.html", "category": "07-调试", "summary": "编译内核 清除内核 命令 ${MAKE} O= mrproper 示例 make CROSS_COMPILE=riscv32-unknown-linux- ARCH=riscv -j16 O=kernel/build KERNEL_SRC=kernel/linux-5.4 INS"}, {"title": "随记", "url": "随记.html", "category": "09-阅读", "summary": "书籍： 《少有人走的路》 《麦肯锡意识》 领导力技能 领导技能：新职务需要的能力 时间管理：时间分配结构，决定如何工作 工作理念：信念和价值观，让工作聚焦 不同维度的示例 书籍： 《少有人走的路》 《麦肯锡意识》 领导力技能 领导技能：新职务需要的能力 时间管理：时间分配结构，决"}, {"title": "I2C协议总结", "url": "i2c协议总结.html", "category": "05-外设", "summary": "简介 以下是 I2C 总线的一些特性： 只需要两条线；串行数据线（SDA）和串行时钟线（SCL）。 连接到总线的每个设备都可以通过唯一的地址进行软件寻址简单的控制器/目标关系始终存在；控制器可以作为控制器发射器或控制器接收器。 它是真正的多控制器总线，包括冲突检测和仲裁，以防止如"}, {"title": "系统死机排查思路", "url": "系统死机排查思路.html", "category": "03-rtos", "summary": "反汇编现场寄存器 kasan watchpoint： 针对固定位置 栈溢出检测： cache：检查地址对齐、长度对齐（少/多刷，少/多无效）。 现象一般是watchpoint抓不到，软件复位无效，如USB驱动与cpu会同时操作内存。 硬件： 排除个体差异，存在电压、电流等不稳定，"}, {"title": "视频编码示例", "url": "视频编码示例.html", "category": "01-linux", "summary": "通路：CSI > ISP > VIPP > VirChn > VENC。 CSI：表示物理 Camera Signal Input Pasrse Device 的接口。CSI 可以选择连接任意一个 ISP。最多支持 3 个 CSI。 ISP：表示物理 ISP。ISP 可以选择连接"}, {"title": "内存地址对齐", "url": "内存地址对齐.html", "category": "07-调试", "summary": "内存地址对齐是在内存中的数据（具体为变量的地址、内存块的地址）按照指定地址长度对齐，包含了基本的变量数据对齐和结构体数据对齐。 为什么需要内存对齐？ 可以提高CPU和内存交互的效率，比如一个32位的系统，CPU读取内存，硬件设计上只支持4字节或4字节的倍数对齐进行地址访问，CPU"}, {"title": "function graph tracer原理", "url": "function-graph-tracer原理.html", "category": "01-linux", "summary": "概述 Function graph相对function trace的不同点是，在函数入口会trace，在函数出口也会trace。 ksys_read ->vfs_read ->ftrace_caller ->prepare_ftrace_return ->function_gra"}, {"title": "Camera基础知识", "url": "camera基础知识.html", "category": "01-linux", "summary": "框架可以分为kernle层、Video input framework、Device Driver层 V4L2与Media device Framework V4L2 Framework： 是video for Linux Two的简称。是Linux标准通用基础视频框架，向下屏蔽"}, {"title": "静态ftrace", "url": "静态ftrace.html", "category": "01-linux", "summary": "上面章节主要描述的是动态ftrace，在早期还有静态ftrace。区别主要如下： - 动态ftrace与静态ftrace在编译参数方面静态编译使用的是参数“-pg”，而动态使用的是fpatchable-function-entry。 - 工具链使能“-pg”参数时，会在每个函数体"}, {"title": "动态function tracer原理", "url": "动态function-tracer原理.html", "category": "01-linux", "summary": "fpatchable-function-entry选项 编译时指定-fpatchable-function-entry=N[,M]，①会在函数入口第一个指令之前插入N个nop，但是会保留M个放到函数入口之前，如果省略M则默认为0；②同时需要一个特殊的-fpatchable-fun"}, {"title": "ftrace-概述", "url": "ftrace-概述.html", "category": "01-linux", "summary": "ftrace是一个内部跟踪器，用于帮助开发人员查找内核正在发生的事情，它可用于调试或分析用户空间之外发生的延迟和性能问题。ftrace从名称上看是function trace，函数跟踪器，但它实际并不限制函数跟踪，而是多个不同跟踪实用程序的框架。延迟跟踪可以检查在禁用和启用中断之"}, {"title": "ftrace的使用", "url": "ftrace的使用.html", "category": "01-linux", "summary": "tracer irqsoff 当关闭中断时，CPU就无法响应中断了（NMI和SMI除外），无法响应外部事件做出反应。这会阻止定时器触发或鼠标中断触发，导致系统延迟。 irqsoff跟踪器跟踪中断被禁用的时间，当达到新的最大延迟时，跟踪器会保存导致该延迟点的跟踪，一边每次达到新的最"}, {"title": "arch初始化", "url": "arch初始化.html", "category": "02-risc-v", "summary": "_start_kernel: /* Mask all interrupts */ csrw CSR_SIE, zero csrw CSR_SIP, zero ① 将sie，sip寄存器设置为0，关闭所有中断和清除中断的pending（不是异常）。 /* Load the glob"}, {"title": "临时虚拟地址空间映射", "url": "临时虚拟地址空间映射.html", "category": "02-risc-v", "summary": "概述 为什么要做临时虚拟地址空间映射？ 一旦开启MMU，PC的下一条指令地址会经过MMU转化，未开启MMU之前地址的翻译是不需要经过MMU转化直接访问。对应开启MMU之后，应该要使用虚拟地址，才能访问到正确的指令内存。 前面描述了虚拟地址转换为物理地址是通过MMU自动转换，但是需"}, {"title": "使能MMU", "url": "使能mmu.html", "category": "02-risc-v", "summary": "① 多核情况使能MMU .Lsecondary_start: #ifdef CONFIG_SMP /* Set trap vector to spin forever to help debug */ la a3, .Lsecondary_park csrw CSR_STVEC,"}, {"title": "虚拟地址与物理地址概念", "url": "虚拟地址与物理地址概念.html", "category": "02-risc-v", "summary": "地址空间 虚拟地址：程序使用的内存地址；物理地址：硬件的地址空间。虚拟地址通过MMU转化为物理地址，虚拟地址的长度与实际的物理内存容量没有关系，从系统中每个进程的角度看，地址空间的进程无法感知其他进程的存在。 32位cpu处理的地址空间为2^32=4G，所以虚拟地址空间为4G，分"}, {"title": "Linux系统RISC-V架构启动流程分析之概述", "url": "linux系统risc-v架构启动流程分析之概述.html", "category": "02-risc-v", "summary": "典型的linux系统启动流程如上，但本文主要探讨的是OS的启动流程，opensbi，uboot暂不涉及。主要围绕arch/riscv/kernel/head.S进行分析。 _start j _start_kernel _start_kernel arch init //关中断，关"}, {"title": "启动第一个应用进程", "url": "启动第一个应用进程.html", "category": "02-risc-v", "summary": "start_kernel ...... arch_call_rest_init() rest_init(); pid = kernel_thread(kernel_init, NULL, CLONE_FS); static int __ref kernel_init(void *"}, {"title": "虚拟地址空间与物理地址空间完整映射", "url": "虚拟地址空间与物理地址空间完整映射.html", "category": "02-risc-v", "summary": "setup bootmem 物理内存都添加到系统之后，会调用setup_bootmem对整个物理内存进行整理，主要的工作就是remove掉一些no-map区域（不归内核管理），同时保留一些关键区域，如内核镜像区，dtb中reserved的内存节点。 上图中，浅绿色的就是reser"}, {"title": "异常初始化", "url": "异常初始化.html", "category": "02-risc-v", "summary": "异常处理概述 略 异常入口 start_kernel trap_init(); void __init trap_init(void) { /* * Set sup0 scratch register to 0, indicating to exception vector * "}, {"title": "挂载根文件系统", "url": "挂载根文件系统.html", "category": "02-risc-v", "summary": "根文件系统是控制权从linux内核转移到用户空间的一个桥梁，文件系统的挂载需要提供挂载点，linux内核在初始化时汇初始化一个虚拟的“/”目录用于根文件系统的挂载。 start_kernel vfs_caches_init() mnt_init() init_rootfs() i"}, {"title": "Linux risc-v head.S调试记录", "url": "linux-risc-v-head-s调试记录.html", "category": "02-risc-v", "summary": "调试准备 gdb调试 0x0000000080200000为opensbi跳转执行的物理地址，linux内核的img会加载到这个地址运行，如果要在这个地方断点，就b *(0x0000000080200000),没法对head.S中进行断点，因为linux加载后会变成虚拟地址。调试"}, {"title": "freertos内存管理", "url": "freertos内存管理.html", "category": "03-rtos", "summary": "freertos一共有5种内存管理算法，heap3直接使用的是c库的管理算法，只是对c库封装了一层接口。本章节主要分析heap1、heap2、heap4； heap1 heap2 heap4 heap5 heap5与heap4相比，支持了允许内存堆跨越多个不连续的内存段，这种情况"}, {"title": "道德经", "url": "道德经.html", "category": "09-阅读", "summary": "第一章 原文 道可道，非常道；名可名，非常名。 无名天地之始，有名万物之母。 故常无，欲以观其妙；常有，欲以观其徼（jiao,叫）。 此两者，同出而异名，同谓之玄。 玄之又玄，众秒之门。 译文 “道”，如果可以说得出来，那么它就不是永恒不变的“道”（即不是那个“道”）。 “名”，"}, {"title": "kasan原理", "url": "kasan原理.html", "category": "07-调试", "summary": "kasan是什么？（基本原理） kasan是用于内存检测的工具，能够检测内存以下异常。 buffer-overflow in heap,stack and globals use-after-free uninitialized-memory-read user-memory-a"}, {"title": "freertos栈溢出检测原理", "url": "freertos栈溢出检测原理.html", "category": "03-rtos", "summary": "portSTACK_GROWTH > 0：栈向上生长 portSTACK_GROWTH < 0: 栈向下生长，本章使用栈向下生长 打开 configRECORD_STACK_HIGH_ADDRESS 1，将PCB中将打开pxEndOfStack，结构如下。 adress:0+ul"}, {"title": "RISC-V backtrace实现原理", "url": "risc-v-backtrace实现原理.html", "category": "02-risc-v", "summary": "start_kernel addi sp,sp,-16 ---① 分配栈帧sp=sp-16,sp指向栈顶 sw ra,12(sp) ---② 将ra存储到sp+12的位置 sw s0,8(sp) xxxxxx jal ra, 6000dba2 <backtrace> xxxxxx"}, {"title": "RISC-V动态链接实验", "url": "risc-v动态链接实验.html", "category": "02-risc-v", "summary": "准备 实验环境 qemu linux启动环境： https://www.laumy.tech/1186.html 代码 动态库 cat swap.c #include <stdio.h> int shared = 1; int z; void swap(int *a, int *"}, {"title": "opensbi分析（二）", "url": "opensbi分析-二.html", "category": "02-risc-v", "summary": "待补充...... 参考： 玄铁处理器Linux移植"}, {"title": "opensbi分析（一）", "url": "opensbi分析-一.html", "category": "02-risc-v", "summary": "引导Hart启动 _start: /* Find preferred boot HART id */ MOV_3R s0, a0, s1, a1, s2, a2 # 将a0,a1,a2的参数分别赋值为s0,s1,s2,这3个参数是前一阶段传入的参数。 # a0: hart id "}, {"title": "qemu+opensbi+uboot+linux+busybox启动环境搭建", "url": "qemu-opensbi-uboot-linux-busybox启动环境搭建.html", "category": "02-risc-v", "summary": "前置条件 qemu+工具链安装 安装好交叉编译工具链和qemu环境，参考：https://www.laumy.tech/1127.html#risc-v64_Xuantie 代码下载 opensbi：[version: v1.2](https://gitee.com/tinyla"}, {"title": "RISC-V架构与FreeRTOS任务栈变化", "url": "risc-v架构与freertos任务栈变化.html", "category": "02-risc-v", "summary": "栈的基本概念 在FreeRTOS中，每个任务有一个全局的tskTCB实例，pxCurrentTCB指针指向的是正在运行的任务实例，有三个和栈相关的变量pxTopOfStack和pxStack，pxEndOfStack。 pxTopOfStack指向当前堆栈栈顶，随着进栈出栈，px"}, {"title": "平头哥E90X的head.S分析", "url": "平头哥e90x的head-s分析.html", "category": "02-risc-v", "summary": "关闭中断 /* disable interrupt */ li t0, MR_MIE --- t0=0x08 csrc mstatus, t0 --- mstatus = mstatus | ~t0 csrw mie, zero --- mie = zero mstatus第4b"}, {"title": "平头哥E90X异常处理", "url": "平头哥e90x异常处理.html", "category": "02-risc-v", "summary": "上下文入栈保存 addi sp, sp, -portCONTEXT_SIZE ----开辟一段栈空间，这里的sp可能是主栈或任务栈 store_x x1, 1 * portWORD_SIZE( sp ) ----依次存储相关寄存器 store_x x5, 2 * portWORD"}, {"title": "平头哥E90X中断处理汇编部分", "url": "平头哥e90x中断处理汇编部分.html", "category": "02-risc-v", "summary": "任务上下文保存 addi sp, sp, -portCONTEXT_SIZE store_x x1, 1 * portWORD_SIZE( sp ) store_x x5, 2 * portWORD_SIZE( sp ) store_x x6, 3 * portWORD_SIZE"}, {"title": "平头哥RISC-V+gdb+vscode调试", "url": "平头哥risc-v-gdb-vscode调试.html", "category": "02-risc-v", "summary": "工具准备 T-HeadDebugServer工具：https://www.xrvm.cn/community/download?id=4238019891233361920 T-HeadDebugServer使用说明：https://www.xrvm.cn/community/d"}, {"title": "RISC-V指令集架构", "url": "risc-v指令集架构.html", "category": "02-risc-v", "summary": "简介 RISC-V是一个通用的指令集架构（ISA），ISA是底层硬件电路面向上层软件程序提供的一层接口规范，ISA定义了： 基本数据类型，BYTE/HALFWORD/WORD 寄存器 指令 寻址模式 异常或中断处理方式 之所以需要ISA，是为上层软件提供一层抽象，制定规则和约束，"}, {"title": "qemu-system-riscv64 virt平台ROM代码启动分析", "url": "qemu-system-riscv64-virt平台rom代码启动分析.html", "category": "02-risc-v", "summary": "为什么下面qemu启动elf时，text地址要从0x80000000开始？ qemu-system-riscv64 -machine virt -cpu c910v -nographic -smp 1 -bios none -kernel xxx.elf 从memory mapp"}, {"title": "RISC-V汇编指令", "url": "risc-v汇编指令.html", "category": "02-risc-v", "summary": "C源代码 unsigned int arithmetic(unsigned int a, unsigned int b) { unsigned int sum, diff, upper; sum = a + b; sum = sum + 2; diff = a - b; diff"}, {"title": "HTML+CSS学习随记", "url": "html-css学习随记.html", "category": "06-语言", "summary": "HTML基本结构 示例1 <!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\"> 1.这是 HTML 4.01 的文档类型声明，表示该文档遵循 H"}, {"title": "Javascript笔记", "url": "javascript笔记.html", "category": "06-语言", "summary": "JS JS简介 JS实现网页交互过程 javascript： 1.让用户和网页进行交互 网站登录功能， 点击，弹出一个按钮 滚动加载 返回底部 2.交互三要素 目标：网页中的那些html元素 事件：触发了什么事件 事件处理程序：针对事件要做什么要的动作 <body> <butto"}, {"title": "环境搭建", "url": "环境搭建.html", "category": "02-risc-v", "summary": "risc-v32入门 https://github.com/plctlab/riscv-operating-system-mooc/blob/main/README_zh.md 按照上面的进行搭建，工具链和qemu都不用编译，直接解压设置环境变量后可使用，需要注意的是ubuntu"}, {"title": "麦肯锡意识", "url": "麦肯锡意识.html", "category": "09-阅读", "summary": ""}, {"title": "金字塔原理", "url": "金字塔原理.html", "category": "09-阅读", "summary": "思维导图 写文章使用的结构"}, {"title": "静态链接与动态链接", "url": "静态链接与动态链接.html", "category": "07-调试", "summary": "经过[ELF格式解析](https://www.laumy.tech/1085.html \\\\\"ELF格式解析\\\\\")章节描述，对ELF文件有了一定的了解，本章节继续来探讨处于链接阶段的：静态链接与动态链接。 静态链接 以下是本小节的实验代码。 ----> a.c extern "}, {"title": "ELF格式解析", "url": "elf格式解析.html", "category": "07-调试", "summary": "编译过程 工具链把程序源文件翻译成可执行文件一般经理4个步骤：预处理、编译、汇编、链接。本章节关于静态链接和动态链接的过程主要就是在第4个过程。链接器会将输入目标文件(.o)经过加工后合并成一个输出文件，这里的输出文件以linux的ELF为例。链接器会将相同性质的段合并在一起，如"}, {"title": "SPI与DBI概念", "url": "spi与dbi概念.html", "category": "05-外设", "summary": "SPI 标准SPI 标准SPI接口，4根线CS、CLK、MISO、MOSI。4根线都是单线传输，主机通过MOSI发送数据，设备通过MISO发送数据给主机。标准的SPI可以支持全双工（发和收同时）、半双工（某个时刻发或收）、单双工（单方向传输，主机要么只能发送，要么只能接收）。 D"}, {"title": "内存相关问题排查思路", "url": "内存相关问题排查思路.html", "category": "03-rtos", "summary": "最近在项目上遇到一个棘手问题，有一块内存在运行过程中概率性的被异常修改，由于牵扯到多方的应用程序，受限于调试手段排查了不少时间，现简单总结下遇到此类问题的排查思路。 添加额外的magic 核心原理就是在malloc的时候，额外多申请一些内存，通常情况下是在头部和尾部多申请一块空间"}, {"title": "使用wordpress搭建https client的测试服务器", "url": "使用wordpress搭建https-client的测试服务器.html", "category": "10-其他", "summary": "前置条件：将wordpress设置为固定链接，参考前面章节https://www.laumy.tech/968.html 进行先设置。 外观->主题编辑器->function.php添加以下代码： add_action( 'rest_api_init', function () "}, {"title": "wordpress怎么被google，百度搜索到。", "url": "wordpress怎么被google-百度搜索到.html", "category": "10-其他", "summary": "前置 先安装插件Yoast SEO,获取到XML 站点地图 Yoast SEO --》设置界面 --->API接口（拉到最下页面） 复制下面几个链接 然后登陆谷歌和百度添加到资源文件 谷歌 https://search.google.com/search-console/abou"}, {"title": "wordpress设定固定链接", "url": "wordpress设定固定链接.html", "category": "10-其他", "summary": "仪表盘设置固定链接 wordpress仪表盘面板->设置->固定链接 这里选择自定义结构：htttps://your.domain.tech/%post_id%.html 网站支持伪静态 按照上面方法修改后，发现访问之前的文章出现404，那是没有设置网站环境支持伪静态，使用Ngi"}, {"title": "内存测量", "url": "内存测量.html", "category": "01-linux", "summary": "系统占用内存 free 旧版本free $ free total used free shared buffers cached Mem: 65960636 63933576 2027060 73392 1602076 32628548 -/+ buffers/cache: 29"}, {"title": "进程虚拟内存", "url": "进程虚拟内存.html", "category": "01-linux", "summary": "进程虚拟地址空间 Executable and Linkable Format（ELF） 上图是可执行文件的内容结构图，由ELF header、program headers、各section、sections headers组成。 - ELF header：描述整个文件的基本属"}, {"title": "DMA与cache一致性", "url": "dma与cache一致性.html", "category": "01-linux", "summary": "无DMA时：设备与内存之间数据搬运需要依靠CPU来完成。 有DMA时：DMA可以直接完成设备与内存直接的数据搬运，不需要cpu介入。 DMA的引入，优点是数据在内存和设备之间的搬运不需要CPU参与，这极大降低了CPU的负荷。但是也引入了新的问题，即cpu读取到的数据不一定是最新的"}, {"title": "连续内存分配器CMA", "url": "连续内存分配器cma.html", "category": "01-linux", "summary": "CMA,contiguous memory allocator是内存管理子系统的一个模块，其主要为了解决分配连续的物理内存。尽管有了伙伴系统、slab分配器以及相关的内存回收机制，但是对于一些驱动如camera、display等模块一下需要分配比较大的一块连续物理内存，随着系统运"}, {"title": "slub分配器", "url": "slub分配器.html", "category": "01-linux", "summary": "伙伴系统内存分配是以物理页面4KB为单位，但是实际使用的时候不会一下使用到4KB。实际使用中很多情况会以字节为单位。因此为了更精确的划分使用内存，linux内核在伙伴系统之上使用slab分配器来进行管理。截止目前linux内核中从最初slab发展到现在，衍生了slub，slob三"}, {"title": "伙伴系统", "url": "伙伴系统.html", "category": "01-linux", "summary": "相关结构体 核心结构体 struct pglist_data: 节点的描述，arm64 UMA架构中，只有一个节点。 struct zone node_zone[]：是一个数组，每个元素表示一个内存区域所对应的 struct zone 结构体。从名字可以看出，此数组的长度为 MA"}, {"title": "内存初始化之物理内存初始化", "url": "内存初始化之物理内存初始化.html", "category": "01-linux", "summary": "恒等映射与内核镜像映射__create_page_tables preserve_boot_args：保持启动参数到boot_args[]数组 set_cpu_boot_maode_flag：设置关于cpu boot相关的全局变量 __create_page_tables：创建恒"}, {"title": "内存初始化之页表基本操作", "url": "内存初始化之页表基本操作.html", "category": "01-linux", "summary": "页表级数 如何确定page table level？确定了VABITS和PAGES size之后，页表级数也可确定，根据内核的配置如下： config PGTABLE_LEVELS int default 2 if ARM64_16K_PAGES && ARM64_VA_BITS"}, {"title": "内存初始化基本概念", "url": "内存初始化基本概念.html", "category": "01-linux", "summary": "三级结构Node、Zone、Page Node与内存架构UMA、NUMA UMA架构（uniform memory acces） 一致内存访问，所有CPU访问内存都需要过总线，距离都是一样的，所以每个处理器访问各个内存块都是同样快。如上图4个CPU都通过系统总线来访问物理内存DD"}, {"title": "文件系统缓存", "url": "文件系统缓存.html", "category": "01-linux", "summary": "#To free pagecache echo 1 > /proc/sys/vm/drop_caches #To free dentry and inode cache echo 2 > /proc/sys/vm/drop_caches #To free pagecache,de"}, {"title": "一切皆文件之块设备驱动（四）", "url": "一切皆文件之块设备驱动-四.html", "category": "01-linux", "summary": "实验环境 kernel version: linux 5.15 kernel module: simpleblk.ko 参考上一章节 application：app_test 参考上一章节 块设备无文件系统方式读写 写数据 存储设备没有格式化挂载文件系统，那么对磁盘设备的操作会经"}, {"title": "一切皆文件之块设备驱动（五）", "url": "一切皆文件之块设备驱动-五.html", "category": "01-linux", "summary": "实验环境 准备 kernel version: linux 5.15 kernel module: 块设备：simpleblk.ko 文件系统：simplefs.ko application： 制作文件系统：mkfs.simplefs 步骤 1.加载块设备驱动：insmod si"}, {"title": "一切皆文件之块设备驱动（二）", "url": "一切皆文件之块设备驱动-二.html", "category": "01-linux", "summary": "打开块设备 mknod 块设备同样要使用mknod创建设备节点，这与字符设备一样。会调用到init_special_inode填充inode的file_operations，只不过块设备注册的是def_blk_fops。 void init_special_inode(struc"}, {"title": "一切皆文件之块设备驱动（三）", "url": "一切皆文件之块设备驱动-三.html", "category": "01-linux", "summary": "块设备驱动示例 #include <linux/blk_types.h> #include <linux/blkdev.h> #include <linux/device.h> #include <linux/blk-mq.h> #include <linux/list.h> #"}, {"title": "内存管理概述", "url": "内存管理概述.html", "category": "01-linux", "summary": "地址空间 虚拟地址：程序使用的内存地址；物理地址：硬件的地址空间。虚拟地址通过MMU转化为物理地址，虚拟地址的长度与实际的物理内存容量没有关系，从系统中每个进程的角度看，地址空间的进程无法感知其他进程的存在。 32位cpu处理的地址空间为2^32=4G，所以虚拟地址空间为4G，分"}, {"title": "一切皆文件之块设备驱动（一）", "url": "一切皆文件之块设备驱动-一.html", "category": "01-linux", "summary": "块设备驱动简介 在linux系统中，有3大驱动类型，分别是：字符设备驱动、块设备驱动、网络设备驱动。块设备驱动与文件系统有着密不可分的关系，块设备是文件系统实际的数据传输单位，通常存储设备有eMMC，Nand/Nor flash，机械硬盘，固态硬盘等，这里所说的块设备驱动，实际就"}, {"title": "一切皆文件之字符设备", "url": "一切皆文件之字符设备.html", "category": "01-linux", "summary": "#include <linux/module.h> #include <linux/fs.h> #include <linux/uaccess.h> #define DEVICE_NAME \"mychardev\" #define BUFFER_SIZE 1024 static c"}, {"title": "文件系统常见系统调用", "url": "文件系统常见系统调用.html", "category": "01-linux", "summary": "上一章节中，我们编写了没有带磁盘设备的文件系统，了解了文件系统操作的大致流程，本章节我们继续在上一章节的基础上完善文件系统，并梳理从用户空间到内核空间大致的调用流程。实验的代码我们使用开源的示例https://github.com/sysprog21/simplefs/tree/"}, {"title": "实现简单文件系统", "url": "实现简单文件系统.html", "category": "01-linux", "summary": "文件系统注册与挂载 static struct file_system_type simplefs_fs_type = { .owner = THIS_MODULE, .name = \"simplefs\", .mount = simplefs_mount, .kill_sb = "}, {"title": "虚拟文件系统", "url": "虚拟文件系统.html", "category": "01-linux", "summary": "Linux系统中支持多种不同的文件系统，为了是用户可以通过一个文件系统操作界面，对各种不同的文件系统进行操作，在具体的文件系统（ext2/ext4等）之上增加了一层抽象一个统一的虚拟文件系统界面，向上提供归一化的文件操作，这个抽象层就称为虚拟文件系统。 为了实现抽象层，Linux"}, {"title": "文件系统磁盘管理", "url": "文件系统磁盘管理.html", "category": "01-linux", "summary": "磁盘空间布局 Extx将磁盘划分为等份的若干区域（最后一个区域可能会小一些），这些区域称为块组（block group）。磁盘以块组为单位进行管理。每个块组再划分为相同大小的block，这些block按功能分为原数据区和数据区。原数据区域也是占用block空间，但是是用于描述管理"}, {"title": "文件系统基本概念", "url": "文件系统基本概念.html", "category": "01-linux", "summary": "mount的机制是如何实现的？ inode是如何分配的。磁盘inode和内存inode有什么区别？ dentry缓存是怎么回事？如何管理？ free命令中Cache和buff有什么区别？Page cache了？如何管理文件数据缓存？ 扇区与簇 物理块和扇区，逻辑块和簇是相同概念。"}, {"title": "负载均衡之均衡", "url": "负载均衡之均衡.html", "category": "01-linux", "summary": "何时均衡 在linux内核中，有一些场景会触发任务均衡的分布在系统的各个cpu上，可以分为以下几个场景： 任务放置：task placement，fork创建的任务、sched_exec的任务或者阻塞被唤醒的任务，这些任务加入就绪队列时，可以确定放置任务到那个cpu上。 主动均衡"}, {"title": "负载均衡之调度组和调度域", "url": "负载均衡之调度组和调度域.html", "category": "01-linux", "summary": "概述 从上一章节大概应该能够理解负载和利用率的区别了，当一个进程正在运行或者即使没有在cpu上运行，而在就绪队列中等待运行，那么他依旧消耗cpu的负载。这是合理的，因为cpu的就绪队列有10个任务等待着运行与5个任务等待运行，明显是10个任务的负载重。而利用率只是关注正在运行的任"}, {"title": "负载均衡之负载跟踪", "url": "负载均衡之负载跟踪.html", "category": "01-linux", "summary": "各任务负载、各cpu的算力（频率+架构）、任务迁移开销（调度域，调度组）。 root@Linux:/# cat /proc/loadavg 3.49 3.43 3.54 4/131 3065 cat /proc/loadavg可以获取CPU全局平均负载，前面的三个值分别表示为1分"}, {"title": "CFS调度实现", "url": "cfs调度实现.html", "category": "01-linux", "summary": "时间计算 vruntime与runtime static void update_curr(struct cfs_rq *cfs_rq) { struct sched_entity *curr = cfs_rq->curr; u64 now = rq_clock_task(rq_"}, {"title": "CFS分组调度", "url": "cfs分组调度.html", "category": "01-linux", "summary": "Linux系统都是支持多用户登录，如果一个Linux系统两个用户存在不同的数量的进程，假设A用户有10个进程，B用户有20个进程，如果系统对这30个进程进行平分CPU，实际上是不公平的，因此引入了组调度的概念，即A用户对CPU的占用应该跟B用对CPU的占用各自为50%，A/B用户"}, {"title": "CFS调度原理", "url": "cfs调度原理.html", "category": "01-linux", "summary": "上一章节中描述了Linux系统中支持多种调度，不同的调度有不同的优先级范围。对于普通进程使用的CFS调度（Completely Fair Scheduler，CFS）。完全公平调度主要核心思想就是保证在一段时间内，每个进程能够运行的时间趋于相等。 为了尽可能的保证一段时间内，每个"}, {"title": "进程调度简介", "url": "进程调度简介.html", "category": "01-linux", "summary": "调度类别 进程调度依赖于调度策略（schedule policy），linux内核把相同的调度策略抽象成调度类（schedule class）。不同类型的进程采用不同的调度策略，目前Linux内核中默认采用5种调度类，分别是stop、deadline、realtime、CFS和i"}, {"title": "进程创建", "url": "进程创建.html", "category": "01-linux", "summary": "fork创建了一个新的进程，也就是fork执行后就会返回两次，分别是父进程返回和子进程返回。 exec可以加载新的程序运行（原程序是A，可以在A中运行后加载可执行程序B，B是A的子进程）。而如果没有exec，A程序执行fork后，仅只是将fork之后的代码复制了一份。exec最早"}, {"title": "markdown使用说明", "url": "markdown使用说明.html", "category": "10-其他", "summary": "首行缩进 `&ensp`; //半角的空格 `&emsp`; //全角的空格（中文的话，一般就直接用两个 即可） 着色 <span style=\"color:red;\">红色文字</span> <span style=\"color:blue;\">蓝色文字</span> <span"}, {"title": "进程基本概念", "url": "进程基本概念.html", "category": "01-linux", "summary": "进程标识 进程是程序加载到内存的执行过程。进程与程序相比用于操作系统的资源如内存空间、文件、signal等。对于进程的标识我们使用process id来标识（PID）。 线程是进程中活跃状态的实体，也是操作系统实际调度的基本单元。进程中的所有线程是共享一些资源的。在linux中，"}, {"title": "中断小结", "url": "中断小结.html", "category": "01-linux", "summary": "上下文 是否抢占 顶半部 中断 否 Softirq/tasklet 软中断 是 workqueue 进程 是 threaded_irq 进程 是 Tasklet：底半部，优先级比较高，处理函数中不能睡眠。 workqueue：底半部，处理函数可以睡眠，也可以执行比较长的应用。 t"}, {"title": "workqueue", "url": "workqueue.html", "category": "01-linux", "summary": "API接口 初始化 函数 说明 DECLARE_WORK(n, f) 静态定义一个work，实际就是定义一个struct work_struct的全局变量。 DECLARE_DELAYED_WORK(_work, _func) 静态定义一个work，与上面的区别就是work可以在"}, {"title": "软中断和tasklet", "url": "软中断和tasklet.html", "category": "01-linux", "summary": "Linux的中断分为上下部机制，上半部在中断上下文中关闭了本地CPU中断响应，下半部是在中断线程中处理。在Linux系统没有引入中断线程化机制之前，就已经出现了一些下半部的机制，如软中断SoftIRQ，Tasklet和workqueue。 SoftIRQ是预留给系统对时间要求比较"}, {"title": "wordpress使用笔记", "url": "wordpress使用笔记.html", "category": "10-其他", "summary": "使用WP Editor.md 粘贴的图片模糊 修改插件的图片质量 /usr/share/nginx/html/wordpress/wp-content/plugins/wp-editormd/src/App/ImagePaste.php 首页不显示全文章，只显示标题和部分内容 /"}, {"title": "Linux中断实现", "url": "linux中断实现.html", "category": "01-linux", "summary": "interrupt controller初始化 设备树中对gic-v3的描述如下，其中interrupt-controller标识了该设备是一个中断控制器。 interrupt-controller@3400000 { compatible = \"arm,gic-v3\"; #in"}, {"title": "Arm64体系结构简介", "url": "arm64体系结构简介.html", "category": "01-linux", "summary": "ARM简介 ARM版本 典型处理器 主要特性 v1 26位地址空间 v2 增加乘法、乘加法、支持协处理指令等 v3 地址空间扩展到32位，增加SPSP和CPSR等 v4 ARM7TDMI/ARM920T 增加Thumb指令等 v5 ARM926EJ-S 增加Jazelle和VFP"}, {"title": "中断基本概念", "url": "中断基本概念.html", "category": "01-linux", "summary": "在现代嵌入式系统中，处理器上会挂接很多个外设，CPU在执行任务的时候，可能会同时由多个中断发生，那么中断必要要进行响应处理并维护一个队列一一运行，这样自然会影响CPU的效率，为了让CPU专注于实际运算，中断控制器孕育而生，各中断信号源都先交给中断控制器处理，由中断控制器进行管理，"}];
const q = new URLSearchParams(location.search).get('q') || '';
const input = document.getElementById('q');
const list = document.getElementById('list');
input.value = q;
function render(keyword){
  const k = (keyword||'').trim().toLowerCase();
  const res = !k? data : data.filter(x => (x.title+x.summary+x.category).toLowerCase().includes(k));
  list.innerHTML = res.map(x => `<article class="post-item"><h2 class="post-title"><a href="${x.url}">${x.title}</a></h2><div class='meta'>${x.category}</div><p class='summary'>${x.summary}</p></article>`).join('');
}
render(q);
input.addEventListener('input', e => render(e.target.value));
    </script>
  </body>
</html>
