<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>分类：linux - Laumy的技术栈</title>
    <link rel="stylesheet" href="../assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card profile">
          <img class="avatar" src="../assets/avatar.jpg" alt="avatar" />
          <div class="author">laumy</div>
          <div class="bio">为学日益，为道日损</div>
          <div class="stats">
            <div><div class="num">160</div><div class="label">文章数</div></div>
            <div><div class="num">10</div><div class="label">分类</div></div>
          </div>
        </div>
                    
            <div class="card">
              <div class="card-title">分类专栏</div>
              <ul class="category-list">
                
                <li class="category-item has-subcategories">
                  <a href="../categories/linux.html" class="category-main">
                    <span class="category-name">linux</span>
                    <span class="subcategory-count">(48篇)</span>
                  </a>
                  
                  <ul class="subcategory-list">
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/性能工具.html">
                        <span class="subcategory-name">性能工具</span>
                        <span class="subcategory-count">(6篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/设备驱动.html">
                        <span class="subcategory-name">设备驱动</span>
                        <span class="subcategory-count">(5篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/内存管理.html">
                        <span class="subcategory-name">内存管理</span>
                        <span class="subcategory-count">(10篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/文件系统.html">
                        <span class="subcategory-name">文件系统</span>
                        <span class="subcategory-count">(12篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/进程调度.html">
                        <span class="subcategory-name">进程调度</span>
                        <span class="subcategory-count">(9篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/linux/中断管理.html">
                        <span class="subcategory-name">中断管理</span>
                        <span class="subcategory-count">(6篇)</span>
                      </a>
                    </li>
                    
                  </ul>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/risc-v.html" class="category-main">
                    <span class="category-name">risc-v</span>
                    <span class="subcategory-count">(25篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/rtos.html" class="category-main">
                    <span class="category-name">rtos</span>
                    <span class="subcategory-count">(4篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item has-subcategories">
                  <a href="../categories/ai.html" class="category-main">
                    <span class="category-name">ai</span>
                    <span class="subcategory-count">(41篇)</span>
                  </a>
                  
                  <ul class="subcategory-list">
                    
                    <li class="subcategory-item">
                      <a href="../categories/ai/ai应用.html">
                        <span class="subcategory-name">ai应用</span>
                        <span class="subcategory-count">(12篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/ai/算法.html">
                        <span class="subcategory-name">算法</span>
                        <span class="subcategory-count">(5篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/ai/lerobot.html">
                        <span class="subcategory-name">lerobot</span>
                        <span class="subcategory-count">(10篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/ai/深度学习.html">
                        <span class="subcategory-name">深度学习</span>
                        <span class="subcategory-count">(11篇)</span>
                      </a>
                    </li>
                    
                    <li class="subcategory-item">
                      <a href="../categories/ai/opencv.html">
                        <span class="subcategory-name">opencv</span>
                        <span class="subcategory-count">(3篇)</span>
                      </a>
                    </li>
                    
                  </ul>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/外设.html" class="category-main">
                    <span class="category-name">外设</span>
                    <span class="subcategory-count">(2篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/语言.html" class="category-main">
                    <span class="category-name">语言</span>
                    <span class="subcategory-count">(4篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/调试.html" class="category-main">
                    <span class="category-name">调试</span>
                    <span class="subcategory-count">(7篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/网络.html" class="category-main">
                    <span class="category-name">网络</span>
                    <span class="subcategory-count">(5篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/阅读.html" class="category-main">
                    <span class="category-name">阅读</span>
                    <span class="subcategory-count">(6篇)</span>
                  </a>
                  
                </li>
                
                <li class="category-item">
                  <a href="../categories/其他.html" class="category-main">
                    <span class="category-name">其他</span>
                    <span class="subcategory-count">(18篇)</span>
                  </a>
                  
                </li>
                
              </ul>
            </div>
            
        
      </aside>

      <section class="content">
        
<div class="card">
  <div class="card-title">分类：linux</div>
  <div class="post-list">
    
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_51abac8beee2dee0ca6db0c96bedf93c.jpg" alt="perf工具使用" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../perf工具使用.html">perf工具使用</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2025-05-14
            </span>
          </div>
          <p class="summary">perf介绍 perf 是一个强大的 Linux 性能分析工具，广泛用于分析程序的性能瓶颈，帮助开发者进行调优。perf 工具能够收集并分析多种硬件和软件事件，包括 CPU 的指令执行、缓存命中与失误、上下文切换等。 硬件事件驱：通过访问 CPU 的 PMU（性能监控单元）捕获硬</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4633_1.jpeg" alt="拍照示例代码分析" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../拍照示例代码分析.html">拍照示例代码分析</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-11-17
            </span>
          </div>
          <p class="summary">数据结构 待补充 初始化启动 启动MPP系统 MPP_SYS_CONF_S mSysConf; memset(&amp;mSysConf, 0, sizeof(MPP_SYS_CONF_S)); mSysConf.nAlignWidth = 32; AW_MPI_SYS_SetConf(</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4509-scaled.jpg" alt="RTSP视频传输示例代码分析" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../rtsp视频传输示例代码分析.html">RTSP视频传输示例代码分析</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-11-17
            </span>
          </div>
          <p class="summary">数据流通路： CSI -&gt; ISP -&gt; VIPP -&gt; VirChn -&gt; VENC CSI：表示物理 Camera Signal Input Pasrse Device 的接口。CSI 可以选择连接任意一个 ISP。最多支持 3 个 CSI。 ISP：表示物理 ISP。ISP</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4633_1.jpeg" alt="移动检测代码示例分析" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../移动检测代码示例分析.html">移动检测代码示例分析</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-11-17
            </span>
          </div>
          <p class="summary">数据结构 VencMotionSearchParam typedef struct { int en_motion_search; // 移动侦测功能使能开关，1：开，0：关。 int dis_default_para; // 是否禁用默认参数，1：使用用户自定义参数，0：使用默</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4633_1.jpeg" alt="视频编码示例" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../视频编码示例.html">视频编码示例</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-09-05
            </span>
          </div>
          <p class="summary">通路：CSI &gt; ISP &gt; VIPP &gt; VirChn &gt; VENC。 CSI：表示物理 Camera Signal Input Pasrse Device 的接口。CSI 可以选择连接任意一个 ISP。最多支持 3 个 CSI。 ISP：表示物理 ISP。ISP 可以选择连接</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4509-scaled.jpg" alt="function graph tracer原理" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../function-graph-tracer原理.html">function graph tracer原理</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-31
            </span>
          </div>
          <p class="summary">概述 Function graph相对function trace的不同点是，在函数入口会trace，在函数出口也会trace。 ksys_read -&gt;vfs_read -&gt;ftrace_caller -&gt;prepare_ftrace_return -&gt;function_gra</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_26e12f1b4882155d60c3b04b7e5ebe1d.jpg" alt="Camera基础知识" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../camera基础知识.html">Camera基础知识</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-29
            </span>
          </div>
          <p class="summary">框架可以分为kernle层、Video input framework、Device Driver层 V4L2与Media device Framework V4L2 Framework： 是video for Linux Two的简称。是Linux标准通用基础视频框架，向下屏蔽</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_0490cf5c14d6626155560b593b74cd17.jpg" alt="静态ftrace" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../静态ftrace.html">静态ftrace</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-28
            </span>
          </div>
          <p class="summary">上面章节主要描述的是动态ftrace，在早期还有静态ftrace。区别主要如下： - 动态ftrace与静态ftrace在编译参数方面静态编译使用的是参数“-pg”，而动态使用的是fpatchable-function-entry。 - 工具链使能“-pg”参数时，会在每个函数体</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4509-scaled.jpg" alt="动态function tracer原理" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../动态function-tracer原理.html">动态function tracer原理</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-28
            </span>
          </div>
          <p class="summary">fpatchable-function-entry选项 编译时指定-fpatchable-function-entry=N[,M]，①会在函数入口第一个指令之前插入N个nop，但是会保留M个放到函数入口之前，如果省略M则默认为0；②同时需要一个特殊的-fpatchable-fun</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_1bb420627685200b9cfc21e886ecadcc.jpg" alt="ftrace-概述" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../ftrace-概述.html">ftrace-概述</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-27
            </span>
          </div>
          <p class="summary">ftrace是一个内部跟踪器，用于帮助开发人员查找内核正在发生的事情，它可用于调试或分析用户空间之外发生的延迟和性能问题。ftrace从名称上看是function trace，函数跟踪器，但它实际并不限制函数跟踪，而是多个不同跟踪实用程序的框架。延迟跟踪可以检查在禁用和启用中断之</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_3b7340fb5fcf13be7e879fb3db8587bf.jpg" alt="ftrace的使用" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../ftrace的使用.html">ftrace的使用</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2024-08-27
            </span>
          </div>
          <p class="summary">tracer irqsoff 当关闭中断时，CPU就无法响应中断了（NMI和SMI除外），无法响应外部事件做出反应。这会阻止定时器触发或鼠标中断触发，导致系统延迟。 irqsoff跟踪器跟踪中断被禁用的时间，当达到新的最大延迟时，跟踪器会保存导致该延迟点的跟踪，一边每次达到新的最</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_e4093f7be650c02635a1db87f9cb821f.jpg" alt="内存测量" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../内存测量.html">内存测量</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-08-27
            </span>
          </div>
          <p class="summary">系统占用内存 free 旧版本free $ free total used free shared buffers cached Mem: 65960636 63933576 2027060 73392 1602076 32628548 -/+ buffers/cache: 29</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_084108bffd6a37851ac96f61c55c3863.jpg" alt="进程虚拟内存" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../进程虚拟内存.html">进程虚拟内存</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-08-26
            </span>
          </div>
          <p class="summary">进程虚拟地址空间 Executable and Linkable Format（ELF） 上图是可执行文件的内容结构图，由ELF header、program headers、各section、sections headers组成。 - ELF header：描述整个文件的基本属</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_44b39971f1e5ad8a531008c14799ad49.jpg" alt="DMA与cache一致性" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../dma与cache一致性.html">DMA与cache一致性</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-08-20
            </span>
          </div>
          <p class="summary">无DMA时：设备与内存之间数据搬运需要依靠CPU来完成。 有DMA时：DMA可以直接完成设备与内存直接的数据搬运，不需要cpu介入。 DMA的引入，优点是数据在内存和设备之间的搬运不需要CPU参与，这极大降低了CPU的负荷。但是也引入了新的问题，即cpu读取到的数据不一定是最新的</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_534a275819ad65dd5978c0d341381b29.jpg" alt="连续内存分配器CMA" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../连续内存分配器cma.html">连续内存分配器CMA</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-08-19
            </span>
          </div>
          <p class="summary">CMA,contiguous memory allocator是内存管理子系统的一个模块，其主要为了解决分配连续的物理内存。尽管有了伙伴系统、slab分配器以及相关的内存回收机制，但是对于一些驱动如camera、display等模块一下需要分配比较大的一块连续物理内存，随着系统运</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_b83b6edbd01e56ece49cfe743e233112.jpg" alt="slub分配器" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../slub分配器.html">slub分配器</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-08-13
            </span>
          </div>
          <p class="summary">伙伴系统内存分配是以物理页面4KB为单位，但是实际使用的时候不会一下使用到4KB。实际使用中很多情况会以字节为单位。因此为了更精确的划分使用内存，linux内核在伙伴系统之上使用slab分配器来进行管理。截止目前linux内核中从最初slab发展到现在，衍生了slub，slob三</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_145e1dfab349c93979e3382e570502f5.jpg" alt="伙伴系统" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../伙伴系统.html">伙伴系统</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-07-22
            </span>
          </div>
          <p class="summary">相关结构体 核心结构体 struct pglist_data: 节点的描述，arm64 UMA架构中，只有一个节点。 struct zone node_zone[]：是一个数组，每个元素表示一个内存区域所对应的 struct zone 结构体。从名字可以看出，此数组的长度为 MA</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_0799025c3a2daf03a2a31ced36b88d37.jpg" alt="内存初始化之物理内存初始化" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../内存初始化之物理内存初始化.html">内存初始化之物理内存初始化</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-07-01
            </span>
          </div>
          <p class="summary">恒等映射与内核镜像映射__create_page_tables preserve_boot_args：保持启动参数到boot_args[]数组 set_cpu_boot_maode_flag：设置关于cpu boot相关的全局变量 __create_page_tables：创建恒</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_3be74c3ec0d0102af9dd1b1a1fd91fd7.jpg" alt="内存初始化之页表基本操作" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../内存初始化之页表基本操作.html">内存初始化之页表基本操作</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-18
            </span>
          </div>
          <p class="summary">页表级数 如何确定page table level？确定了VABITS和PAGES size之后，页表级数也可确定，根据内核的配置如下： config PGTABLE_LEVELS int default 2 if ARM64_16K_PAGES &amp;&amp; ARM64_VA_BITS</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_6d2fb92edac71f0ea5c3246ddc3268c6.jpg" alt="内存初始化基本概念" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../内存初始化基本概念.html">内存初始化基本概念</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-10
            </span>
          </div>
          <p class="summary">三级结构Node、Zone、Page Node与内存架构UMA、NUMA UMA架构（uniform memory acces） 一致内存访问，所有CPU访问内存都需要过总线，距离都是一样的，所以每个处理器访问各个内存块都是同样快。如上图4个CPU都通过系统总线来访问物理内存DD</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_4563d1adba322baf728d76cc5d1408c9.jpg" alt="文件系统缓存" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../文件系统缓存.html">文件系统缓存</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-05
            </span>
          </div>
          <p class="summary">#To free pagecache echo 1 &gt; /proc/sys/vm/drop_caches #To free dentry and inode cache echo 2 &gt; /proc/sys/vm/drop_caches #To free pagecache,de</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_c69fe5fb31aa6d753d775db469da9896.jpg" alt="一切皆文件之块设备驱动（四）" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之块设备驱动-四.html">一切皆文件之块设备驱动（四）</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-04
            </span>
          </div>
          <p class="summary">实验环境 kernel version: linux 5.15 kernel module: simpleblk.ko 参考上一章节 application：app_test 参考上一章节 块设备无文件系统方式读写 写数据 存储设备没有格式化挂载文件系统，那么对磁盘设备的操作会经</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_2f196a7cbc45e506672b1e90458d7272.jpg" alt="一切皆文件之块设备驱动（五）" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之块设备驱动-五.html">一切皆文件之块设备驱动（五）</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-04
            </span>
          </div>
          <p class="summary">实验环境 准备 kernel version: linux 5.15 kernel module: 块设备：simpleblk.ko 文件系统：simplefs.ko application： 制作文件系统：mkfs.simplefs 步骤 1.加载块设备驱动：insmod si</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_8cb0c52c358ef8ad24b7aef183457582.jpg" alt="一切皆文件之块设备驱动（二）" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之块设备驱动-二.html">一切皆文件之块设备驱动（二）</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-04
            </span>
          </div>
          <p class="summary">打开块设备 mknod 块设备同样要使用mknod创建设备节点，这与字符设备一样。会调用到init_special_inode填充inode的file_operations，只不过块设备注册的是def_blk_fops。 void init_special_inode(struc</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_3b39892a88b0e1977741fd577a769fa7.jpg" alt="一切皆文件之块设备驱动（三）" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之块设备驱动-三.html">一切皆文件之块设备驱动（三）</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-04
            </span>
          </div>
          <p class="summary">块设备驱动示例 #include &lt;linux/blk_types.h&gt; #include &lt;linux/blkdev.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/blk-mq.h&gt; #include &lt;linux/list.h&gt; #</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_cb7636562b9588e0d3070794adffec4e.jpg" alt="内存管理概述" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../内存管理概述.html">内存管理概述</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-04
            </span>
          </div>
          <p class="summary">地址空间 虚拟地址：程序使用的内存地址；物理地址：硬件的地址空间。虚拟地址通过MMU转化为物理地址，虚拟地址的长度与实际的物理内存容量没有关系，从系统中每个进程的角度看，地址空间的进程无法感知其他进程的存在。 32位cpu处理的地址空间为2^32=4G，所以虚拟地址空间为4G，分</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_6e9f2cd13fec0f8325a29151ea196e01.jpg" alt="一切皆文件之块设备驱动（一）" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之块设备驱动-一.html">一切皆文件之块设备驱动（一）</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-06-03
            </span>
          </div>
          <p class="summary">块设备驱动简介 在linux系统中，有3大驱动类型，分别是：字符设备驱动、块设备驱动、网络设备驱动。块设备驱动与文件系统有着密不可分的关系，块设备是文件系统实际的数据传输单位，通常存储设备有eMMC，Nand/Nor flash，机械硬盘，固态硬盘等，这里所说的块设备驱动，实际就</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_85ad14b1958abe5e4e1bdba751564b82.jpg" alt="一切皆文件之字符设备" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../一切皆文件之字符设备.html">一切皆文件之字符设备</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-28
            </span>
          </div>
          <p class="summary">#include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #define DEVICE_NAME &#34;mychardev&#34; #define BUFFER_SIZE 1024 static c</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_ab0e4b315b4839d6ff4e073fd3791a6a.jpg" alt="文件系统常见系统调用" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../文件系统常见系统调用.html">文件系统常见系统调用</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-27
            </span>
          </div>
          <p class="summary">上一章节中，我们编写了没有带磁盘设备的文件系统，了解了文件系统操作的大致流程，本章节我们继续在上一章节的基础上完善文件系统，并梳理从用户空间到内核空间大致的调用流程。实验的代码我们使用开源的示例https://github.com/sysprog21/simplefs/tree/</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_cf158055b8de4a26b4af450e53c5adfa.jpg" alt="实现简单文件系统" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../实现简单文件系统.html">实现简单文件系统</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-21
            </span>
          </div>
          <p class="summary">文件系统注册与挂载 static struct file_system_type simplefs_fs_type = { .owner = THIS_MODULE, .name = &#34;simplefs&#34;, .mount = simplefs_mount, .kill_sb = </p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_8268464056e615fff2c2c6028c3bf923.jpg" alt="虚拟文件系统" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../虚拟文件系统.html">虚拟文件系统</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-20
            </span>
          </div>
          <p class="summary">Linux系统中支持多种不同的文件系统，为了是用户可以通过一个文件系统操作界面，对各种不同的文件系统进行操作，在具体的文件系统（ext2/ext4等）之上增加了一层抽象一个统一的虚拟文件系统界面，向上提供归一化的文件操作，这个抽象层就称为虚拟文件系统。 为了实现抽象层，Linux</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_3094f9387032029d6524d9d20fe0a6ca.jpg" alt="文件系统磁盘管理" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../文件系统磁盘管理.html">文件系统磁盘管理</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-14
            </span>
          </div>
          <p class="summary">磁盘空间布局 Extx将磁盘划分为等份的若干区域（最后一个区域可能会小一些），这些区域称为块组（block group）。磁盘以块组为单位进行管理。每个块组再划分为相同大小的block，这些block按功能分为原数据区和数据区。原数据区域也是占用block空间，但是是用于描述管理</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_a2aa4567ad1f5c58340fe7fbb6b16f0d.jpg" alt="文件系统基本概念" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../文件系统基本概念.html">文件系统基本概念</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-05-13
            </span>
          </div>
          <p class="summary">mount的机制是如何实现的？ inode是如何分配的。磁盘inode和内存inode有什么区别？ dentry缓存是怎么回事？如何管理？ free命令中Cache和buff有什么区别？Page cache了？如何管理文件数据缓存？ 扇区与簇 物理块和扇区，逻辑块和簇是相同概念。</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_a5dc98e9783e5cd283b2fd0214c642df.jpg" alt="负载均衡之均衡" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../负载均衡之均衡.html">负载均衡之均衡</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-04-22
            </span>
          </div>
          <p class="summary">何时均衡 在linux内核中，有一些场景会触发任务均衡的分布在系统的各个cpu上，可以分为以下几个场景： 任务放置：task placement，fork创建的任务、sched_exec的任务或者阻塞被唤醒的任务，这些任务加入就绪队列时，可以确定放置任务到那个cpu上。 主动均衡</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_7899f9010271eec5a7d023fca4dd488b.jpg" alt="负载均衡之调度组和调度域" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../负载均衡之调度组和调度域.html">负载均衡之调度组和调度域</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-04-16
            </span>
          </div>
          <p class="summary">概述 从上一章节大概应该能够理解负载和利用率的区别了，当一个进程正在运行或者即使没有在cpu上运行，而在就绪队列中等待运行，那么他依旧消耗cpu的负载。这是合理的，因为cpu的就绪队列有10个任务等待着运行与5个任务等待运行，明显是10个任务的负载重。而利用率只是关注正在运行的任</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_b725ab47056127971680f54b86cc9316.jpg" alt="负载均衡之负载跟踪" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../负载均衡之负载跟踪.html">负载均衡之负载跟踪</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-04-08
            </span>
          </div>
          <p class="summary">各任务负载、各cpu的算力（频率+架构）、任务迁移开销（调度域，调度组）。 root@Linux:/# cat /proc/loadavg 3.49 3.43 3.54 4/131 3065 cat /proc/loadavg可以获取CPU全局平均负载，前面的三个值分别表示为1分</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_8394a28d228bf21f49758af95b477365.jpg" alt="CFS调度实现" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../cfs调度实现.html">CFS调度实现</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-04-02
            </span>
          </div>
          <p class="summary">时间计算 vruntime与runtime static void update_curr(struct cfs_rq *cfs_rq) { struct sched_entity *curr = cfs_rq-&gt;curr; u64 now = rq_clock_task(rq_</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_f1872becbdd34723c385b1b47f19f12e.jpg" alt="CFS分组调度" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../cfs分组调度.html">CFS分组调度</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-04-01
            </span>
          </div>
          <p class="summary">Linux系统都是支持多用户登录，如果一个Linux系统两个用户存在不同的数量的进程，假设A用户有10个进程，B用户有20个进程，如果系统对这30个进程进行平分CPU，实际上是不公平的，因此引入了组调度的概念，即A用户对CPU的占用应该跟B用对CPU的占用各自为50%，A/B用户</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_f1e8108aa95e9b00d7f2e69657da380a.jpg" alt="CFS调度原理" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../cfs调度原理.html">CFS调度原理</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-26
            </span>
          </div>
          <p class="summary">上一章节中描述了Linux系统中支持多种调度，不同的调度有不同的优先级范围。对于普通进程使用的CFS调度（Completely Fair Scheduler，CFS）。完全公平调度主要核心思想就是保证在一段时间内，每个进程能够运行的时间趋于相等。 为了尽可能的保证一段时间内，每个</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_e03f85a17bb9caf7edeb3c67b198c1a2.jpg" alt="进程调度简介" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../进程调度简介.html">进程调度简介</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-25
            </span>
          </div>
          <p class="summary">调度类别 进程调度依赖于调度策略（schedule policy），linux内核把相同的调度策略抽象成调度类（schedule class）。不同类型的进程采用不同的调度策略，目前Linux内核中默认采用5种调度类，分别是stop、deadline、realtime、CFS和i</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_8eb9f02bb6ced6af4038bd27cef6a33d.jpg" alt="进程创建" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../进程创建.html">进程创建</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-19
            </span>
          </div>
          <p class="summary">fork创建了一个新的进程，也就是fork执行后就会返回两次，分别是父进程返回和子进程返回。 exec可以加载新的程序运行（原程序是A，可以在A中运行后加载可执行程序B，B是A的子进程）。而如果没有exec，A程序执行fork后，仅只是将fork之后的代码复制了一份。exec最早</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_db7d532557f8e79e8a7b296e3fb1629d.jpg" alt="进程基本概念" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../进程基本概念.html">进程基本概念</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-12
            </span>
          </div>
          <p class="summary">进程标识 进程是程序加载到内存的执行过程。进程与程序相比用于操作系统的资源如内存空间、文件、signal等。对于进程的标识我们使用process id来标识（PID）。 线程是进程中活跃状态的实体，也是操作系统实际调度的基本单元。进程中的所有线程是共享一些资源的。在linux中，</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_ab2e4fe23e14c02bb29a7f1f4c2374bf.jpg" alt="中断小结" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../中断小结.html">中断小结</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-11
            </span>
          </div>
          <p class="summary">上下文 是否抢占 顶半部 中断 否 Softirq/tasklet 软中断 是 workqueue 进程 是 threaded_irq 进程 是 Tasklet：底半部，优先级比较高，处理函数中不能睡眠。 workqueue：底半部，处理函数可以睡眠，也可以执行比较长的应用。 t</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/IMG_4633_1.jpeg" alt="workqueue" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../workqueue.html">workqueue</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-05
            </span>
          </div>
          <p class="summary">API接口 初始化 函数 说明 DECLARE_WORK(n, f) 静态定义一个work，实际就是定义一个struct work_struct的全局变量。 DECLARE_DELAYED_WORK(_work, _func) 静态定义一个work，与上面的区别就是work可以在</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_3b15bb3b2af9aa854ff5a2d097d230e5.jpg" alt="软中断和tasklet" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../软中断和tasklet.html">软中断和tasklet</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-05
            </span>
          </div>
          <p class="summary">Linux的中断分为上下部机制，上半部在中断上下文中关闭了本地CPU中断响应，下半部是在中断线程中处理。在Linux系统没有引入中断线程化机制之前，就已经出现了一些下半部的机制，如软中断SoftIRQ，Tasklet和workqueue。 SoftIRQ是预留给系统对时间要求比较</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_55593fd38b57f7196ae93cc4bf046b15.jpg" alt="Linux中断实现" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../linux中断实现.html">Linux中断实现</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-04
            </span>
          </div>
          <p class="summary">interrupt controller初始化 设备树中对gic-v3的描述如下，其中interrupt-controller标识了该设备是一个中断控制器。 interrupt-controller@3400000 { compatible = &#34;arm,gic-v3&#34;; #in</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_300bd876e354afece405179950027a19.jpg" alt="Arm64体系结构简介" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../arm64体系结构简介.html">Arm64体系结构简介</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-04
            </span>
          </div>
          <p class="summary">ARM简介 ARM版本 典型处理器 主要特性 v1 26位地址空间 v2 增加乘法、乘加法、支持协处理指令等 v3 地址空间扩展到32位，增加SPSP和CPSR等 v4 ARM7TDMI/ARM920T 增加Thumb指令等 v5 ARM926EJ-S 增加Jazelle和VFP</p>
        </div>
      </div>
    </article>
    
    <article class="post-item">
      <div class="latest-post-content">
        
        <div class="post-image">
          <img src="../assets/thumbs/wp_editor_md_bd1e88299326e42a275b6466b0fa2bbb.jpg" alt="中断基本概念" />
        </div>
        
        <div class="post-text">
          <h2 class="post-title"><a href="../中断基本概念.html">中断基本概念</a></h2>
          <div class="meta">
            <span class="meta-item">
              <i class="icon">🕒</i>
              2023-03-04
            </span>
          </div>
          <p class="summary">在现代嵌入式系统中，处理器上会挂接很多个外设，CPU在执行任务的时候，可能会同时由多个中断发生，那么中断必要要进行响应处理并维护一个队列一一运行，这样自然会影响CPU的效率，为了让CPU专注于实际运算，中断控制器孕育而生，各中断信号源都先交给中断控制器处理，由中断控制器进行管理，</p>
        </div>
      </div>
    </article>
    
    
  </div>
 </div>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../assets/site.js"></script>
  </body>
  </html>

