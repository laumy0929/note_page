<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>异常初始化 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">异常处理概述</a><ul></ul></li><li><a href="#_2">异常入口</a><ul></ul></li><li><a href="#_3">异常软件处理流程</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>异常初始化</h1>
  <div class="meta">2024-07-07 · risc-v</div>
  <div class="post-content"><h2 id="_1">异常处理概述</h2>
<p>略</p>
<h2 id="_2">异常入口</h2>
<div class="codehilite"><pre><span></span><code><span class="n">start_kernel</span>
<span class="w">  </span><span class="nf">trap_init</span><span class="p">();</span>

<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Set sup0 scratch register to 0, indicating to exception vector</span>
<span class="cm">     * that we are presently executing in the kernel</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">csr_write</span><span class="p">(</span><span class="n">CSR_SSCRATCH</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Set the exception vector address */</span>
<span class="w">    </span><span class="n">csr_write</span><span class="p">(</span><span class="n">CSR_STVEC</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle_exception</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Enable all interrupts */</span>
<span class="n">csr_write</span><span class="p">(</span><span class="n">CSR_SIE</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="n">设置trap的入口函数为handle_exception</span><span class="err">。</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_3">异常软件处理流程</h2>
<div class="codehilite"><pre><span></span><code><span class="n">ENTRY</span><span class="p">(</span><span class="n">handle_exception</span><span class="p">)</span>
<span class="w">    </span><span class="n">SAVE_ALL</span>
<span class="w">    </span><span class="n">①</span><span class="w"> </span><span class="n">保存上下文</span><span class="err">，</span><span class="n">主要是一些寄存器</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Set sscratch register to 0, so that if a recursive exception</span>
<span class="cm">     * occurs, the exception vector knows it came from the kernel</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">csrw</span><span class="w"> </span><span class="n">CSR_SSCRATCH</span><span class="p">,</span><span class="w"> </span><span class="n">x0</span>
<span class="w">    </span><span class="n">②清空临时寄存器scratch</span>
<span class="w">    </span><span class="cm">/* Load the global pointer */</span>
<span class="p">.</span><span class="n">option</span><span class="w"> </span><span class="n">push</span>
<span class="p">.</span><span class="n">option</span><span class="w"> </span><span class="n">norelax</span>
<span class="w">    </span><span class="n">la</span><span class="w"> </span><span class="n">gp</span><span class="p">,</span><span class="w"> </span><span class="n">__global_pointer$</span>
<span class="p">.</span><span class="n">option</span><span class="w"> </span><span class="n">pop</span>

<span class="n">la</span><span class="w"> </span><span class="n">ra</span><span class="p">,</span><span class="w"> </span><span class="n">ret_from_exception</span>
<span class="n">③</span><span class="w"> </span><span class="n">设置异常返回</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * MSB of cause differentiates between</span>
<span class="cm">     * interrupts and exceptions</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">bge</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="mf">1f</span>

<span class="w">    </span><span class="cm">/* Handle interrupts */</span>
<span class="w">    </span><span class="n">move</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="cm">/* pt_regs */</span>
<span class="n">tail</span><span class="w"> </span><span class="n">do_IRQ</span>
<span class="n">④s4里面保存的是scause的值</span><span class="err">，</span><span class="n">通过最高位判断是中断还是异常</span><span class="err">，</span><span class="n">中断调用do_IRQ</span><span class="err">，</span><span class="n">异常的就接着往下运行</span><span class="err">。</span><span class="n">关于do_IRQ的处理待后续中断处理流程单独分析</span><span class="err">。</span>
<span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/* Exceptions run with interrupts enabled or disabled</span>
<span class="cm">       depending on the state of sstatus.SR_SPIE */</span>
<span class="w">    </span><span class="n">andi</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">SR_SPIE</span>
<span class="w">    </span><span class="n">beqz</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="mf">1f</span>
<span class="w">    </span><span class="n">csrs</span><span class="w"> </span><span class="n">CSR_SSTATUS</span><span class="p">,</span><span class="w"> </span><span class="n">SR_SIE</span>
<span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/* Handle syscalls */</span>
<span class="w">    </span><span class="n">li</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">EXC_SYSCALL</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">handle_syscall</span>
<span class="w">    </span><span class="n">④</span><span class="w"> </span><span class="n">异常类型是系统调用</span><span class="err">，</span><span class="n">则跳转handle_syscall</span>
<span class="w">    </span><span class="cm">/* Handle other exceptions */</span>
<span class="w">    </span><span class="n">slli</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">RISCV_LGPTR</span>
<span class="w">    </span><span class="n">la</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">excp_vect_table</span>
<span class="w">    </span><span class="n">la</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">excp_vect_table_end</span>
<span class="w">    </span><span class="n">move</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="cm">/* pt_regs */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span>
<span class="w">    </span><span class="cm">/* Check if exception code lies within bounds */</span>
<span class="w">    </span><span class="n">bgeu</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mf">1f</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="n">jr</span><span class="w"> </span><span class="n">t0</span>
<span class="n">⑤如果不是系统调用</span><span class="err">，</span><span class="n">处理其他类型异常</span><span class="err">，</span><span class="n">根据excp_vect_table进行跳转</span><span class="err">，</span><span class="n">如do_page_fault</span>
<span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">tail</span><span class="w"> </span><span class="n">do_trap_unknown</span>
<span class="w">    </span><span class="n">⑥如果从excp_vect_table都未查询到对应的异常</span><span class="err">，</span><span class="n">进行单独处理</span><span class="err">。</span>
<span class="nl">handle_syscall</span><span class="p">:</span>
<span class="w">     </span><span class="cm">/* save the initial A0 value (needed in signal handlers) */</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">PT_ORIG_A0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Advance SEPC to avoid executing the original</span>
<span class="cm">     * scall instruction on sret</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">addi</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x4</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">PT_SEPC</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w">    </span><span class="cm">/* Trace syscalls, but only if requested by the user. */</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_TI_FLAGS</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">andi</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_TIF_SYSCALL_WORK</span>
<span class="w">    </span><span class="n">bnez</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">handle_syscall_trace_enter</span>
<span class="nl">check_syscall_nr</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Check to make sure we don't jump to a bogus syscall number. */</span>
<span class="w">    </span><span class="n">li</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">__NR_syscalls</span>
<span class="w">    </span><span class="n">la</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">sys_ni_syscall</span>
<span class="w">    </span><span class="cm">/* Syscall number held in a7 */</span>
<span class="w">    </span><span class="n">bgeu</span><span class="w"> </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="mf">1f</span>
<span class="w">    </span><span class="n">la</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">sys_call_table</span>
<span class="w">    </span><span class="n">slli</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="n">RISCV_LGPTR</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
<span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">jalr</span><span class="w"> </span><span class="n">s0</span>
<span class="nl">ret_from_syscall</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Set user a0 to kernel a0 */</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">PT_A0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w">    </span><span class="cm">/* Trace syscalls, but only if requested by the user. */</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_TI_FLAGS</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">andi</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_TIF_SYSCALL_WORK</span>
<span class="w">    </span><span class="n">bnez</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">handle_syscall_trace_exit</span>
<span class="w">    </span><span class="n">⑦上面是系统调用的异常处理</span><span class="err">，</span><span class="n">后续再单独分析</span><span class="err">。</span>
<span class="nl">ret_from_exception</span><span class="p">:</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">PT_SSTATUS</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w">    </span><span class="n">csrc</span><span class="w"> </span><span class="n">CSR_SSTATUS</span><span class="p">,</span><span class="w"> </span><span class="n">SR_SIE</span>
<span class="w">    </span><span class="n">andi</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">SR_SPP</span>
<span class="w">    </span><span class="n">bnez</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">resume_kernel</span>
<span class="w">    </span><span class="n">⑧从异常中返回</span><span class="err">，</span><span class="n">根据sstatus中SPP的位来判断是内核陷入的异常还是用户陷入的异常</span><span class="err">，</span><span class="mi">0</span><span class="n">是用户陷入的异常</span><span class="err">，</span><span class="n">跳转执行resume_userspace</span><span class="err">，</span><span class="mi">1</span><span class="n">是内核陷入的异常</span><span class="err">，</span><span class="n">跳转执行resume_kernel</span><span class="err">。</span><span class="n">sstatus</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="n">是SPP位</span><span class="err">，</span><span class="n">保存的是陷入异常前是U模式还是S模式</span><span class="err">，</span><span class="n">如果是U模式代表是用户态</span><span class="err">，</span><span class="n">如果是S模式代表是内核态</span><span class="err">。</span>
<span class="nl">resume_userspace</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Interrupts must be disabled here so flags are checked atomically */</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_TI_FLAGS</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span><span class="w"> </span><span class="cm">/* current_thread_info-&gt;flags */</span>
<span class="w">    </span><span class="n">andi</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">_TIF_WORK_MASK</span>
<span class="w">    </span><span class="n">bnez</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">work_pending</span>

<span class="w">    </span><span class="cm">/* Save unwound kernel stack pointer in thread_info */</span>
<span class="w">    </span><span class="n">addi</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">PT_SIZE_ON_STACK</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">TASK_TI_KERNEL_SP</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Save TP into sscratch, so we can find the kernel data structures</span>
<span class="cm">     * again.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">csrw</span><span class="w"> </span><span class="n">CSR_SSCRATCH</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span>
<span class="w">    </span><span class="n">⑨</span><span class="w"> </span><span class="n">恢复用户态的tp</span><span class="err">，</span><span class="n">线程指针</span><span class="err">，</span><span class="n">待到后续进程调度时再详细分析</span><span class="err">。</span>
<span class="nl">restore_all</span><span class="p">:</span>
<span class="w">    </span><span class="n">RESTORE_ALL</span>
<span class="n">sret</span>
<span class="n">⑩</span><span class="w"> </span><span class="n">恢复上下文</span><span class="err">，</span><span class="n">执行sret返回</span><span class="err">。</span>
</code></pre></div>
<p>arch/riscv/kernel/entry.S是关于risc-v trap入口的实现，trap的包含异常和中断。trap的中总入口为handle_exception，主要处理一下事项。 - 保存上下文，主要是将一些寄存器压入栈中。 - 根据scause寄存器判断是异常还是中断，如果是中断跳转到do_IRQ运行，如果是异常根据异常的cause进分发处理。 - 异常中有一类是系统调用，根据scause查询如果是系统调用根据sys_call_table[]跳转处理。 - 异常如果不是系统调用，就是程序运行中出现的异常，根据scause查询excp_vect_table[]跳转处理。 - 异常和中断都处理完成之后，最终回到ret_from_exception，这里会根据sstatus的SSP位来判断是用户态陷入的还是内核态陷入，根据内核和用户态的更新tp。 - 最后调用RESTORE_ALL恢复上下文，退出trap。</p></div>
  <div class="post-nav">
    <a class="prev" href="/虚拟地址空间与物理地址空间完整映射.html">← 虚拟地址空间与物理地址空间完整映射</a>
    <a class="next" href="/挂载根文件系统.html">挂载根文件系统 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/assets/site.js"></script>
  </body>
  </html>

