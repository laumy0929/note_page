<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>lerobot录制 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">简介</a><ul></ul></li><li><a href="#_2">关键配置类</a><ul><li><a href="#recordconfig">RecordConfig</a></li><li><a href="#robotconfig">RobotConfig</a></li><li><a href="#datasetrecordconfig">DatasetRecordConfig</a></li><li><a href="#teleoperatorconfig">TeleoperatorConfig</a></li><li><a href="#pretrainedconfig">PreTrainedConfig</a></li></ul></li><li><a href="#_3">参数解析</a><ul></ul></li><li><a href="#_4">硬件初始化与连接</a><ul></ul></li><li><a href="#_5">数据集创建</a><ul><li><a href="#_6">数据特征定义</a></li><li><a href="#_9">创建数据集</a></li><li><a href="#_10">加载数据集</a></li></ul></li><li><a href="#_11">录制流程</a><ul></ul></li><li><a href="#_12">录制循环</a><ul><li><a href="#_13">初始化与参数校验</a></li><li><a href="#_14">主循环控制与数据采集</a></li></ul></li><li><a href="#_15">数据存储</a><ul><li><a href="#_16">写入缓存</a></li><li><a href="#_17">写入磁盘</a></li></ul></li><li><a href="#_18">结束采集</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>lerobot录制</h1>
  <div class="meta">2025-07-29 · ai</div>
  <div class="post-content"><h2 id="_1">简介</h2>
<p>lerobot record是关键核心流程，其包括了数据的采集和模型推理两部分。</p>
<p>如果是数据采集模式，命令启动如下</p>
<div class="codehilite"><pre><span></span><code><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">lerobot</span><span class="o">.</span><span class="n">record</span> \
    <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">disable_torque_on_disconnect</span><span class="o">=</span><span class="n">true</span> \
    <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="n">so101_follower</span> \
    <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">port</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyACM0</span> \
    <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">R12252801</span> \
    <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="o">=</span><span class="s2">"{ handeye: {type: opencv, index_or_path: 6, width: 640, height: 480, fps: 30}, fixed: {type: opencv, index_or_path: 0, width: 640, height: 480, fps: 30}}"</span> \
    <span class="o">--</span><span class="n">teleop</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="n">so101_leader</span> \
    <span class="o">--</span><span class="n">teleop</span><span class="o">.</span><span class="n">port</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyACM1</span> \
    <span class="o">--</span><span class="n">teleop</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">R07252608</span> \
    <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">repo_id</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">HF_USER</span><span class="p">}</span><span class="o">/</span><span class="n">record</span><span class="o">-</span><span class="mi">07271148</span>\
    <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_episodes</span><span class="o">=</span><span class="mi">10</span> \
    <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">reset_time_s</span><span class="o">=</span><span class="mi">5</span> \
    <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">push_to_hub</span><span class="o">=</span><span class="n">false</span> \
    <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">single_task</span><span class="o">=</span><span class="s2">"Grab the cube"</span> \
    <span class="o">--</span><span class="n">display_data</span><span class="o">=</span><span class="n">true</span>
</code></pre></div>
<p>如果是模型推理模式，则命令如下：</p>
<div class="codehilite"><pre><span></span><code><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">lerobot</span><span class="o">.</span><span class="n">record</span>  \
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="n">so101_follower</span> \
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">disable_torque_on_disconnect</span><span class="o">=</span><span class="n">true</span> \
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">port</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyACM0</span> \
<span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="o">=</span><span class="s2">"{ handeye: {type: opencv, index_or_path: 6, width: 640, height: 480, fps: 30}, fixed: {type: opencv, index_or_path: 0, width: 640, height: 480, fps: 30}}"</span> \
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">R12252801</span> \
  <span class="o">--</span><span class="n">display_data</span><span class="o">=</span><span class="n">false</span> \
  <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">single_task</span><span class="o">=</span><span class="s2">"Put brick into the box"</span> \
  <span class="o">--</span><span class="n">policy</span><span class="o">.</span><span class="n">path</span><span class="o">=</span><span class="n">outputs</span><span class="o">/</span><span class="n">weigh_07280842</span><span class="o">/</span><span class="n">pretrained_model</span> \
  <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">episode_time_s</span><span class="o">=</span><span class="mi">240</span>  \
  <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">repo_id</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">HF_USER</span><span class="p">}</span><span class="o">/</span><span class="n">eval_so101_07271148</span>

<span class="n">默认录制时长是60s</span><span class="err">，</span><span class="mi">60</span><span class="n">S后会停止</span><span class="err">，</span><span class="n">如果要改长加上</span><span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">episode_time_s</span><span class="o">=</span><span class="mi">640</span> 
</code></pre></div>
<p>主要的区别是如果是采集模式需要使用--teleop参数启动遥控机器，如果是模型推理模式则不需要启动遥控机器，但是需要指定模型路径--policy.path，本质上就是机器人的动作指令来源于哪里，要么来之遥控器的，要么来自模型推理出来的。</p>
<p>在阅读本文前，这里先做一个总结：</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2025/07/wp_editor_md_643928e8d5da2fdf1d721700de6bbb9e.jpg"><img alt="" src="/assets/doc/04-ai/lerobot/lerobot数据采集与模型测试/images/wp_editor_md_643928e8d5da2fdf1d721700de6bbb9e.jpg"/></a></p>
<p>从上图可以看出整个录制流程主要围绕机器设备、遥控设备、模型、数据集四个要素进行展开。</p>
<ul>
<li>机器：有SO101Follower、LeKiwi等机器，都继承Robot类。通过命令行参数robot.type调用make_robot_from_config函数选择创建具体的实例设备，函数返回的还是Robot但是指向的是具体的机器实例如SO101Follower，利用了多态的特性做到了解耦，如果要新添机器时，只需要参考SO101Follower添加一个新的设备即可。在创建机器实例时传递RobotConfig参数，这个参数依旧是抽象基类，其继承了draccus.ChoiceRregistry，通过命令行参数robot.type选择注册具体的配置如SO101FollowerConfig。</li>
<li>遥控：用于控制机器，常用于数据的采集。这里同样通过命令行参数teleop.type调用make_teleoperator_from_config函数选择创建具体的设备实例，创建实例时需要传递TeleoperatorConfig参数，其也是一个抽象基类，基于命令选择注册实例化的配置类参数，如SO101LeaderConfig。</li>
<li>模型：模型用于决策推理动作，其和遥控二选一，如果指定了遥控了，模型就不需要指定了。通用使用了机器、遥控的解耦机制，具体的实例化为ACT或DiffusionPolicy等。</li>
<li>数据：通过参数dataset.xxx将参数构建为DataRecordConfig类，然后将其中的信息传递给LeRobotDataset。</li>
</ul>
<p>lerobot的整个代码框架将具体的设备、配置、模型等做到了解耦，方便拓展新的设备，其设计思想值得借鉴。下面本文将先按照执行命令启动流程可以分为参数解析、硬件设备初始化与连接、数据集初始化、采集循环、数据保存等几个阶段，接下来将按照这几个阶段进行介绍。</p>
<h2 id="_2">关键配置类</h2>
<p>在介绍关键流程时，先来总结一下关键record流程需要的配置类数据结构，这些Config类主要用于机器、遥控、模型实例化传递的参数。</p>
<h3 id="recordconfig">RecordConfig</h3>
<p>RecordConfig是整个record入口函数的传递参数，其通过命令行的参数构建形成RecordConfig对象传递给函数。</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">RecordConfig</span><span class="p">:</span>
    <span class="c1"># 1. 核心以来配置</span>
    <span class="c1"># 机器人硬件配置如型号、端口、相机参数等，有RobotConfig类定义</span>
    <span class="c1"># 如s101_folloer的通信端口、关节限制等，必现通过命令行或代码显式传入。</span>
    <span class="n">robot</span><span class="p">:</span> <span class="n">RobotConfig</span>
    <span class="c1">#数据集录制配置，如repo_id，num_episodes、fpsdeng，必现显式传入。</span>
    <span class="n">dataset</span><span class="p">:</span> <span class="n">DatasetRecordConfig</span>
    <span class="c1"># 2.控制方式配置（可选）</span>
    <span class="c1"># 遥控操作器配置，如So100_leader，可选。</span>
    <span class="n">teleop</span><span class="p">:</span> <span class="n">TeleoperatorConfig</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># 预训练策略配置，如模型路径、推理设备等。</span>
    <span class="n">policy</span><span class="p">:</span> <span class="n">PreTrainedConfig</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#3. UI与反馈配置（可选）</span>
    <span class="c1"># 是否实时显示相机画面，通过rerun可视化工具</span>
    <span class="n">display_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># 是否启用语音合成反馈，人机的提示声，默认开启。</span>
    <span class="n">play_sounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># 是否从现有数据集续录</span>
    <span class="n">resume</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 如果指定了policy，则进行加载模型</span>
        <span class="n">policy_path</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_path_arg</span><span class="p">(</span><span class="s2">"policy"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">policy_path</span><span class="p">:</span>
            <span class="n">cli_overrides</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_cli_overrides</span><span class="p">(</span><span class="s2">"policy"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">PreTrainedConfig</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">policy_path</span><span class="p">,</span> <span class="n">cli_overrides</span><span class="o">=</span><span class="n">cli_overrides</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">pretrained_path</span> <span class="o">=</span> <span class="n">policy_path</span>
         <span class="c1"># teleop和policy必须要指定一个</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">teleop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Choose a policy, a teleoperator or both to control the robot"</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__get_path_fields__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""This enables the parser to load config from the policy using `--policy.path=local/dir`"""</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">"policy"</span><span class="p">]</span>
</code></pre></div>
<p>RecordConfig中有几个关键的成员，分别是RobotConfig，DatasetRrcordConfig、TeleoperatorConfig、PreTrainedConfig。其中除了DatasetRrcordConfig外的其他几个都是继承draccus.ChoiceRegistry 和 abc.ABC，是一个抽象基类，需通过注册的子类（如特定机器人型号的配置类）实例化，种设计既保证了配置的结构化（继承 abc.ABC），又支持灵活的子类选择（通过 draccus.ChoiceRegistry 实现配置注册与解析）。</p>
<ul>
<li>RobotConfig 控制硬件接口，确保机器人正确连接和数据采集；</li>
<li>DatasetRecordConfig 控制数据存储，定义数据集格式和元信息；</li>
<li>TeleoperatorConfig 和 PreTrainedConfig 控制机器人行为，分别对应手动和自动控制模式。</li>
</ul>
<h3 id="robotconfig">RobotConfig</h3>
<div class="codehilite"><pre><span></span><code><span class="c1">#标记为数据类，所有字段必现通过关键参数传入，自动生成__init__等方法</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#继承draccus框架选择注册机制，允许子类如SO100FollowerConfig、KochFollowerConfig</span>
<span class="c1">#作为可选机器人型号注册，支持通过配置文件或命令行参数</span>
<span class="c1">#动态选择例如--robot.type=s101_follower</span>
<span class="c1">#abc.ABC抽象基类，不可直接实例化，必现通过子类具体机器人型号配置使用。</span>
<span class="k">class</span> <span class="nc">RobotConfig</span><span class="p">(</span><span class="n">draccus</span><span class="o">.</span><span class="n">ChoiceRegistry</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="c1"># 机器的唯一标识实例</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># 标定文件存储目录</span>
    <span class="n">calibration_dir</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#是 dataclass 的初始化后钩子，用于补充参数校验逻辑，确保机器人配置的合法性。</span>
    <span class="c1">#主要是检查cameras中的宽高、帧率等。</span>
    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"cameras"</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">config</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fps"</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">"Specifying '</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">' is required for the camera to be used in a robot"</span>
                        <span class="p">)</span>
    <span class="c1">#通过 draccus.ChoiceRegistry 的 get_choice_name 方法，动态返回子类的注册名称（即机器人型号）。</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_choice_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
</code></pre></div>
<p>RobotConfig 是抽象基类（ABC），仅定义所有机器共有的通用配置字段，如id、calibration_dir。其继承了draccus.ChoiceRegistry实现了不同机器人型号的动态注册与选择。</p>
<p>下面以一个继承实例说明</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@RobotConfig</span><span class="o">.</span><span class="n">register_subclass</span><span class="p">(</span><span class="s2">"so101_follower"</span><span class="p">)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SO101FollowerConfig</span><span class="p">(</span><span class="n">RobotConfig</span><span class="p">):</span>
    <span class="c1"># 机器的通信端口，如/dev/ttyACM0，通过--robot.port命令传入</span>
    <span class="n">port</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># 断开连接时是否关闭电机扭矩，通过命令--robot.disable_torque_on_disconnect</span>
    <span class="n">disable_torque_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># 电机相对位置目标安全上限，防止运动幅度过大。</span>
    <span class="n">max_relative_target</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># 相机的配置通过字典的方式。</span>
    <span class="n">cameras</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CameraConfig</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="c1">#--robot.cameras="{ handeye: {type: opencv, index_or_path: 6, width: 640, height: 480, fps: 30}, fixed: {type: opencv, index_or_path: 0, width: 640, height: 480, fps: 30}}</span>

    <span class="c1"># 是否使用角度制而非弧度制</span>
    <span class="n">use_degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</code></pre></div>
<p>这是框架自定义的子类注册装饰器，作用是将 SO101FollowerConfig 类与字符串 so101_follower 绑定，使其成为 RobotConfig 的可选型号。装饰器内部会将 SO101FollowerConfig 类添加到 RobotConfig 的“子类注册表”中，键为 so101_follower，值为类本身。当用户通过命令行传入 --robot.type=so101_follower 时，框架会从注册表中查找并实例化该类。</p>
<p>总结一下，RobotConfig是机器的硬件配置，但是其是一个虚拟基类，其具体实例的机器型号通过子类继承RobotConfig，有很多型号的子类，其巧妙的使用了draccus.ChoiceRegistry注册机制（RobotConfig继承），通过参数--robot.type来指定具体实例化的设备。同时这里也使用了多态的特性，通过统一的RobotConfig接口操作不同实例的具体实现，如通过 robot.type 属性（基类定义），可以动态判断具体子类类型，并执行对应逻辑。</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">"so101_follower"</span><span class="p">:</span>  <span class="c1"># 通过基类接口获取子类类型</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"SO101 特有端口: </span><span class="si">{</span><span class="n">cfg</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">port</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>  <span class="c1"># 访问子类特有属性</span>
<span class="k">elif</span> <span class="n">cfg</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">"so100_follower"</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"SO100 特有IP: </span><span class="si">{</span><span class="n">cfg</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">ip_address</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>  <span class="c1"># 另一子类的特有属性</span>
</code></pre></div>
<h3 id="datasetrecordconfig">DatasetRecordConfig</h3>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">DatasetRecordConfig</span><span class="p">:</span>
    <span class="c1">#1. 数据集标识与存储</span>
    <span class="c1">#数据集唯一标识符，格式为 '{hf_username}/{dataset_name}' (e.g. `lerobot/test`)，用于定位hugging Face Hub仓库或本地路径</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span>
   <span class="c1">#录制任务的文字描述，用于标注数据用途。</span>
    <span class="n">single_task</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># 数据集本地存储根目录，如果未指定使用~/.cache/huggingface/datasets</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># 2.录制控制参数</span>
    <span class="c1"># 录制的帧率，控制数据采集帧率。</span>
    <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="c1"># 单段录制时长，默认60S</span>
    <span class="n">episode_time_s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span>
    <span class="c1"># 重置环境时长，两端录制之间预留环境重置时间。</span>
    <span class="n">reset_time_s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">60</span>
    <span class="c1"># 总录制段数，控制数据集包含样本数量（如50段*60S=3000S总数据）</span>
    <span class="n">num_episodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="c1">#3. 数据处理与上传</span>
    <span class="c1"># 是否将录制图像帧编码为视频文件，默认开启</span>
    <span class="n">video</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># 是否上传数据集到hugging Face Hub，默认自动上传。</span>
    <span class="n">push_to_hub</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># Hub仓库是否设置为私有，默认是公开</span>
    <span class="n">private</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># 上传到hub上的数据集标签</span>
    <span class="n">tags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#4. 图像存储性能参数</span>
    <span class="c1">#图像写入的线程数</span>
    <span class="n">num_image_writer_processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#每个相机图像写入的线程数</span>
    <span class="n">num_image_writer_threads_per_camera</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"You need to provide a task as argument in `single_task`."</span><span class="p">)</span>
    <span class="c1">#__post_init__ 是 dataclass 的初始化后钩子方法，在 __init__ 初始化所有字段后自动执行，</span>
    <span class="c1"># 用于补充校验逻辑。</span>
    <span class="c1"># 确保 single_task 字段不为空。因为 single_task 是描述录制任务的核心元数据（无默认值且必选），</span>
    <span class="c1"># 若未提供则直接抛出错误，避免后续数据标注缺失关键信息。</span>
</code></pre></div>
<p>DatasetRecordConfig 是数据集录制任务的参数容器，被嵌套在 RecordConfig 中（作为 RecordConfig.dataset 字段），最终通过 parser.wrap() 装饰器从命令行参数解析生成实例。</p>
<p>例如，用户通过命令行指定：</p>
<div class="codehilite"><pre><span></span><code><span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">repo_id</span><span class="o">=</span><span class="n">aliberts</span><span class="o">/</span><span class="n">record</span><span class="o">-</span><span class="n">test</span> <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_episodes</span><span class="o">=</span><span class="mi">2</span> <span class="o">--</span><span class="n">dataset</span><span class="o">.</span><span class="n">single_task</span><span class="o">=</span><span class="s2">"Grab the cube"</span>
</code></pre></div>
<p>这些参数会被解析为 DatasetRecordConfig 实例，其字段值（如 num_episodes=2）直接控制录制逻辑（如 record_loop 函数的循环次数）。</p>
<h3 id="teleoperatorconfig">TeleoperatorConfig</h3>
<div class="codehilite"><pre><span></span><code><span class="nd">@dataclass</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TeleoperatorConfig</span><span class="p">(</span><span class="n">draccus</span><span class="o">.</span><span class="n">ChoiceRegistry</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="c1"># Allows to distinguish between different teleoperators of the same type</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Directory to store calibration file</span>
    <span class="n">calibration_dir</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_choice_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
</code></pre></div>
<p>TeleoperatorConfig 是远程遥控操作器（如手柄、键盘、 leader 机器人）的抽象配置基类，用于定义所有遥操作器共有的通用配置字段和动态选择机制。它与RobotConfig类似，同样继承了draccus.ChoiceRegistry 实现了注册机制，其具体的子类又继承TeleoperatorConfig。</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@TeleoperatorConfig</span><span class="o">.</span><span class="n">register_subclass</span><span class="p">(</span><span class="s2">"so101_leader"</span><span class="p">)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SO101LeaderConfig</span><span class="p">(</span><span class="n">TeleoperatorConfig</span><span class="p">):</span>
    <span class="c1"># Port to connect to the arm</span>
    <span class="n">port</span><span class="p">:</span> <span class="nb">str</span>

    <span class="n">use_degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</code></pre></div>
<p>用户通过-teleop.type指定来实例化具体的操作设备，如--teleop.type=so101_leader时，具体的流程如下。</p>
<ul>
<li>框架通过 draccus.ChoiceRegistry 查找注册名称为 so101_leader 的子类（如 SO101LeaderConfig）；</li>
<li>实例化该子类，接收命令行参数（如 --teleop.port=/dev/ttyACM0）并初始化特有字段（如 port）；</li>
<li>最终通过 TeleoperatorConfig 基类引用（如 cfg.teleop）传入 make_teleoperator_from_config 函数，创建具体遥操作器实例。</li>
</ul>
<h3 id="pretrainedconfig">PreTrainedConfig</h3>
<div class="codehilite"><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PreTrainedConfig</span><span class="p">(</span><span class="n">draccus</span><span class="o">.</span><span class="n">ChoiceRegistry</span><span class="p">,</span> <span class="n">HubMixin</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="c1">#1. 观测与特征配置</span>
    <span class="c1"># 策略输入的观测部署，如=2表示输入当前+前1步观测</span>
    <span class="n">n_obs_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#特征归一化模式映射{"image":"mead_std"}</span>
    <span class="n">normalization_mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NormalizationMode</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
   <span class="c1">#输入特征的规范{"image": PolicyFeature(type=VISUAL, shape=(3, 224, 224))}）</span>
    <span class="n">input_features</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PolicyFeature</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="c1">#输出特征规范输出特征规范（定义策略输出的特征类型，如 {"action": PolicyFeature(type=ACTION, shape=(6,))}）</span>
    <span class="n">output_features</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PolicyFeature</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="c1">#2. 设备与性能配置</span>
    <span class="c1"># 策略运行设备如是否使用cuda或cpu</span>
    <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># cuda | cpu | mp</span>
    <span class="c1">#是否启用自动混合精度训练</span>
    <span class="n">use_amp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#3. hugging face Hub继承</span>
    <span class="c1">#是否将配置上传到Hub</span>
    <span class="n">push_to_hub</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#Hub的id</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># 仓库是否私有</span>
    <span class="n">private</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># 仓库的标签</span>
    <span class="n">tags</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Add tags to your policy on the hub.</span>
    <span class="n">license</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#方法在__init__后执行，处理运行设备选择和AMP的可用性</span>
    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretrained_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#自动选择可用设备，如果用户指定的设备不可用。</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_torch_device_available</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
            <span class="n">auto_device</span> <span class="o">=</span> <span class="n">auto_select_torch_device</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Device '</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">' is not available. Switching to '</span><span class="si">{</span><span class="n">auto_device</span><span class="si">}</span><span class="s2">'."</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">auto_device</span><span class="o">.</span><span class="n">type</span>

        <span class="c1">#自动禁用不支持AMP</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_amp</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_amp_available</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">"Automatic Mixed Precision (amp) is not available on device '</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">'. Deactivating AMP."</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_amp</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#通过 draccus.ChoiceRegistry 的 get_choice_name 方法，返回子类注册的策略型号名称（如 sac、tdmpc），用于日志打印和策略选择逻辑</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_choice_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

    <span class="c1">#抽象方法</span>
    <span class="n">observation_delta_indices</span><span class="p">:</span><span class="n">返回观测特征的差分索引</span>
    <span class="n">action_delta_indices</span> <span class="p">:</span> <span class="n">返回动作特征的差分索引</span>
    <span class="n">reward_delta_indices</span> <span class="p">:</span> <span class="n">返回奖励特征的差分索引</span>
    <span class="n">et_optimizer_preset</span><span class="p">()</span> <span class="p">:</span> <span class="n">返回优化器配置</span>
    <span class="n">get_scheduler_preset</span><span class="p">()</span> <span class="p">:</span> <span class="n">返回学习率调度器配置</span><span class="err">（</span><span class="n">如</span> <span class="n">CosineAnnealing</span><span class="err">）。</span>
    <span class="n">validate_features</span><span class="p">()</span> <span class="p">:</span><span class="n">校验</span> <span class="n">input_features</span> <span class="n">和</span> <span class="n">output_features</span> <span class="n">的合法性</span><span class="err">（</span><span class="n">如形状匹配</span><span class="err">）</span>

    <span class="c1">#将策略配置实例（含超参数、特征规范、设备设置等）序列化</span>
    <span class="c1">#为标准 JSON 文件 config.json，存储到指定目录。这是策略配</span>
    <span class="c1">#置上传到 Hugging Face Hub 的前置步骤——Hub 要求模型/配</span>
    <span class="c1">#置必须包含 config.json 以描述其参数，而 _save_pretrained 正</span>
    <span class="c1">#是生成该文件的标准化实现。例如，当调用</span>
    <span class="c1">#config.push_to_hub() 时，框架会先调用 _save_pretrained 将</span>
    <span class="c1">#配置保存到临时目录，再将该目录上传到 Hub，最终用户可通</span>
    <span class="c1">#过 PreTrainedConfig.from_pretrained("repo_id") 加载此 JSON</span>
    <span class="c1">#配置。</span>
    <span class="k">def</span> <span class="nf">_save_pretrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save_directory</span><span class="p">:</span> <span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_directory</span> <span class="o">/</span> <span class="n">CONFIG_NAME</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">,</span> <span class="n">draccus</span><span class="o">.</span><span class="n">config_type</span><span class="p">(</span><span class="s2">"json"</span><span class="p">):</span>
            <span class="n">draccus</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="c1">#from_pretrained 是 PreTrainedConfig 的 核心类方法，用于从 </span>
    <span class="c1">#本地目录 或 Hugging Face Hub 加载预训练策略的配置文件</span>
    <span class="c1">#（config.json），并实例化为具体的配置对象（如 SACConfig、</span>
    <span class="c1">#TDMPCConfig）。它是策略配置“复用与共享”的入口，支持通过</span>
    <span class="c1">#命令行参数覆盖配置，实现灵活的参数调整。</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pretrained</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
        <span class="n">pretrained_name_or_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">force_download</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">resume_download</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">proxies</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">token</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">local_files_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">revision</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">policy_kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">model_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pretrained_name_or_path</span><span class="p">)</span>
        <span class="n">config_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#从本地目录加载</span>
        <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">model_id</span><span class="p">)</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">CONFIG_NAME</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">model_id</span><span class="p">):</span>
                <span class="n">config_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">model_id</span><span class="p">,</span> <span class="n">CONFIG_NAME</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">CONFIG_NAME</span><span class="si">}</span><span class="s2"> not found in </span><span class="si">{</span><span class="n">Path</span><span class="p">(</span><span class="n">model_id</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1">#从hugging face hub下载</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">config_file</span> <span class="o">=</span> <span class="n">hf_hub_download</span><span class="p">(</span>
                    <span class="n">repo_id</span><span class="o">=</span><span class="n">model_id</span><span class="p">,</span>
                    <span class="n">filename</span><span class="o">=</span><span class="n">CONFIG_NAME</span><span class="p">,</span>
                    <span class="n">revision</span><span class="o">=</span><span class="n">revision</span><span class="p">,</span>
                    <span class="n">cache_dir</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span>
                    <span class="n">force_download</span><span class="o">=</span><span class="n">force_download</span><span class="p">,</span>
                    <span class="n">proxies</span><span class="o">=</span><span class="n">proxies</span><span class="p">,</span>
                    <span class="n">resume_download</span><span class="o">=</span><span class="n">resume_download</span><span class="p">,</span>
                    <span class="n">token</span><span class="o">=</span><span class="n">token</span><span class="p">,</span>
                    <span class="n">local_files_only</span><span class="o">=</span><span class="n">local_files_only</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">HfHubHTTPError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">CONFIG_NAME</span><span class="si">}</span><span class="s2"> not found on the HuggingFace Hub in </span><span class="si">{</span><span class="n">model_id</span><span class="si">}</span><span class="s2">"</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="c1"># HACK: this is very ugly, ideally we'd like to be able to do that natively with draccus</span>
        <span class="c1"># something like --policy.path (in addition to --policy.type)</span>
        <span class="n">cli_overrides</span> <span class="o">=</span> <span class="n">policy_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"cli_overrides"</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">with</span> <span class="n">draccus</span><span class="o">.</span><span class="n">config_type</span><span class="p">(</span><span class="s2">"json"</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">draccus</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">config_file</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">cli_overrides</span><span class="p">)</span>
</code></pre></div>
<p>PreTrainedConfig是所有策略模型如ACT,TDMPC的抽象配置类，定义了策略训练/推理所需的通用参数，特征规范、设备配置及Hugging Face Hub交互机制。它通过 dataclass、draccus.ChoiceRegistry 和 abc.ABC 实现“配置标准化”“多策略兼容”和“Hub 集成”，是策略初始化的核心参数载体。</p>
<ul>
<li>draccus.ChoiceRegistry：通用跟前面的RobotConfig类似，支持动态子类注册，允许子类（如 SACConfig、TDMPCConfig）作为“策略选项”注册，支持通过 --policy.type=sac 动态选择。</li>
<li>HubMixin：Hugging Face Hub 交互混入类，提供 from_pretrained（从 Hub/本地加载配置）和 _save_pretrained（保存配置到 Hub/本地）方法，实现策略配置的共享与复用。</li>
<li>abc.ABC：抽象基类，包含未实现的抽象方法（如 get_optimizer_preset），强制子类必须实现核心逻辑，确保策略配置的完整性。</li>
</ul>
<h2 id="_3">参数解析</h2>
<p>输入的参数会draccus 解析器读取所有 --xxx 参数，映射到 RecordConfig 类（定义在 record.py 中），生成结构化配置对象 RecordConfig类型的cfg实例，关键的配置项如下：</p>
<ul>
<li>robot.type=so101_follower：指定机器人类型为 so101_follower（从动机器人）。</li>
<li>teleop.type=so101_leader：指定遥操作器类型为 so101_leader（主动遥操作器）。</li>
<li>dataset.num_episodes=10：采集10个回合数据。</li>
<li>display_data=true：启用 Rerun 可视化工具显示摄像头画面和机器人状态。</li>
</ul>
<p>RecordConfig的cfg实例构造是，会调用RecordConfig.<strong>post_init</strong> 检查如single_task，--teleop.type以及-policy.type必现要选择一个。因为录制要么就是验证模式，要么就是数据采集模式。验证模式就是通过大模型推理得到的动作数据，而采集模式通过遥控臂得到的数据控制设备。</p>
<h2 id="_4">硬件初始化与连接</h2>
<p><strong>机器人的初始化so101_follower</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">robot</span> <span class="o">=</span> <span class="n">make_robot_from_config</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">robot</span><span class="p">)</span>
<span class="n">robot</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</code></pre></div>
<p>传入的参数是cfg.robot，cfg.robot是一个基类，实际实例化为so101_follower的实例，这里使用了多态的特性。根据传入的参数--robot.port=/dev/ttyACM0 连接到机器人串口，初始化通信协议（如 ROS 或自定义串口协议）。根据 --robot.cameras 配置两个 OpenCV 摄像头。--robot.disable_torque_on_disconnect=true 确保程序退出时机器人断电，避免碰撞风险。</p>
<p><strong>遥控机器初始化so101_leader</strong></p>
<div class="codehilite"><pre><span></span><code><span class="n">teleop</span> <span class="o">=</span> <span class="n">make_teleoperator_from_config</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span><span class="p">)</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
<span class="n">teleop</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</code></pre></div>
<p>遥控机器初始化是可选的，如果指定了模型即是验证的方式，那么就不用启动遥控机器了，只有采集数据的时候才需要遥控机器。</p>
<p>总结一下，通过make_robot_from_config根据传入的robot.type创建一个机器实例,这里是class SO101Follower(Robot)。如果是采集模式还会创建一个遥控机器人实例，通过make_teleoperator_from_config生成实例class SO101Leader(Teleoperator)。</p>
<h2 id="_5">数据集创建</h2>
<h3 id="_6">数据特征定义</h3>
<div class="codehilite"><pre><span></span><code><span class="c1"># 动作特征-&gt;数据集动作特征</span>
<span class="n">action_features</span> <span class="o">=</span> <span class="n">hw_to_dataset_features</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">action_features</span><span class="p">,</span> <span class="s2">"action"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">video</span><span class="p">)</span>
<span class="c1"># 观测特征-&gt;数据集观测特征</span>
<span class="n">obs_features</span> <span class="o">=</span> <span class="n">hw_to_dataset_features</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">observation_features</span><span class="p">,</span> <span class="s2">"observation"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">video</span><span class="p">)</span>
<span class="c1"># 整个动作特征、观测特征</span>
<span class="n">dataset_features</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">action_features</span><span class="p">,</span> <span class="o">**</span><span class="n">obs_features</span><span class="p">}</span>

    <span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Action Features:"</span><span class="p">)</span>
    <span class="n">pprint</span><span class="p">(</span><span class="n">action_features</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Observation Features:"</span><span class="p">)</span>
    <span class="n">pprint</span><span class="p">(</span><span class="n">obs_features</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Dataset Features:"</span><span class="p">)</span>
    <span class="n">pprint</span><span class="p">(</span><span class="n">dataset_features</span><span class="p">)</span>
</code></pre></div>
<p>数据应该长什么样？ 这总的要格式要求吧？ hw_to_dataset_features就是将机器硬件特征（电机位置、摄像头图像）转换为数据集特征描述，也就是说数据要按照这个格式来。格式包含数据类型dtype、形状shape等。下面根据直接打印action_features、obs_features、dataset_features的打印的结果来分别分析。</p>
<div class="codehilite"><pre><span></span><code><span class="err">Ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="w"> </span><span class="err">Fea</span><span class="kc">tures</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">'ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">6</span><span class="p">,</span><span class="err">)</span><span class="p">,</span>
<span class="w">            </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">                      </span><span class="err">'shoulder_li</span><span class="kc">ft</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">                      </span><span class="err">'elbow_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">                      </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">                      </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_roll.pos'</span><span class="p">,</span>
<span class="w">                      </span><span class="err">'gripper.pos'</span><span class="p">]</span>
<span class="w">            </span><span class="p">}</span>
<span class="p">}</span>

<span class="err">Observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="w"> </span><span class="err">Fea</span><span class="kc">tures</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.s</span><span class="kc">tate</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">机器人关节状态</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">'</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">6</span><span class="p">,</span><span class="err">)</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">,</span><span class="w"> </span><span class="err">...</span><span class="p">,</span><span class="w"> </span><span class="err">'gripper.pos'</span><span class="p">]</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">与动作特征电机名称一致</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.ha</span><span class="kc">n</span><span class="err">deye'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">手眼相机图像</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'video'</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'heigh</span><span class="kc">t</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'wid</span><span class="kc">t</span><span class="err">h'</span><span class="p">,</span><span class="w"> </span><span class="err">'cha</span><span class="kc">nnels</span><span class="err">'</span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.</span><span class="kc">f</span><span class="err">ixed'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">固定视角相机图像</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'video'</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'heigh</span><span class="kc">t</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'wid</span><span class="kc">t</span><span class="err">h'</span><span class="p">,</span><span class="w"> </span><span class="err">'cha</span><span class="kc">nnels</span><span class="err">'</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_7">动作与观测特征</h4>
<p>生成action_features、obs_features都是调用hw_to_dataset_features函数，下面来看看这个函数的实现。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 函数入参为3个</span>
<span class="c1">#  -hw_features: dict[str, type | tuple] 机器硬件特征字典，键为特征名称如关节名、摄像头名，值为特征的类型如float或图像尺寸元组（height，width，channels），注意这里的type是类型不是实际的数值</span>
<span class="c1">#  -prefix: str 特征前缀，用于区分数据集不同的部分</span>
<span class="c1">#  -use_video: bool 是否将摄像头图像编码为视频</span>
<span class="k">def</span> <span class="nf">hw_to_dataset_features</span><span class="p">(</span>
    <span class="n">hw_features</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">],</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_video</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># 1.硬件特征分类，将关节特征和图像特征分出来</span>
    <span class="c1"># jointfs是关键特征，通过for循环遍历hw_features.items()满足ftype为float。然后将key和ftype通过新的键值对存储到joint_fs中。</span>
    <span class="c1">#示例输出：{"shoulder_pan.pos": float, "shoulder_lift.pos": float, ..., "gripper.pos": float}（共6个关节）。</span>
    <span class="n">joint_fts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">ftype</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ftype</span> <span class="ow">in</span> <span class="n">hw_features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">ftype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">}</span>
    <span class="c1">#cam_fs是摄像头的图像特征，值为(height, width, channels)元组。</span>
    <span class="c1">#示例输出：{"handeye": (480, 640, 3), "fixed": (480, 640, 3)}（两个摄像头，分辨率480×640，RGB三通道）。</span>
    <span class="n">cam_fts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">hw_features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)}</span>

    <span class="c1">#2. 关节特征转换数值型</span>
    <span class="c1">#根据传入的action动作指令，构建一个新的键值对，键为action。</span>
    <span class="k">if</span> <span class="n">joint_fts</span> <span class="ow">and</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s2">"action"</span><span class="p">:</span>
        <span class="n">features</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"dtype"</span><span class="p">:</span> <span class="s2">"float32"</span><span class="p">,</span> <span class="c1">#统一数值类型为float32，适合模型训练</span>
            <span class="s2">"shape"</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">joint_fts</span><span class="p">),),</span><span class="c1">#形状关键数量，如6个关键，(6,)</span>
            <span class="s2">"names"</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">joint_fts</span><span class="p">),</span><span class="c1">#关节名称列表，与机人电机意义对应</span>
        <span class="p">}</span>

    <span class="c1">#3. 观测装特特征，与前面action结构类似，只是键值为observation.state</span>
    <span class="k">if</span> <span class="n">joint_fts</span> <span class="ow">and</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s2">"observation"</span><span class="p">:</span>
        <span class="n">features</span><span class="p">[</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.state"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"dtype"</span><span class="p">:</span> <span class="s2">"float32"</span><span class="p">,</span>
            <span class="s2">"shape"</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">joint_fts</span><span class="p">),),</span>
            <span class="s2">"names"</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">joint_fts</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="c1">#4. 摄像头特征转换，为每个摄像头生成图像/视频存储特征</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">cam_fts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">features</span><span class="p">[</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.images.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"dtype"</span><span class="p">:</span> <span class="s2">"video"</span> <span class="k">if</span> <span class="n">use_video</span> <span class="k">else</span> <span class="s2">"image"</span><span class="p">,</span> <span class="c1">#存储类型：视频或图像</span>
            <span class="s2">"shape"</span><span class="p">:</span> <span class="n">shape</span><span class="p">,</span> <span class="c1">#图像尺寸(height, width, channels)</span>
            <span class="s2">"names"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"height"</span><span class="p">,</span> <span class="s2">"width"</span><span class="p">,</span> <span class="s2">"channels"</span><span class="p">],</span><span class="c1">#形状维度名称</span>
        <span class="p">}</span>

    <span class="n">_validate_feature_names</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">features</span>
</code></pre></div>
<p>数据集的创建关键来源hw_features: dict[str, type | tuple]参数，该值来源于robot.action_features、robot.observation_features，根据参数的实例化以SO101Follower实例为例。</p>
<div class="codehilite"><pre><span></span><code>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_motors_ft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">motor</span><span class="si">}</span><span class="s2">.pos"</span><span class="p">:</span> <span class="nb">float</span> <span class="k">for</span> <span class="n">motor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus</span><span class="o">.</span><span class="n">motors</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_cameras_ft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">cam</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="n">cam</span><span class="p">]</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="n">cam</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span>
        <span class="p">}</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">observation_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_motors_ft</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cameras_ft</span><span class="p">}</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">action_features</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motors_ft</span>
</code></pre></div>
<p><strong>电机位置特征结构</strong>_motors_ft定义了电机位置特征结构，描述关节运动的状态，其来源于self.bus.motors管理的电机列表，在<strong>Init</strong>中初始化，包含6个关节电机：</p>
<div class="codehilite"><pre><span></span><code><span class="n">motors</span><span class="o">=</span><span class="p">{</span>
    <span class="s2">"shoulder_pan"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>  <span class="c1"># 肩转</span>
    <span class="s2">"shoulder_lift"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span> <span class="c1"># 肩抬</span>
    <span class="s2">"elbow_flex"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>   <span class="c1"># 肘弯</span>
    <span class="s2">"wrist_flex"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>   <span class="c1"># 腕弯</span>
    <span class="s2">"wrist_roll"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>   <span class="c1"># 腕转</span>
    <span class="s2">"gripper"</span><span class="p">:</span> <span class="n">Motor</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s2">"sts3215"</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>      <span class="c1"># 夹爪</span>
<span class="p">}</span>
</code></pre></div>
<p>其输出格式返回字典 {电机名.pos: 数据类型}，例如：</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
    <span class="s2">"shoulder_pan.pos"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="s2">"shoulder_lift.pos"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="o">...</span><span class="p">,</span> 
    <span class="s2">"gripper.pos"</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">}</span>
</code></pre></div>
<p>float表示电机位置是浮点数值。</p>
<p><strong>摄像头图像特征</strong>定义机器人摄像头图像特征的结构，用于描述视觉传感器数据格式。来源self.cameras 是由 make_cameras_from_configs 创建的摄像头实例（如 handeye、fixed 摄像头），配置来自 self.config.cameras（包含分辨率等参数）。其输出格式为返回字典 {摄像头名: (高度, 宽度, 通道数)}，例如：</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
    <span class="s2">"handeye"</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># 480px高、640px宽、RGB三通道</span>
    <span class="s2">"fixed"</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>观测特征</strong>observation_features整合了电机位置和摄像头图像特征，定义机器人完整可观测装特，提供数据集录制和策略决策。通过字典解包（**）合并 _motors_ft（电机位置）和 _cameras_ft（摄像头图像），输出示例：</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
    <span class="c1"># 电机位置特征（来自 _motors_ft）</span>
    <span class="s2">"shoulder_pan.pos"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="s2">"shoulder_lift.pos"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="o">...</span><span class="p">,</span> 
    <span class="s2">"gripper.pos"</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
    <span class="c1"># 摄像头图像特征（来自 _cameras_ft）</span>
    <span class="s2">"handeye"</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
    <span class="s2">"fixed"</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>动作特征</strong>action_features定义机器人的动作指令格式，即遥控机器人。其直接服用_motors_ft，说明动作指令就是电机目标位置。</p>
<h4 id="_8">数据集特征合并</h4>
<div class="codehilite"><pre><span></span><code><span class="n">dataset_features</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">action_features</span><span class="p">,</span> <span class="o">**</span><span class="n">obs_features</span><span class="p">}</span>
</code></pre></div>
<p>合并动作特征与观测特征，形成数据集完整存储结构，用于初始化 LeRobotDataset。确保每个时间步的记录包含「观测→动作」的完整配对，满足训练需求（如模仿学习中，观测为输入，动作为标签）。</p>
<div class="codehilite"><pre><span></span><code><span class="err">Da</span><span class="kc">taset</span><span class="w"> </span><span class="err">Fea</span><span class="kc">tures</span><span class="p">:</span>
<span class="p">{</span>
<span class="w">    </span><span class="err">'ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">'</span><span class="p">,</span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">6</span><span class="p">,</span><span class="err">)</span><span class="p">,</span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'shoulder_li</span><span class="kc">ft</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'elbow_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_roll.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'gripper.pos'</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.s</span><span class="kc">tate</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">'</span><span class="p">,</span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">6</span><span class="p">,</span><span class="err">)</span><span class="p">,</span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'shoulder_li</span><span class="kc">ft</span><span class="err">.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'elbow_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_roll.pos'</span><span class="p">,</span>
<span class="w">            </span><span class="err">'gripper.pos'</span>
<span class="w">        </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.ha</span><span class="kc">n</span><span class="err">deye'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'video'</span><span class="p">,</span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'heigh</span><span class="kc">t</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'wid</span><span class="kc">t</span><span class="err">h'</span><span class="p">,</span><span class="w"> </span><span class="err">'cha</span><span class="kc">nnels</span><span class="err">'</span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.</span><span class="kc">f</span><span class="err">ixed'</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">'d</span><span class="kc">t</span><span class="err">ype'</span><span class="p">:</span><span class="w"> </span><span class="err">'video'</span><span class="p">,</span>
<span class="w">        </span><span class="err">'shape'</span><span class="p">:</span><span class="w"> </span><span class="err">(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span>
<span class="w">        </span><span class="err">'</span><span class="kc">na</span><span class="err">mes'</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">'heigh</span><span class="kc">t</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'wid</span><span class="kc">t</span><span class="err">h'</span><span class="p">,</span><span class="w"> </span><span class="err">'cha</span><span class="kc">nnels</span><span class="err">'</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>action：是遥控操作机器（如SO101Leader）的关节位置数据</li>
<li>observation.state：机器人（如S0101Follower）实时采集的关节位置数据。</li>
<li>observation.images.xx:机器人实时采集的图像数据，可有多个。</li>
</ul>
<h3 id="_9">创建数据集</h3>
<p>创建数据集，是创建一个空的数据集。 传入的参数有repo_id标识了数据集的目录，root为数据集的根目录等等，具体如下阐述。</p>
<div class="codehilite"><pre><span></span><code>        <span class="n">dataset</span> <span class="o">=</span> <span class="n">LeRobotDataset</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span>
            <span class="n">root</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">root</span><span class="p">,</span>
            <span class="n">robot_type</span><span class="o">=</span><span class="n">robot</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">features</span><span class="o">=</span><span class="n">dataset_features</span><span class="p">,</span>
            <span class="n">use_videos</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">video</span><span class="p">,</span>
            <span class="n">image_writer_processes</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_image_writer_processes</span><span class="p">,</span>
            <span class="n">image_writer_threads</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_image_writer_threads_per_camera</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="p">),</span>
        <span class="p">)</span>
</code></pre></div>
<ul>
<li>cfg.dataset.repo_id: 数据集的唯一标识，用于本地粗才能路径标识和上传hugging Face Hub上传的仓库名称</li>
<li>cfg.dataset.fps:录制帧率。</li>
<li>root=cfg.dataset.root:本地存储的路径，可以通过--dataset.root指定，如果没有提供，则默认使用缓存目录~/.cache/huggingface/</li>
<li>robot_type=robot.name:机器的唯一标识，会写入到meta.json中。</li>
<li>features=dataset_features：核心参数，数据集特征定义，由上一章节合并特征。</li>
<li>use_videos=cfg.dataset.video: 图像的存储格式，true表示使用mpr格式。False保留为PNG格式，占用空间大。内部在录制结束后，通过encode_episode_videos 调用 ffmpeg 将 PNG 序列转为视频（定义于 lerobot_dataset.py).</li>
<li>image_writer_processes: 图像写入的进程数量，默认0，仅使用线程即一个进程。</li>
<li>image_writer_threads：图像写入的线程数，默认4线程/摄像头 × N摄像头。</li>
</ul>
<h4 id="lerobotdatasetcreate">LeRobotDataset.create</h4>
<p>LeRobotDataset.create返回的是一个LeRobotDataset对象实例。</p>
<p>典型的LeRobotDataset本地存储为：</p>
<div class="codehilite"><pre><span></span><code>        <span class="o">.</span>
        <span class="err">├──</span> <span class="n">data</span>
        <span class="err">│</span>   <span class="err">├──</span> <span class="n">chunk</span><span class="o">-</span><span class="mi">000</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000000</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000001</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000002</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">└──</span> <span class="o">...</span>
        <span class="err">│</span>   <span class="err">├──</span> <span class="n">chunk</span><span class="o">-</span><span class="mi">001</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_001000</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_001001</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_001002</span><span class="o">.</span><span class="n">parquet</span>
        <span class="err">│</span>   <span class="err">│</span>   <span class="err">└──</span> <span class="o">...</span>
        <span class="err">│</span>   <span class="err">└──</span> <span class="o">...</span>
        <span class="err">├──</span> <span class="n">meta</span>
        <span class="err">│</span>   <span class="err">├──</span> <span class="n">episodes</span><span class="o">.</span><span class="n">jsonl</span>
        <span class="err">│</span>   <span class="err">├──</span> <span class="n">info</span><span class="o">.</span><span class="n">json</span>
        <span class="err">│</span>   <span class="err">├──</span> <span class="n">stats</span><span class="o">.</span><span class="n">json</span>
        <span class="err">│</span>   <span class="err">└──</span> <span class="n">tasks</span><span class="o">.</span><span class="n">jsonl</span>
        <span class="err">└──</span> <span class="n">videos</span>
            <span class="err">├──</span> <span class="n">chunk</span><span class="o">-</span><span class="mi">000</span>
            <span class="err">│</span>   <span class="err">├──</span> <span class="n">observation</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">laptop</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000000</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000001</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000002</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">└──</span> <span class="o">...</span>
            <span class="err">│</span>   <span class="err">├──</span> <span class="n">observation</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">phone</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000000</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000001</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">├──</span> <span class="n">episode_000002</span><span class="o">.</span><span class="n">mp4</span>
            <span class="err">│</span>   <span class="err">│</span>   <span class="err">└──</span> <span class="o">...</span>
            <span class="err">├──</span> <span class="n">chunk</span><span class="o">-</span><span class="mi">001</span>
            <span class="err">└──</span> <span class="o">...</span>
</code></pre></div>
<p><strong>核心属性</strong></p>
<ul>
<li>meta： LeRobotDatasetMetadata类，元数据管理器，存储数据集“说明书”：特征定义（动作/观测维度）、帧率、机器人类型、任务描述等。</li>
<li>repo_id: str类型，数据集唯一标识（如 lerobot/pick_cube），用于 Hugging Face Hub 定位和本地路径标识。</li>
<li>root:Path，本地存储根路径（默认：~/.cache/huggingface/lerobot/{repo_id}），包含 data/（Parquet）、meta/（元数据）、videos/（视频）。</li>
<li>revision： str类型，表示数据集的版本，默认代码库版本为v2.1。</li>
<li>tolerance_s：float类型，时间戳校验容差，确保录制视频帧率稳定性。</li>
<li>hf_dataset: Hugging Face Dataset 对象，存储非图像数据（关节位置、时间戳等），以 Parquet 格式。</li>
<li>episode_data_index： dirc类型，episode 索引映射表，记录每个 episode 的起始/结束帧位置（如 {"from": [0, 300], "to": [299, 599]}），加速帧检索。</li>
<li>delta_indices： dict类型，时间戳偏移索引（如 {"past": [-2, -1], "future": [1, 2]}），用于多模态数据同步（如动作与图像对齐）。</li>
<li>episode_buffer： dict类型，内存缓冲区，临时存储当前录制的帧数据（如 {"action": [], "observation.images.handeye": [], "timestamp": []}）。</li>
<li>image_writer:AsyncImageWriter,异步图像写入器（多线程/多进程），避免图像存储阻塞主控制循环（确保录制帧率稳定）。</li>
<li>image_transforms:图像预处理函数（如 torchvision.transforms.Resize、Normalize），训练时动态应用于摄像头图像。</li>
<li>video_backend: str类型，视频解码后端（默认 torchcodec 或 pyav），支持从 MP4 中精准提取指定时间戳的帧。</li>
</ul>
<p><strong>核心方法</strong></p>
<ul>
<li><strong>init</strong>: 数据集加载的入口，根据本地缓存状态完成元数据校验、数据下载（若缺失） 和时间戳同步检查，确保数据集可用。</li>
<li>add_frame:逐帧添加数据到缓冲区，录制时将单帧数据（动作、观测、图像）添加到 episode_buffer，并异步写入图像（避免阻塞控制循环）。</li>
<li>save_episode:写入到磁盘，录制完成一个 episode 后，将 episode_buffer 中的数据写入磁盘。包括非图像数据转换为Parquet文件存储到xxx.parquet，图像数据编码为MP4存储，元数据更新info.json,episodes.jsonl，episodes_stats.jsonl。</li>
<li><strong>getiterm</strong>：数据的加载与训练适配，实现 torch.utils.data.Dataset 接口，支持通过 DataLoader 加载数据用于训练。</li>
<li>push_to_hub：将数据集（元数据、Parquet、视频）上传至 Hugging Face Hub，自动生成数据集卡片（README.md），包含特征说明、硬件兼容性和统计信息</li>
<li>pull_from_repo:从 Hub 拉取指定版本的数据集，支持按 allow_patterns 筛选文件（如仅拉取元数据 meta/ 或特定 episode）。</li>
<li>start_image_writer/stop_image_writer:为避免图像存储阻塞录制主循环（导致帧率波动），通过 AsyncImageWriter 启动多线程/多进程写入器。</li>
<li>create:数据的新建或加载，是初始化的类方法。</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">create</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># 数据集标识（用户指定）</span>
    <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># 帧率（默认 30 FPS）</span>
    <span class="n">features</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>  <span class="c1"># 特征定义（动作+观测，来自机器人硬件）</span>
    <span class="n">root</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span>  <span class="c1"># 本地路径</span>
    <span class="n">robot_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># 机器人类型（如 "so101_follower"）</span>
    <span class="n">use_videos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># 是否编码视频（默认 True）</span>
    <span class="n">image_writer_processes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># 图像写入进程数</span>
    <span class="n">image_writer_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="p">),</span>  <span class="c1"># 图像写入线程数</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"LeRobotDataset"</span><span class="p">:</span>
    <span class="c1"># 1. 初始化元数据（调用 LeRobotDatasetMetadata.create）</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">LeRobotDatasetMetadata</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
        <span class="n">repo_id</span><span class="o">=</span><span class="n">repo_id</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="n">robot_type</span><span class="o">=</span><span class="n">robot_type</span><span class="p">,</span> <span class="n">use_videos</span><span class="o">=</span><span class="n">use_videos</span>
    <span class="p">)</span>
    <span class="c1"># 2. 启动图像写入器（异步写入）</span>
    <span class="k">if</span> <span class="n">image_writer_processes</span> <span class="ow">or</span> <span class="n">image_writer_threads</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">start_image_writer</span><span class="p">(</span><span class="n">image_writer_processes</span><span class="p">,</span> <span class="n">image_writer_threads</span><span class="p">)</span>
    <span class="c1"># 3. 初始化 episode 缓冲区（内存临时存储）</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">episode_buffer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">create_episode_buffer</span><span class="p">()</span>
    <span class="c1"># 4. 创建空 HF Dataset（存储非图像数据）</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">hf_dataset</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">create_hf_dataset</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">obj</span>
</code></pre></div>
<ul>
<li>元数据驱动：通过 LeRobotDatasetMetadata.create 确保数据集特征与机器人硬件严格对齐，避免录制后因特征不匹配导致训练错误。</li>
<li>性能优化：异步图像写入器（多线程/多进程）解决了录制时 I/O 阻塞问题，保障实时控制循环的稳定性。</li>
<li>标准化存储：统一 Parquet+MP4 格式，兼容 Hugging Face Hub 生态和 PyTorch DataLoader，简化“录制-训练”流程。</li>
</ul>
<p>LeRobotDataset.create 是一个类方法，通过 @classmethod 装饰，其核心特性是无需先实例化LeRobotDataset 类即可调用，直接通过类名 LeRobotDataset.create(...) 触发，并返回一个初始化完成的 LeRobotDataset 实例，通常用于工厂模式或单例模式的场景。</p>
<p>类方法（@classmethod）的第一个参数是 cls（代表类本身），因此可以直接通过类名触发，而非实例。LeRobotDataset.create 的作用正是绕开普通构造函数 <strong>init</strong>，为新建数据集执行特殊初始化逻辑（如元数据创建、目录结构搭建、异步写入器启动等），最终返回一个完整的 LeRobotDataset 实例。</p>
<h4 id="lerobotdatasetmetadatacreate">LeRobotDatasetMetadata.create</h4>
<p>在LeRobotDataset中会调用到obj.meta = LeRobotDatasetMetadata.create创建一个LeRobotDatasetMetadata对象，其核心功能是为全新数据集初始化元数据结构，包括目录创建、特征定义合并、元数据文件生成（如 meta/info.json）和硬件兼容性校验，确保后续机器人数据录制（关节状态、摄像头图像等）与存储格式严格对齐。</p>
<div class="codehilite"><pre><span></span><code>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">features</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">robot_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_videos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">"LeRobotDatasetMetadata"</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Creates metadata for a LeRobotDataset."""</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="c1">#创建空的 LeRobotDatasetMetadata 实例（不触发 __init__，避免加载现有元数据）</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">repo_id</span> <span class="o">=</span> <span class="n">repo_id</span>
        <span class="c1"># 数据集标识（如 "username/pick_cube"）</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">HF_LEROBOT_HOME</span> <span class="o">/</span> <span class="n">repo_id</span>
        <span class="c1"># 本地路径（默认缓存目录）</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># TODO(aliberts, rcadene): implement sanity check for features</span>
        <span class="c1"># 合并用户提供的特征与默认特征（补充必选字段）</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">DEFAULT_FEATURES</span><span class="p">}</span>
        <span class="n">_validate_feature_names</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
        <span class="c1"># 校验特征名称合法性（如禁止含空格、特殊字符，确保与硬件接口一致）</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">task_to_task_index</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="c1"># 任务列表（如 {"pick": 0, "place": 1}）及索引映射</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">episodes_stats</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">episodes</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="c1"># 初始化 episode 统计信息、全局统计、episode 列表</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">create_empty_dataset_info</span><span class="p">(</span><span class="n">CODEBASE_VERSION</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">use_videos</span><span class="p">,</span> <span class="n">robot_type</span><span class="p">)</span>
     <span class="c1">#生成数据集的“总说明书”（meta/info.json），包含以下关键信息</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">video_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_videos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="n">write_json</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">root</span> <span class="o">/</span> <span class="n">INFO_PATH</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">obj</span>
</code></pre></div>
<p>LeRobotDatasetMetadata.create 是新建数据集的“元数据基石”，通过标准化目录结构、特征定义和兼容性校验，确保机器人录制数据（动作、图像、状态）的存储格式与硬件特征严格对齐。其输出的 LeRobotDatasetMetadata 实例是连接机器人硬件与数据集文件系统的核心桥梁，为后续数据录制、编码和训练加载提供统一的元信息描述。</p>
<h3 id="_10">加载数据集</h3>
<p>加载数据集是加载已经存在的数据集，针对的场景是针对此前的录制场景接着录制，与创建数据集不同，创建数据集是从头开始，创建一个空的数据集。那么lerobot怎么进行恢复了？</p>
<p>前面章节无论是LeRobotDataset.create 还是LeRobotDatasetMetadata.create都会绕过类的构造函数xxx.<strong>init</strong>的运行，那么xxx.<strong>init</strong>在哪里运行了？</p>
<p>LeRobotDataset.<strong>init</strong> 是类的默认构造函数，仅在直接实例化 LeRobotDataset 时调用，核心场景是 恢复已有数据集的录制或加载。而 LeRobotDataset.create 是类方法，用于创建全新数据集，二者分工明确，对应不同的用户需求。接下来针对恢复的场景来说明。</p>
<p>当输入参数--resume=true，即在原来的数据集基础上进行。</p>
<div class="codehilite"><pre><span></span><code>   <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">resume</span><span class="p">:</span>
       <span class="c1">#走恢复模式</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">LeRobotDataset</span><span class="p">(</span>
            <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span><span class="c1"># 数据集标识（如 "lerobot/pick_cube"）</span>
            <span class="n">root</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">root</span><span class="p">,</span><span class="c1"># 本地存储路径（默认：~/.cache/huggingface/lerobot/{repo_id}）</span>
<span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="s2">"cameras"</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">start_image_writer</span><span class="p">(</span>
                <span class="n">num_processes</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_image_writer_processes</span><span class="p">,</span>
                <span class="n">num_threads</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_image_writer_threads_per_camera</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">cameras</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">sanity_check_dataset_robot_compatibility</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">robot</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span> <span class="n">dataset_features</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">LeRobotDataset</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="o">......</span><span class="p">)</span>
</code></pre></div>
<p>关键流程是实例化LeRobotDataset，触发LeRobotDataset.<strong>init</strong> 方法，LeRobotDataset类的初始化代码如下。</p>
<h4 id="lerobotdatasetinit">LeRobotDataset.<strong>init</strong></h4>
<div class="codehilite"><pre><span></span><code><span class="n">LeRobotDataset</span><span class="err">：</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># 数据集标识（如 "lerobot/pick_cube"）</span>
    <span class="n">root</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span>  <span class="c1"># 本地存储路径（默认：~/.cache/huggingface/lerobot/{repo_id}）</span>
    <span class="n">episodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># 指定加载的 episode 索引（如 [0, 2, 5]）</span>
    <span class="n">image_transforms</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># 图像预处理（如 Resize、Normalize）</span>
    <span class="n">delta_timestamps</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span>  <span class="c1"># 时间戳偏移（用于多模态数据同步）</span>
    <span class="n">tolerance_s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>  <span class="c1"># 时间戳校验容差（确保帧率稳定性）</span>
    <span class="n">revision</span><span class="p">:</span> <span class="o">...</span><span class="p">,</span>  <span class="c1"># 数据集版本（默认代码库版本 v2.1）</span>
    <span class="n">force_cache_sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># 强制同步缓存（忽略本地文件，重新拉取）</span>
    <span class="n">download_videos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># 是否下载视频文件</span>
    <span class="n">video_backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># 视频解码后端（如 "pyav"、"torchcodec"）</span>
<span class="p">):</span>
    <span class="c1"># 1. 初始化基础路径与配置</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span> <span class="o">=</span> <span class="n">repo_id</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="ow">or</span> <span class="n">HF_LEROBOT_HOME</span> <span class="o">/</span> <span class="n">repo_id</span>  <span class="c1"># 本地路径</span>
    <span class="c1">#没有创建的话默认就是~/.cache/huggingface/lerobot</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 创建目录（若不存在）</span>

    <span class="c1"># 2. 加载元数据（通过 LeRobotDatasetMetadata）</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="o">=</span> <span class="n">LeRobotDatasetMetadata</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">,</span> <span class="n">force_cache_sync</span><span class="o">=</span><span class="n">force_cache_sync</span>
    <span class="p">)</span>

    <span class="c1"># 3. 加载实际数据（优先本地缓存，缺失则从 Hub 下载）</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">force_cache_sync</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span>  <span class="c1"># 强制同步时跳过本地缓存</span>
        <span class="c1"># 验证本地数据文件完整性</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">/</span> <span class="n">fpath</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="k">for</span> <span class="n">fpath</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_episodes_file_paths</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hf_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_hf_dataset</span><span class="p">()</span>  <span class="c1"># 加载 Parquet 格式数据（非图像）</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">):</span>
        <span class="c1"># 从 Hub 下载数据（含 Parquet 和视频文件）</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">get_safe_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">)</span>  <span class="c1"># 校验版本合法性</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">download_episodes</span><span class="p">(</span><span class="n">download_videos</span><span class="p">)</span>  <span class="c1"># 下载指定 episode 数据</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hf_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_hf_dataset</span><span class="p">()</span>  <span class="c1"># 重新加载数据</span>

    <span class="c1"># 4. 数据校验（确保时间戳与帧率匹配）</span>
    <span class="n">timestamps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hf_dataset</span><span class="p">[</span><span class="s2">"timestamp"</span><span class="p">]))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">episode_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hf_dataset</span><span class="p">[</span><span class="s2">"episode_index"</span><span class="p">]))</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">check_timestamps_sync</span><span class="p">(</span>  <span class="c1"># 校验每帧时间间隔是否为 1/fps ± tolerance_s</span>
        <span class="n">timestamps</span><span class="p">,</span> <span class="n">episode_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">episode_data_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance_s</span>
    <span class="p">)</span>
</code></pre></div>
<p>LeRobotDataset 类的构造函数（<strong>init</strong> 方法），其核心作用是加载已存在的机器人数据集（本地或 Hugging Face Hub），并完成元数据校验、数据完整性检查、时间戳同步等关键步骤，为后续数据访问（如训练、可视化）提供统一接口。该方法是 LeRobotDataset 类的“入口”，仅在恢复已有数据集或加载数据集用于训练时调用。</p>
<p>LeRobotDataset 是基于 PyTorch Dataset 的子类，专为机器人数据设计，支持两种场景：</p>
<ul>
<li>加载本地已有数据集：从指定路径（root）直接读取元数据和数据文件。</li>
<li>从 Hugging Face Hub 下载数据集：若本地数据缺失，自动从 Hub 拉取并加载。</li>
</ul>
<p>无论哪种场景，<strong>init</strong> 均确保数据集的元数据一致性（如机器人类型、帧率）、数据完整性（文件不缺失）和时间戳有效性（符合录制帧率），为下游任务（如策略训练）提供可靠数据。</p>
<h4 id="lerobotdatasetmetadatainit">LeRobotDatasetMetadata.<strong>init</strong></h4>
<p>在LeRobotDataset.<strong>init</strong>中实例化了self.meta = LeRobotDatasetMetadata，该类创建时会调用构造函数LeRobotDatasetMetadata.<strong>init</strong>。</p>
<div class="codehilite"><pre><span></span><code><span class="n">lass</span> <span class="n">LeRobotDatasetMetadata</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">revision</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force_cache_sync</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span> <span class="o">=</span> <span class="n">repo_id</span> <span class="c1"># 数据集唯一标识</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">revision</span> <span class="k">if</span> <span class="n">revision</span> <span class="k">else</span> <span class="n">CODEBASE_VERSION</span>
        <span class="c1"># 版本（默认代码库版本）</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">HF_LEROBOT_HOME</span> <span class="o">/</span> <span class="n">repo_id</span>
        <span class="c1">#本地路径（默认缓存目录）</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">force_cache_sync</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_metadata</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">NotADirectoryError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_valid_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">get_safe_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">)</span>

            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">/</span> <span class="s2">"meta"</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pull_from_repo</span><span class="p">(</span><span class="n">allow_patterns</span><span class="o">=</span><span class="s2">"meta/"</span><span class="p">)</span>
            <span class="c1"># 加载本地元数据</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_metadata</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">load_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="n">check_version_compatibility</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span><span class="p">,</span> <span class="n">CODEBASE_VERSION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_to_task_index</span> <span class="o">=</span> <span class="n">load_tasks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episodes</span> <span class="o">=</span> <span class="n">load_episodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&lt;</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"v2.1"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">load_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span> <span class="o">=</span> <span class="n">backward_compatible_episodes_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">episodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span> <span class="o">=</span> <span class="n">load_episodes_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">aggregate_stats</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">load_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">load_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="n">check_version_compatibility</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span><span class="p">,</span> <span class="n">CODEBASE_VERSION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_to_task_index</span> <span class="o">=</span> <span class="n">load_tasks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episodes</span> <span class="o">=</span> <span class="n">load_episodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">&lt;</span> <span class="n">packaging</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"v2.1"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">load_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span> <span class="o">=</span> <span class="n">backward_compatible_episodes_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">episodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span> <span class="o">=</span> <span class="n">load_episodes_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">aggregate_stats</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">episodes_stats</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
</code></pre></div>
<p>从 self.root/meta 目录加载核心元数据文件（info.json、tasks.jsonl、episodes.jsonl 等），并校验元数据版本与当前代码库兼容性（check_version_compatibility）</p>
<h2 id="_11">录制流程</h2>
<div class="codehilite"><pre><span></span><code>    <span class="n">policy</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">policy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">make_policy</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">policy</span><span class="p">,</span> <span class="n">ds_meta</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
    <span class="c1">#如果是能了策略模型，进行实例创建</span>
    <span class="n">listener</span><span class="p">,</span> <span class="n">events</span> <span class="o">=</span> <span class="n">init_keyboard_listener</span><span class="p">()</span>
    <span class="c1">#初始化监听键盘事件</span>
</code></pre></div>
<p>先判断是否指定了策略模型，如果指定了进行创建实例。同时初始化键盘监听器</p>
<div class="codehilite"><pre><span></span><code><span class="n">recorded_episodes</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">recorded_episodes</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_episodes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">events</span><span class="p">[</span><span class="s2">"stop_recording"</span><span class="p">]:</span>
    <span class="c1"># 录制当前回合数据</span>
    <span class="n">log_say</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Recording episode </span><span class="si">{</span><span class="n">dataset</span><span class="o">.</span><span class="n">num_episodes</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">play_sounds</span><span class="p">)</span>  <span class="c1"># 语音提示开始录制</span>
    <span class="n">record_loop</span><span class="p">(</span>  <span class="c1"># 核心数据采集函数</span>
        <span class="n">robot</span><span class="o">=</span><span class="n">robot</span><span class="p">,</span>
        <span class="n">teleop</span><span class="o">=</span><span class="n">teleop</span><span class="p">,</span>  <span class="c1"># 遥操作器输入（或策略生成动作）</span>
        <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="p">,</span>
        <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>  <span class="c1"># 数据写入目标</span>
        <span class="n">control_time_s</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">episode_time_s</span><span class="p">,</span>  <span class="c1"># 单回合录制时长（默认60秒）</span>
        <span class="n">display_data</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">display_data</span><span class="p">,</span>  <span class="c1"># 实时可视化</span>
    <span class="p">)</span>

    <span class="c1"># 回合间环境重置（给用户调整物体位置的时间）</span>
    <span class="c1"># 该阶段不写入数据，用于用户重置环境。</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">events</span><span class="p">[</span><span class="s2">"stop_recording"</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="o">...</span><span class="p">):</span>
        <span class="n">log_say</span><span class="p">(</span><span class="s2">"Reset the environment"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">play_sounds</span><span class="p">)</span>
        <span class="n">record_loop</span><span class="p">(</span>  <span class="c1"># 重置阶段不记录数据（dataset=None）</span>
            <span class="n">robot</span><span class="o">=</span><span class="n">robot</span><span class="p">,</span>
            <span class="n">teleop</span><span class="o">=</span><span class="n">teleop</span><span class="p">,</span>
            <span class="n">control_time_s</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">reset_time_s</span><span class="p">,</span>  <span class="c1"># 重置时长（用户指定5秒）</span>
            <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># 禁用数据写入</span>
        <span class="p">)</span>

    <span class="c1"># 处理重录事件（用户按 'r' 触发）</span>
    <span class="k">if</span> <span class="n">events</span><span class="p">[</span><span class="s2">"rerecord_episode"</span><span class="p">]:</span>
        <span class="n">log_say</span><span class="p">(</span><span class="s2">"Re-record episode"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">play_sounds</span><span class="p">)</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">clear_episode_buffer</span><span class="p">()</span>  <span class="c1"># 清空当前回合无效数据</span>
        <span class="k">continue</span>  <span class="c1"># 重新录制当前回合</span>

    <span class="n">dataset</span><span class="o">.</span><span class="n">save_episode</span><span class="p">()</span>  <span class="c1"># 保存当前回合数据到磁盘（图像、状态、动作）</span>
    <span class="n">recorded_episodes</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 回合计数+1</span>
</code></pre></div>
<p>核心是调用record_loop进行采集录制，过程中监听用户输入的键盘值处理相关逻辑如右键结束单次录制，左键重复录制，ESC退出流程。</p>
<p>当前回合录制结束后，继续调用record_loop只是传递的参数不一样，等待环境复位。录制完当前回合后，调用dataset.save_episode()将数据写入到磁盘中。</p>
<h2 id="_12">录制循环</h2>
<p>record_loop函数在两种场景下被调用，主要的作用是协调机器人控制（遥操作/策略）、数据采集与存储，确保数据帧率稳定且格式符合数据集要求。</p>
<ul>
<li>正常录制：按配置时长（control_time_s）录制 episode 数据，保存到数据集。</li>
<li>环境重置：录制结束后，执行一段无数据保存的控制（让用户手动重置环境）。</li>
</ul>
<h3 id="_13">初始化与参数校验</h3>
<div class="codehilite"><pre><span></span><code><span class="c1"># 校验数据集帧率与录制帧率一致性</span>
<span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dataset</span><span class="o">.</span><span class="n">fps</span> <span class="o">!=</span> <span class="n">fps</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"The dataset fps should be equal to requested fps (</span><span class="si">{</span><span class="n">dataset</span><span class="o">.</span><span class="n">fps</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">fps</span><span class="si">}</span><span class="s2">)."</span><span class="p">)</span>

<span class="c1"># 多遥操作器处理（如机械臂遥操作 + 键盘底盘控制）</span>
<span class="n">teleop_arm</span> <span class="o">=</span> <span class="n">teleop_keyboard</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">teleop</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="c1"># 分离键盘遥操作器和机械臂遥操作器</span>
    <span class="n">teleop_keyboard</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">teleop</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">KeyboardTeleop</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">teleop_arm</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">teleop</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">SO100Leader</span><span class="p">,</span> <span class="o">...</span><span class="p">))),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># 校验：仅支持 LeKiwi 机器人，且必须包含 1 个键盘遥操作器 + 1 个机械臂遥操作器</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">teleop_arm</span> <span class="ow">and</span> <span class="n">teleop_keyboard</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">teleop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">robot</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">"lekiwi_client"</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="c1"># 策略重置（若使用策略控制，确保初始状态一致）</span>
<span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">policy</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</code></pre></div>
<p>首先校验一下数据集的帧率与录制帧率是否一致，如果遥控机器人有多个实例，比如主臂+键盘，一般这种组合用于lekiwi，包含一个键盘遥控操作器和1个机械臂遥控操作器。最后判断是否使用模型推理控制，如果是使用了先进行复位。</p>
<h3 id="_14">主循环控制与数据采集</h3>
<div class="codehilite"><pre><span></span><code><span class="n">timestamp</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#  episode 已录制时长（秒）</span>
<span class="n">start_episode_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>  <span class="c1"># 起始时间戳</span>
<span class="k">while</span> <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">control_time_s</span><span class="p">:</span>
    <span class="n">start_loop_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>  <span class="c1"># 本轮循环起始时间</span>

    <span class="c1"># 检查是否提前退出（如用户按特定按键）</span>
    <span class="k">if</span> <span class="n">events</span><span class="p">[</span><span class="s2">"exit_early"</span><span class="p">]:</span>
        <span class="n">events</span><span class="p">[</span><span class="s2">"exit_early"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">break</span>

    <span class="c1"># 1. 获取机器人观测（传感器数据：摄像头图像、关节角度等）</span>
    <span class="n">observation</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()</span>

    <span class="c1"># 2. 构建观测帧（符合数据集格式）</span>
    <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">observation_frame</span> <span class="o">=</span> <span class="n">build_dataset_frame</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">observation</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">"observation"</span><span class="p">)</span>

    <span class="c1"># 3. 生成动作（策略/遥操作器二选一）</span>
    <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># 策略生成动作：输入观测帧，输出动作值</span>
        <span class="n">action_values</span> <span class="o">=</span> <span class="n">predict_action</span><span class="p">(</span>
            <span class="n">observation_frame</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">get_safe_torch_device</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="o">...</span>
        <span class="p">)</span>
        <span class="c1"># 格式化动作：按机器人动作特征（如关节名称）构建字典</span>
        <span class="n">action</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">action_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">action_features</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="n">policy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">teleop</span><span class="p">,</span> <span class="n">Teleoperator</span><span class="p">):</span>
        <span class="c1"># 单遥操作器：直接获取动作</span>
        <span class="n">action</span> <span class="o">=</span> <span class="n">teleop</span><span class="o">.</span><span class="n">get_action</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">policy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">teleop</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># 多遥操作器：合并机械臂动作和底盘动作</span>
        <span class="n">arm_action</span> <span class="o">=</span> <span class="n">teleop_arm</span><span class="o">.</span><span class="n">get_action</span><span class="p">()</span>  <span class="c1"># 机械臂动作</span>
        <span class="n">base_action</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">_from_keyboard_to_base_action</span><span class="p">(</span><span class="n">teleop_keyboard</span><span class="o">.</span><span class="n">get_action</span><span class="p">())</span>  <span class="c1"># 底盘动作</span>
        <span class="n">action</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">arm_action</span><span class="p">,</span> <span class="o">**</span><span class="n">base_action</span><span class="p">}</span>  <span class="c1"># 合并动作</span>

    <span class="c1"># 4. 执行动作并记录实际发送的动作（可能因安全限制被裁剪）</span>
    <span class="n">sent_action</span> <span class="o">=</span> <span class="n">robot</span><span class="o">.</span><span class="n">send_action</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

    <span class="c1"># 5. 保存数据到数据集（若启用）</span>
    <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">action_frame</span> <span class="o">=</span> <span class="n">build_dataset_frame</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">features</span><span class="p">,</span> <span class="n">sent_action</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">"action"</span><span class="p">)</span>  <span class="c1"># 动作帧</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">observation_frame</span><span class="p">,</span> <span class="o">**</span><span class="n">action_frame</span><span class="p">}</span>  <span class="c1"># 合并观测与动作</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">add_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">single_task</span><span class="p">)</span>  <span class="c1"># 添加到数据集</span>

    <span class="c1"># 6. 可视化数据（若启用）</span>
    <span class="k">if</span> <span class="n">display_data</span><span class="p">:</span>
        <span class="n">log_rerun_data</span><span class="p">(</span><span class="n">observation</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>  <span class="c1"># 记录数据用于 Rerun 可视化</span>

    <span class="c1"># 7. 维持帧率：等待剩余时间以确保循环周期为 1/FPS 秒</span>
    <span class="n">dt_s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_loop_t</span>  <span class="c1"># 本轮循环耗时</span>
    <span class="n">busy_wait</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span> <span class="o">-</span> <span class="n">dt_s</span><span class="p">)</span>  <span class="c1">#  busy 等待以补足时间</span>

    <span class="c1"># 更新 episode 已录制时长</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_episode_t</span>
</code></pre></div>
<p>这里分为两种模式，一个是模型推理模式和遥控操作模式，前者是使用大模型进行预测产生动作处理，后者是用于大模型训练采集数据。</p>
<p>对于<strong>采集数据模式流程</strong>如下：</p>
<ul>
<li>获取观测原始数据：调用robot.get_observation()获取观测数据，包括机器关节的数据、摄像头数据等。用于后续的数据存储。</li>
<li>获取遥控机器人的动作数据：调用action = teleop.get_action()获取到动作数据。如果是多遥控操作器，需要将其合并动作。</li>
<li>发送机器人执行动作：调用sent_action = robot.send_action(action)执行动作。</li>
<li>保存数据集：先调用build_dataset_frame构建遥控臂的数据action，然后将action与从臂机器的观测数据action_values进行合并frame，最后调用dataset.add_frame添加到数据集中。</li>
<li>可视化数据：如果启动了可视化数据，调用log_rerun_data记录数据用于rerun可视化。</li>
<li>时长更新：录制一轮有一个默认的等待时长，调用busy_wait进行等待。</li>
</ul>
<p>对于<strong>模型推理模式流程</strong>如下：</p>
<ul>
<li>获取观测原始数据：调用robot.get_observation()获取观测数据，包括机器关节的数据、摄像头数据等。</li>
<li>构建模型输入数据：要能够喂给模型做预测动作，需要将数据转换为模型可接收的格式，调用build_dataset_frame将观测原始数据进行转换。</li>
<li>模型生成预测动作：调用predict_action得到预测动作action_values，接着将action_values转换为机器的动作特征action。</li>
<li>发送预测动作：调用robot.send_action(action)将预测动作发送给机器进行执行。</li>
</ul>
<p>下面是observation = robot.get_observation()返回的数据格式，主要包括的是6个舵机关节位置信息+两个相机的图像信息，一共8个键值对。</p>
<div class="codehilite"><pre><span></span><code><span class="err">observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="p">:</span>
<span class="p">{</span><span class="err">'elbow_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">99.54710144927537</span><span class="p">,</span>
<span class="w"> </span><span class="err">'</span><span class="kc">f</span><span class="err">ixed'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="w"> </span><span class="mi">58</span><span class="p">,</span><span class="w">  </span><span class="mi">48</span><span class="p">,</span><span class="w">  </span><span class="mi">39</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">56</span><span class="p">,</span><span class="w">  </span><span class="mi">46</span><span class="p">,</span><span class="w">  </span><span class="mi">37</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">49</span><span class="p">,</span><span class="w">  </span><span class="mi">39</span><span class="p">,</span><span class="w">  </span><span class="mi">29</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">45</span><span class="p">,</span><span class="w">  </span><span class="mi">81</span><span class="p">,</span><span class="w">  </span><span class="mi">69</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">54</span><span class="p">,</span><span class="w">  </span><span class="mi">87</span><span class="p">,</span><span class="w">  </span><span class="mi">76</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">55</span><span class="p">,</span><span class="w">  </span><span class="mi">88</span><span class="p">,</span><span class="w">  </span><span class="mi">77</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'gripper.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">2.666666666666667</span><span class="p">,</span>
<span class="w"> </span><span class="err">'ha</span><span class="kc">n</span><span class="err">deye'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="mi">76</span><span class="p">,</span><span class="w"> </span><span class="mi">71</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">75</span><span class="p">,</span><span class="w"> </span><span class="mi">70</span><span class="p">,</span><span class="w"> </span><span class="mi">74</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">69</span><span class="p">,</span><span class="w"> </span><span class="mi">67</span><span class="p">,</span><span class="w"> </span><span class="mi">70</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="mi">38</span><span class="p">,</span><span class="w"> </span><span class="mi">73</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">68</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">26</span><span class="p">,</span><span class="w"> </span><span class="mi">63</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'shoulder_li</span><span class="kc">ft</span><span class="err">.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-98.65771812080537</span><span class="p">,</span>
<span class="w"> </span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-10.490956072351423</span><span class="p">,</span>
<span class="w"> </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">54.17743324720067</span><span class="p">,</span>
<span class="w"> </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_roll.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-3.5714285714285694</span><span class="p">}</span>
</code></pre></div>
<p>原始的观测数据，要经过处理，以便喂给模型或者存储到本地，输出的数据如下，一共有3个键值对，包括2个摄像头的键值对和一个舵机关节位置的，可以看到将前面6个舵机的合并为一个键值对了。</p>
<div class="codehilite"><pre><span></span><code><span class="err">observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">_</span><span class="kc">fra</span><span class="err">me</span><span class="p">:</span>
<span class="p">{</span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.</span><span class="kc">f</span><span class="err">ixed'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w">  </span><span class="mi">55</span><span class="p">,</span><span class="w">  </span><span class="mi">61</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">73</span><span class="p">,</span><span class="w">  </span><span class="mi">48</span><span class="p">,</span><span class="w">  </span><span class="mi">54</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">68</span><span class="p">,</span><span class="w">  </span><span class="mi">48</span><span class="p">,</span><span class="w">  </span><span class="mi">49</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">62</span><span class="p">,</span><span class="w">  </span><span class="mi">82</span><span class="p">,</span><span class="w">  </span><span class="mi">73</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">69</span><span class="p">,</span><span class="w">  </span><span class="mi">89</span><span class="p">,</span><span class="w">  </span><span class="mi">80</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">73</span><span class="p">,</span><span class="w">  </span><span class="mi">90</span><span class="p">,</span><span class="w">  </span><span class="mi">82</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.ha</span><span class="kc">n</span><span class="err">deye'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="mi">67</span><span class="p">,</span><span class="w"> </span><span class="mi">78</span><span class="p">,</span><span class="w"> </span><span class="mi">72</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">72</span><span class="p">,</span><span class="w"> </span><span class="mi">83</span><span class="p">,</span><span class="w"> </span><span class="mi">77</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">69</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p">,</span><span class="w"> </span><span class="mi">75</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="mi">51</span><span class="p">,</span><span class="w"> </span><span class="mi">71</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">39</span><span class="p">,</span><span class="w"> </span><span class="mi">59</span><span class="p">,</span><span class="w">  </span><span class="mi">6</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">63</span><span class="p">,</span><span class="w">  </span><span class="mi">7</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.s</span><span class="kc">tate</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[</span><span class="mf">-10.490956</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">-98.657715</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">99.547104</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">54.177433</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">-3.5714285</span><span class="p">,</span>
<span class="w">         </span><span class="mf">2.6666667</span><span class="p">],</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">)</span><span class="p">}</span>
</code></pre></div>
<p>发送给机器人的动作数据，比较简单如下，也就是6个舵机的关节位置信息。</p>
<div class="codehilite"><pre><span></span><code><span class="err">se</span><span class="kc">nt</span><span class="err">_ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="p">:</span>
<span class="p">{</span><span class="err">'elbow_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">99.63685882886972</span><span class="p">,</span>
<span class="w"> </span><span class="err">'gripper.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">0.6509357200976403</span><span class="p">,</span>
<span class="w"> </span><span class="err">'shoulder_li</span><span class="kc">ft</span><span class="err">.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-99.36102236421725</span><span class="p">,</span>
<span class="w"> </span><span class="err">'shoulder_pa</span><span class="kc">n</span><span class="err">.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-10.0</span><span class="p">,</span>
<span class="w"> </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_</span><span class="kc">fle</span><span class="err">x.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">53.53886235345203</span><span class="p">,</span>
<span class="w"> </span><span class="err">'wris</span><span class="kc">t</span><span class="err">_roll.pos'</span><span class="p">:</span><span class="w"> </span><span class="mf">-3.598634095087988</span><span class="p">}</span>
</code></pre></div>
<p>存储录制数据时，需要遥控机器action_frame、观测机器abservation_frame（前面已经列出了），下面看看相关数据的格式。</p>
<p>action_frame是遥控机器的sent_action转换而来，调用action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")，实际上就是将sent_action数据6个键值对改为1个键值对。</p>
<div class="codehilite"><pre><span></span><code><span class="err">ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">_</span><span class="kc">fra</span><span class="err">me</span><span class="p">:</span>
<span class="p">{</span><span class="err">'ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[</span><span class="mf">-10.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">-99.36102</span><span class="w">  </span><span class="p">,</span><span class="w">  </span><span class="mf">99.636856</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">53.538864</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">-3.598634</span><span class="w"> </span><span class="p">,</span>
<span class="w">         </span><span class="mf">0.6509357</span><span class="p">],</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">)</span><span class="p">}</span>
</code></pre></div>
<p>最后将经过处理的一个遥控机器数据和经过处理的观测数据进行合并，最终得到如下4个键值对的数据。</p>
<div class="codehilite"><pre><span></span><code><span class="kc">fra</span><span class="err">me</span><span class="p">:</span>
<span class="p">{</span><span class="err">'ac</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[</span><span class="mf">-10.</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">-99.36102</span><span class="w">  </span><span class="p">,</span><span class="w">  </span><span class="mf">99.636856</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">53.538864</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">-3.598634</span><span class="w"> </span><span class="p">,</span>
<span class="w">         </span><span class="mf">0.6509357</span><span class="p">],</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.</span><span class="kc">f</span><span class="err">ixed'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="w"> </span><span class="mi">70</span><span class="p">,</span><span class="w">  </span><span class="mi">62</span><span class="p">,</span><span class="w">  </span><span class="mi">51</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">63</span><span class="p">,</span><span class="w">  </span><span class="mi">55</span><span class="p">,</span><span class="w">  </span><span class="mi">44</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">61</span><span class="p">,</span><span class="w">  </span><span class="mi">54</span><span class="p">,</span><span class="w">  </span><span class="mi">44</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">53</span><span class="p">,</span><span class="w">  </span><span class="mi">95</span><span class="p">,</span><span class="w">  </span><span class="mi">83</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">47</span><span class="p">,</span><span class="w">  </span><span class="mi">90</span><span class="p">,</span><span class="w">  </span><span class="mi">80</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">58</span><span class="p">,</span><span class="w"> </span><span class="mi">104</span><span class="p">,</span><span class="w">  </span><span class="mi">93</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.images.ha</span><span class="kc">n</span><span class="err">deye'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[[[</span><span class="mi">76</span><span class="p">,</span><span class="w"> </span><span class="mi">80</span><span class="p">,</span><span class="w"> </span><span class="mi">55</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">78</span><span class="p">,</span><span class="w"> </span><span class="mi">82</span><span class="p">,</span><span class="w"> </span><span class="mi">59</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">77</span><span class="p">,</span><span class="w"> </span><span class="mi">79</span><span class="p">,</span><span class="w"> </span><span class="mi">57</span><span class="p">],</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="err">...</span><span class="p">,</span>
<span class="w">        </span><span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">47</span><span class="p">,</span><span class="w"> </span><span class="mi">61</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">66</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">]]],</span><span class="w"> </span><span class="err">shape=(</span><span class="mi">480</span><span class="p">,</span><span class="w"> </span><span class="mi">640</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="err">)</span><span class="p">,</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=ui</span><span class="kc">nt</span><span class="mi">8</span><span class="err">)</span><span class="p">,</span>
<span class="w"> </span><span class="err">'observa</span><span class="kc">t</span><span class="err">io</span><span class="kc">n</span><span class="err">.s</span><span class="kc">tate</span><span class="err">'</span><span class="p">:</span><span class="w"> </span><span class="err">array(</span><span class="p">[</span><span class="mf">-10.490956</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">-98.657715</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">99.547104</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">54.177433</span><span class="w"> </span><span class="p">,</span><span class="w">  </span><span class="mf">-3.5714285</span><span class="p">,</span>
<span class="w">         </span><span class="mf">2.6666667</span><span class="p">],</span><span class="w"> </span><span class="err">d</span><span class="kc">t</span><span class="err">ype=</span><span class="kc">fl</span><span class="err">oa</span><span class="kc">t</span><span class="mi">32</span><span class="err">)</span><span class="p">}</span>
</code></pre></div>
<p><strong>可视化显示</strong></p>
<div class="codehilite"><pre><span></span><code>    <span class="c1"># 6. 可视化数据（若启用）</span>
    <span class="k">if</span> <span class="n">display_data</span><span class="p">:</span>
        <span class="n">log_rerun_data</span><span class="p">(</span><span class="n">observation</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>  <span class="c1"># 记录数据用于 Rerun 可视化</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2025/08/wp_editor_md_6f48aacc8f8cb50e0cf1732fb3e741c9.jpg"><img alt="" src="/assets/doc/04-ai/lerobot/lerobot数据采集与模型测试/images/wp_editor_md_6f48aacc8f8cb50e0cf1732fb3e741c9.jpg"/></a></p>
<p>可以看到界面显示的observation.xxx和action.xxx就是调用的这里log_rerun_data函数，理论上来说observation和action要越吻合越好，因为action是模型推理或主臂的动作，observation是实际的动作。</p>
<h2 id="_15">数据存储</h2>
<p>在上一节中，循序录制过程中，将经过处理的遥控机器数据action_frame和经过处理后的机器观测数据observation_frame合并得到的数据frame，然后先调用dataset.add_frame(frame, task=single_task)写入，最后调用save_episode方法将缓存数据写入磁盘。</p>
<h3 id="_16">写入缓存</h3>
<p>add_frame 是 LeRobotDataset 类的核心方法之一，负责将单帧机器人数据暂存到内存缓冲区（episode_buffer），并对图像数据进行预处理（如格式转换、临时存储）。该方法是数据录制流程中的关键环节，确保每帧数据符合数据集格式要求，并为后续的 save_episode 方法（将缓冲区数据写入磁盘）做准备。</p>
<div class="codehilite"><pre><span></span><code>   <span class="k">def</span> <span class="nf">add_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># 1. 数据格式转换PyTorch Tensor → NumPy 数组</span>
        <span class="c1"># 目的是统一数据格式为 NumPy 数组（数据集底层存储格式），避免因混合 Tensor/NumPy 类型导致后续处理异常。</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">frame</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

       <span class="c1">#2. 数据校验，确保帧格式符合数据集定义</span>
       <span class="c1">#检查 frame 中的所有特征（如 observation.state、action）</span>
        <span class="c1">#是否与 self.features 中定义的 dtype（数据类型）、shape</span>
        <span class="c1">#（维度）一致。例如，若 self.features 定义 action 为 </span>
        <span class="c1">#float32 且形状为 (6,)，则校验 frame["action"] 是否满足这些</span>
        <span class="c1">#条件，确保数据规范性。</span>
        <span class="n">validate_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>

        <span class="c1">#3. 如果没有初始化 episode 缓冲区，则初始化创建</span>
        <span class="c1"># 内存缓冲区，用于累积当前 episode 的所有帧数据。结构</span>
        <span class="c1">#与 self.features 对应，例如包含 observation.state、</span>
        <span class="c1">#action、timestamp 等键，每个键的值为列表（按帧顺序存</span>
        <span class="c1">#储数据）</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_episode_buffer</span><span class="p">()</span>

        <span class="c1"># 4. 记录帧索引与时间戳</span>
        <span class="c1"># 未提供 timestamp，默认按帧率（self.fps）计算相对时间</span>
        <span class="c1">#（如 30 FPS 时，第 0 帧为 0s，第 1 帧为 1/30 ≈0.033s），确保时间序列连续性</span>
        <span class="n">frame_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"size"</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">frame_index</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fps</span>
        <span class="c1"># 记录存储frame_index，timestamp，task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"frame_index"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"timestamp"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"task"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="c1"># 5. 添加一帧数据到episode_buffer</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"An element of the frame is not in the features. '</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">' not in '</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">'."</span>
                <span class="p">)</span>
           <span class="c1"># 如果是图像，处理追加到数据缓冲区</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">"dtype"</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"image"</span><span class="p">,</span> <span class="s2">"video"</span><span class="p">]:</span>
                <span class="n">img_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_image_file_path</span><span class="p">(</span>
                    <span class="n">episode_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"episode_index"</span><span class="p">],</span> <span class="n">image_key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">frame_index</span><span class="o">=</span><span class="n">frame_index</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">frame_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">img_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1">#通过 _get_image_file_path 生成标准化路径，调用存储图片,可同步可异步。</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_image</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">img_path</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">img_path</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  如果是动作特征数据直接追加到原始数据缓冲区</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
       <span class="c1">#6. 最后更新缓冲区大小</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"size"</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
<p>add_frame 是机器人数据录制的“数据暂存中枢”，通过内存缓冲区累积帧数据、预处理图像并校验数据格式，为后续持久化存储奠定基础。其设计兼顾了录制效率（异步图像写入）和数据可靠性（格式校验），是构建标准化机器人数据集的核心环节，其设计，总结有以下优点：</p>
<ul>
<li>数据暂存与累积：通过 episode_buffer 在内存中临时存储一整段 episode 的数据，避免频繁磁盘 I/O 影响录制帧率。</li>
<li>图像预处理解耦：将图像保存与数据记录分离，支持异步图像写入（AsyncImageWriter），确保主录制循环（record_loop）不受图像存储速度影响，维持稳定帧率。</li>
<li>数据一致性校验：通过 validate_frame 提前过滤无效数据，避免错误数据进入后续流程（如 save_episode 写入磁盘）</li>
</ul>
<h3 id="_17">写入磁盘</h3>
<p>录制完一轮，会调用dataset.save_episode()进行存储写入磁盘。</p>
<div class="codehilite"><pre><span></span><code>   <span class="k">def</span> <span class="nf">save_episode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">episode_data</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#1. 输入处理与数据校验</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">episode_data</span><span class="p">:</span>
            <span class="n">episode_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span> <span class="c1">#使用内存缓冲区数据（默认流程）</span>
        <span class="c1">#校验缓冲区数据的完整性，确保所有特征（如 </span>
        <span class="c1">#observation.state、action）的长度一致（与 episode 总帧</span>
        <span class="c1">#数匹配），且 episode_index 未超出当前数据集范围</span>
        <span class="n">validate_episode_buffer</span><span class="p">(</span><span class="n">episode_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">total_episodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>

        <span class="c1"># 2.从缓冲区中提取非特征数据（这些键不直接存储到 Parquet）</span>
        <span class="n">episode_length</span> <span class="o">=</span> <span class="n">episode_buffer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"size"</span><span class="p">)</span><span class="c1"># 当前 episode 的总帧数</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">episode_buffer</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"task"</span><span class="p">)</span><span class="c1"># 每帧的任务标签列表（可能重复）</span>
        <span class="n">episode_tasks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span><span class="c1"># 当前 episode 涉及的唯一任务列表</span>
        <span class="n">episode_index</span> <span class="o">=</span> <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"episode_index"</span><span class="p">]</span> <span class="c1"># 当前 episode 的索引</span>
        <span class="c1">#3. 构建全局索引与episode标识，确保每帧在整个数据集中有唯一标识，便于后续数据加载时定位。</span>
        <span class="c1"># 生成全局帧索引（从数据集总帧数开始累加）</span>
        <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"index"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">total_frames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">total_frames</span> <span class="o">+</span> <span class="n">episode_length</span><span class="p">)</span>
        <span class="c1">#生成 episode_index 数组（所有帧均属于当前 episode）</span>
        <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"episode_index"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">episode_length</span><span class="p">,),</span> <span class="n">episode_index</span><span class="p">)</span>

        <span class="c1"># 4. 任务标签处理与元数据更新</span>
        <span class="c1"># 添加新任务到元数据（若任务不存在）</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">episode_tasks</span><span class="p">:</span>
            <span class="n">task_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get_task_index</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">task_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="n">task</span><span class="p">)</span><span class="c1"># 新增任务并更新 tasks.jsonl</span>

        <span class="c1"># 生成 task_index 数组（将每帧的任务标签映射为整数索引）</span>
        <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"task_index"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get_task_index</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">])</span>
        <span class="c1"># 5.数值特征数据格式化</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ft</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># 跳过索引类特征、图像和视频（这些由其他逻辑处理）</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"index"</span><span class="p">,</span> <span class="s2">"episode_index"</span><span class="p">,</span> <span class="s2">"task_index"</span><span class="p">]</span> <span class="ow">or</span> <span class="n">ft</span><span class="p">[</span><span class="s2">"dtype"</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"image"</span><span class="p">,</span> <span class="s2">"video"</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="c1"># 将列表形式的帧数据堆叠为二维数组（shape: [episode_length, feature_dim]）</span>
            <span class="n">episode_buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">episode_buffer</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
          <span class="c1">#若 action 特征为长度 6 的向量，episode_buffer["action"] </span>
        <span class="c1"># 会从 [ [a0], [a1], ..., [aN] ] 堆叠为 [ [a0_0, ..., a0_5], ..., [aN_0, ..., aN_5] ]，符合 Parquet 存储格式。</span>

        <span class="c1">#6. 等待异步图像写入完成</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_image_writer</span><span class="p">()</span><span class="c1"># 确保所有临时图像文件已写入磁盘</span>
        <span class="c1"># 保存数值到Parquet文件</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_episode_table</span><span class="p">(</span><span class="n">episode_buffer</span><span class="p">,</span> <span class="n">episode_index</span><span class="p">)</span>
        <span class="n">ep_stats</span> <span class="o">=</span> <span class="n">compute_episode_stats</span><span class="p">(</span><span class="n">episode_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
          <span class="c1"># _save_episode_table 行为</span>
          <span class="c1">#      从缓冲区提取特征数据，构造 datasets.Dataset 对象。</span>
          <span class="c1">#      将数据写入 Parquet 文件（路径由元数据的 get_data_file_path 生成，如 data/chunk-000/episode_000000.parquet）。</span>
          <span class="c1">#      更新内存中的 hf_dataset（拼接新 episode 数据）。</span>

        <span class="c1">#8. 若启用视频模式，将图像编码存储为视频文件</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">video_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">video_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_episode_videos</span><span class="p">(</span><span class="n">episode_index</span><span class="p">)</span> <span class="c1"># 将临时图像编码为 MP4</span>
    <span class="c1">#调用 ffmpeg 将临时目录下的图像帧（如 images/observation.images.laptop/episode_000000/frame_*.png）</span>
    <span class="c1">#编码为 MP4 视频，存储路径由元数据的 get_video_file_path 定义</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">video_keys</span><span class="p">:</span>
                <span class="n">episode_buffer</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">video_paths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># 记录视频文件路径</span>

        <span class="c1"># `meta.save_episode` be executed after encoding the videos</span>

        <span class="c1">#9. 更新元数据与校验时间戳</span>
        <span class="c1"># 更新元数据（总 episodes、总 frames、chunks 等）</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">save_episode</span><span class="p">(</span><span class="n">episode_index</span><span class="p">,</span> <span class="n">episode_length</span><span class="p">,</span> <span class="n">episode_tasks</span><span class="p">,</span> <span class="n">ep_stats</span><span class="p">)</span>
        <span class="c1"># 校验时间戳连续性（确保帧间隔符合帧率 1/fps ± tolerance_s）</span>
        <span class="n">ep_data_index</span> <span class="o">=</span> <span class="n">get_episode_data_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">episodes</span><span class="p">,</span> <span class="p">[</span><span class="n">episode_index</span><span class="p">])</span>
        <span class="n">ep_data_index_np</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ep_data_index</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">check_timestamps_sync</span><span class="p">(</span>
            <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"timestamp"</span><span class="p">],</span><span class="c1"># 帧时间戳数组</span>
            <span class="n">episode_buffer</span><span class="p">[</span><span class="s2">"episode_index"</span><span class="p">],</span><span class="c1"># episode 索引数组</span>
            <span class="n">ep_data_index_np</span><span class="p">,</span><span class="c1"># episode 帧范围</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span><span class="c1"># 帧率</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance_s</span><span class="p">,</span><span class="c1"># 时间容差</span>
        <span class="p">)</span>
       <span class="c1">#10. 文件完整性校验与资源清理</span>
       <span class="c1"># 验证视频文件数量（每个 episode × 每个视频 key 应对应一个 MP4）</span>
        <span class="n">video_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">"*.mp4"</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">video_files</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_episodes</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">video_keys</span><span class="p">)</span>
       <span class="c1"># 验证 Parquet 文件数量（每个 episode 对应一个 Parquet）</span>
        <span class="n">parquet_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">"*.parquet"</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parquet_files</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_episodes</span>

        <span class="c1"># 删除临时图像目录（已编码为视频，无需保留）</span>
        <span class="n">img_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">/</span> <span class="s2">"images"</span>
        <span class="k">if</span> <span class="n">img_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">/</span> <span class="s2">"images"</span><span class="p">)</span>
        <span class="c1"># 重置缓冲区，准备下一段 episode 录制</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">episode_data</span><span class="p">:</span>  <span class="c1"># Reset the buffer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">episode_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_episode_buffer</span><span class="p">()</span>
</code></pre></div>
<p>save_episode 是 LeRobotDataset 类的核心方法，负责将内存缓冲区（episode_buffer）中累积的单段 episode 数据持久化到磁盘，同时更新元数据、生成视频文件、校验数据完整性，并重置缓冲区以准备下一段录制。该方法是数据录制流程的“收尾环节”，确保每段 episode 数据符合 LeRobot 数据集格式规范。主要功能如下：</p>
<ul>
<li>数据持久化：将内存中的帧数据（数值特征、图像路径）写入 Parquet 文件（结构化数据）和 MP4 文件（视频数据）。</li>
<li>元数据更新：更新数据集元信息（如总 episode 数、总帧数、任务标签），确保元数据与实际数据一致。</li>
<li>数据校验：验证时间戳连续性、文件完整性（如视频/Parquet 文件数量匹配预期），避免无效数据入库。</li>
<li>资源清理：删除临时图像文件（已编码为视频），释放内存缓冲区。</li>
</ul>
<p>save_episode 是 LeRobot 数据集录制的“最终执行者”，通过系统化的数据格式化、编码、校验和清理，将内存中的临时帧数据转化为符合规范的磁盘存储，同时维护元数据一致性和数据完整性。其设计确保了录制数据的可靠性、存储效率和下游可用性，是连接实时录制与离线数据使用的关键桥梁。</p>
<h2 id="_18">结束采集</h2>
<div class="codehilite"><pre><span></span><code><span class="n">log_say</span><span class="p">(</span><span class="s2">"Stop recording"</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">play_sounds</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># 语音提示结束录制</span>
<span class="n">robot</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>  <span class="c1"># 断开机器人连接（禁用扭矩，确保安全）</span>
<span class="k">if</span> <span class="n">teleop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">teleop</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>  <span class="c1"># 断开遥操作器连接</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">is_headless</span><span class="p">()</span> <span class="ow">and</span> <span class="n">listener</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">listener</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>  <span class="c1"># 停止键盘监听器</span>
</code></pre></div>
<p>断开设备，停止键盘监听。</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">push_to_hub</span><span class="p">:</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">push_to_hub</span><span class="p">(</span><span class="n">tags</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span> <span class="n">private</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">private</span><span class="p">)</span>  <span class="c1"># 上传数据集到 Hugging Face Hub</span>
</code></pre></div>
<p>将数据上传到hugging Face Hub上。</p></div>
  <div class="post-nav">
    <a class="prev" href="/lerobot训练.html">← lerobot训练</a>
    <a class="next" href="/python补习.html">python补习 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/assets/site.js"></script>
  </body>
  </html>

