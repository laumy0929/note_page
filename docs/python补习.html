<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>python补习 - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">首页</a></div>
          <div class="nav-item site-link">
            <a href="https://www.laumy.tech" target="_blank" title="访问主站">主站点:www.laumy.tech</a>
          </div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">装饰器</a><ul><li><a href="#_2">函数装饰器</a></li><li><a href="#_6">类装饰器</a></li></ul></li><li><a href="#_8">函数返回类型注解</a><ul><li><a href="#_9">容器类型</a></li><li><a href="#_10">组合类型</a></li><li><a href="#_11">特殊类型</a></li></ul></li><li><a href="#_12">配置选择注册机制</a><ul><li><a href="#_13">注册与选择流程</a></li></ul></li><li><a href="#_14">动作先行思维</a><ul><li><a href="#a-if-cond-else-b">A if cond else B</a></li><li><a href="#or">or短路运算</a></li><li><a href="#for">for循环</a></li><li><a href="#_15">列表推导式</a></li><li><a href="#_16">字典推导式</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>python补习</h1>
  <div class="meta">
    <span class="meta-item">
      <i class="icon">🕒</i>
      2025-07-29
    </span>
    <span class="meta-item">
      <i class="icon">📂</i>
      语言
    </span>
    <span class="meta-item">
      <i class="icon">👤</i>
      laumy
    </span>
  </div>
  <div class="post-content"><h2 id="_1">装饰器</h2>
<h3 id="_2">函数装饰器</h3>
<h4 id="_3">什么是装饰器</h4>
<p>装饰器是python的一种高级语法，本质上是函数包装器，可以在不修改函数代码的前提下为函数添加额外功能如日志记录、性能计时、权限校验，也可以修改函数的输入和输出。装饰器通过@装饰器名语法应用与函数，也是一种语法糖，简化包装的代码。</p>
<h4 id="_4">基本语法与原理</h4>
<p>装饰器是一个<strong>接收函数</strong>作为参数，并<strong>返回新函数</strong>的函数。当用@decorator修饰函数func时，相当于执行func=decorator(func)，即原函数被替换为装饰器返回的新函数。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 定义装饰器：打印函数调用信息</span>
<span class="k">def</span> <span class="nf">log_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"调用函数: </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>  <span class="c1"># 额外功能：打印日志</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>      <span class="c1"># 执行原函数</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"函数 </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> 执行完毕"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>                       <span class="c1"># 返回原函数结果</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># 应用装饰器</span>
<span class="nd">@log_decorator</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># 调用函数</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>上面打印的输出为</p>
<div class="codehilite"><pre><span></span><code><span class="n">调用函数</span><span class="p">:</span> <span class="n">add</span>
<span class="n">函数</span> <span class="n">add</span> <span class="n">执行完毕</span>
<span class="mi">3</span>
</code></pre></div>
<p>可以看到，相当于给add函数做了一层包装。这里 log_decorator 为 add 函数添加了“调用日志”功能，原 add 函数代码未做任何修改。</p>
<h4 id="_5">带参数的装饰器</h4>
<p>如果装饰器需要自定义参数（如 @parser.wrap() 中的空括号），需在基础装饰器外再嵌套一层<strong>参数接收函数</strong>。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 带参数的装饰器：自定义日志前缀</span>
<span class="k">def</span> <span class="nf">log_decorator</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">"LOG"</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">] 调用函数: </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>  <span class="c1"># 使用装饰器参数</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="c1"># 应用装饰器（传递参数）</span>
<span class="nd">@log_decorator</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">"DEBUG"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 输出: [DEBUG] 调用函数: multiply → 返回 12</span>
</code></pre></div>
<p>装饰器在 Python 中非常常用，典型场景包括：</p>
<ul>
<li>日志记录：自动记录函数调用、参数、返回值；</li>
<li>性能计时：统计函数执行时间；</li>
<li>权限校验：检查用户是否有权限调用函数；</li>
<li>输入/输出处理：自动转换参数类型、格式化返回值；</li>
<li>资源管理：自动打开/关闭文件、数据库连接等。</li>
</ul>
<h3 id="_6">类装饰器</h3>
<p>前面描述了函数装饰器，还有类的装饰器。类的装饰器是通过修改类的定义、<strong>添加/覆盖方法或属性，或返回一个新类</strong>，来增强类的功能，与函数装饰器（修饰函数）不同，类装饰器专注于修饰类本身。类装饰器通过 @装饰器名 语法应用于类，是一种“语法糖”，简化了类的动态修改逻辑。</p>
<p>类装饰器是一个接收类作为参数，并返回新类的函数。当用 @decorator 修饰类 MyClass 时，相当于执行 MyClass = decorator(MyClass)，即原类被“替换”为装饰器返回的新类。</p>
<h4 id="_7">简单类装饰器示例</h4>
<div class="codehilite"><pre><span></span><code><span class="c1"># 定义类装饰器：为类添加一个属性和方法</span>
<span class="k">def</span> <span class="nf">add_greeting</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">greeting</span> <span class="o">=</span> <span class="s2">"Hello from decorator!"</span>  <span class="c1"># 新添加类属性</span>

    <span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 新定义要添加的实例方法</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">greeting</span><span class="si">}</span><span class="s2"> I'm </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">."</span>

    <span class="bp">cls</span><span class="o">.</span><span class="n">say_hello</span> <span class="o">=</span> <span class="n">say_hello</span>  <span class="c1"># 将方法绑定到类</span>
    <span class="k">return</span> <span class="bp">cls</span>  <span class="c1"># 返回修改后的类</span>

<span class="c1"># 应用装饰器</span>
<span class="nd">@add_greeting</span>
<span class="k">class</span> <span class="nc">Person</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># 使用装饰后的类</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="s2">"Alice"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">greeting</span><span class="p">)</span>       <span class="c1"># 输出：Hello from decorator!</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">say_hello</span><span class="p">())</span>    <span class="c1"># 输出：Hello from decorator! I'm Alice.</span>
</code></pre></div>
<h4 id="dataclass">内置装饰器@dataclass</h4>
<p>@dataclass 是 Python 标准库 dataclasses 提供的内置类装饰器，用于快速定义数据存储类（Data Class），核心作用是：</p>
<ul>
<li>自动生成 <strong>init</strong> 方法：无需手动编写 def <strong>init</strong>(self, robot, dataset, ...): ...，装饰器会根据类字段自动生成。</li>
<li>自动生成 <strong>repr</strong>、<strong>eq</strong> 等方法：方便打印实例（如 print(cfg)）和比较实例是否相等。</li>
<li>支持字段默认值和类型注解：如 teleop: TeleoperatorConfig | None = None 中的默认值和类型约束。</li>
</ul>
<p>先来看看如果不适用@dataclass装饰器，定义一个普通的类，需要手动编写<strong>init</strong>，<strong>repr</strong>等方法，如下</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">DatasetConfig</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_episodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span> <span class="o">=</span> <span class="n">repo_id</span>  <span class="c1"># 手动绑定 self.xxx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_episodes</span> <span class="o">=</span> <span class="n">num_episodes</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 手动编写打印逻辑</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"DatasetConfig(repo_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span><span class="si">!r}</span><span class="s2">, num_episodes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_episodes</span><span class="si">!r}</span><span class="s2">)"</span>

<span class="c1"># 使用</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="n">DatasetConfig</span><span class="p">(</span><span class="s2">"aliberts/record-test"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>  <span class="c1"># 输出：DatasetConfig(repo_id='aliberts/record-test', num_episodes=2)</span>
</code></pre></div>
<p>如果使用了@dataclass，则不需要编写<strong>init</strong>等方法，但是需要添加属性的类型注解声明，如下面repo_id，num_episodes。如果有默认值的，如下的int=50,可选传递参数，如果没有默认值的，必现要传递参数如repo_id。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DatasetConfig</span><span class="p">:</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># 必选字段（无默认值）</span>
    <span class="n">num_episodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># 可选字段（默认值 50）</span>

<span class="c1"># 使用（效果与普通类完全一致）</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="n">DatasetConfig</span><span class="p">(</span><span class="s2">"aliberts/record-test"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>  <span class="c1"># 自动生成 __repr__：DatasetConfig(repo_id='aliberts/record-test', num_episodes=2)</span>
</code></pre></div>
<p>@dataclass提供初始化后回调方法，在<strong>init</strong>执行完毕后自动调用，用于字段校验，动态修改字段值等。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DatasetConfig</span><span class="p">:</span>
    <span class="n">repo_id</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># 必选字段（无默认值）</span>
    <span class="n">num_episodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># 可选字段（默认值 50）</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repo_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"You need to provide a repo_id as argument."</span><span class="p">)</span>
</code></pre></div>
<h2 id="_8">函数返回类型注解</h2>
<p>函数返回类型注解是python 3.0+引入的类型提示语法，用于显式声明函数预期返回值的类型。它不会改变函数的运行逻辑，只是为了提升代码的可读性、支持IDE智能提示，便于静态代码检查工具检测潜在错误。其语法格式为如下：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">函数名</span><span class="p">(</span><span class="n">参数</span><span class="p">:</span> <span class="n">参数类型</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">返回值类型</span><span class="p">:</span>
    <span class="c1"># 函数逻辑</span>
    <span class="k">return</span> <span class="n">返回值</span>
</code></pre></div>
<p>返回类型注解通过<strong>-&gt;</strong>类型语法声明，位于函数定义参数列表之后、冒号：之前。</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="n">cfg</span><span class="p">:</span> <span class="n">RecordConfig</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LeRobotDataset</span><span class="p">:</span>
    <span class="c1"># ... 函数逻辑 ...</span>
    <span class="k">return</span> <span class="n">dataset</span>  <span class="c1"># dataset 是 LeRobotDataset 实例</span>
</code></pre></div>
<p>这里 -&gt; LeRobotDataset 表示：record 函数执行完毕后，预期返回一个 LeRobotDataset 类的实例。</p>
<p>注解都有哪些类型了，除了基础的int、float、str、bool、None（空）这几个类型外，还有容器类型、组合类型、特殊类型等。</p>
<h3 id="_9">容器类型</h3>
<p><strong>列表</strong>，list[值类型] ，用于标注列表、字典、元组等容器的元素类型，Python 3.9+ 支持直接用 list[int] 形式，旧版本需从 typing 模块导入（如 List[int]）。</p>
<div class="codehilite"><pre><span></span><code><span class="n">motor_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"shoulder_pan"</span><span class="p">,</span> <span class="s2">"elbow_flex"</span><span class="p">]</span>  <span class="c1"># 字符串列表</span>
<span class="n">positions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">]</span>  <span class="c1"># 浮点数列表</span>
</code></pre></div>
<p><strong>字典</strong>，dict[键类型, 值类型]如下示例</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">_motors_ft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">]:</span>  <span class="c1"># 键为字符串，值为类型对象（如 float）</span>
    <span class="k">return</span> <span class="p">{</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">motor</span><span class="si">}</span><span class="s2">.pos"</span><span class="p">:</span> <span class="nb">float</span> <span class="k">for</span> <span class="n">motor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bus</span><span class="o">.</span><span class="n">motors</span><span class="p">}</span>
</code></pre></div>
<p><strong>元组</strong>，tuple[类型1, 类型2, ...]，如下示例：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">_cameras_ft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>  <span class="c1"># 值为元组（高、宽、通道数）</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">cam</span><span class="p">:</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">}</span>
<span class="c1"># 更精确标注：tuple[int, int, int]（高、宽、3通道）</span>
</code></pre></div>
<p><strong>集合类型</strong>，set[元素类型]，如下示例唯一电机ID集合。</p>
<div class="codehilite"><pre><span></span><code><span class="n">motor_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>  <span class="c1"># 整数集合</span>
</code></pre></div>
<h3 id="_10">组合类型</h3>
<p><strong>Union</strong>,Union[类型1, 类型2, ...],允许整数或字符串的参数</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="k">def</span> <span class="nf">get_motor</span><span class="p">(</span><span class="n">motor_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Motor</span><span class="p">:</span>  <span class="c1"># motor_id 可为 int 或 str</span>
    <span class="o">...</span>
<span class="c1"># Python 3.10+ 简写：</span>
<span class="k">def</span> <span class="nf">get_motor</span><span class="p">(</span><span class="n">motor_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Motor</span><span class="p">:</span>
    <span class="o">...</span>
</code></pre></div>
<p><strong>Option</strong>，Optional[类型]，（等价于 Union[类型, None]），可能为None的配置参数。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">port</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># port 可为字符串或 None</span>
    <span class="o">...</span>
</code></pre></div>
<h3 id="_11">特殊类型</h3>
<p><strong>Any</strong>，任意类型，关闭类型检查，允许任何类型（常用于动态数据，如lerobot代码中 get_observation 返回 dict[str, Any]）</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="k">def</span> <span class="nf">get_observation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>  <span class="c1"># 值可为任意类型（电机位置/图像等）</span>
    <span class="o">...</span>
</code></pre></div>
<p><strong>Callable</strong>，Callable[[参数类型1, 参数类型2], 返回值类型]，接受函数作为参数。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">calibrate</span><span class="p">(</span><span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># callback 是 (str) -&gt; None 的函数</span>
    <span class="n">callback</span><span class="p">(</span><span class="s2">"Calibration done"</span><span class="p">)</span>
</code></pre></div>
<p><strong>type</strong>,Type[类型]（标注“类型本身”而非实例，如lerobot代码中 dict[str, type]）,接受类作为参数。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span>

<span class="k">def</span> <span class="nf">create_robot</span><span class="p">(</span><span class="n">robot_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Robot</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Robot</span><span class="p">:</span>  <span class="c1"># robot_class 是 Robot 的子类</span>
    <span class="k">return</span> <span class="n">robot_class</span><span class="p">()</span>
</code></pre></div>
<h2 id="_12">配置选择注册机制</h2>
<p>以draccus.ChoiceRegistry为例说明，draccus.ChoiceRegistry 是 draccus 配置框架提供的子类注册与动态选择机制。它允许将基类的多个子类注册为“可选选项”，并通过配置参数（如命令行、配置文件）动态选择具体子类。在工程中，这一机制用于实现 “同一接口，多种实现” 的灵活配置（例如不同机器人型号共享 RobotConfig 接口，但有各自的硬件参数实现）。</p>
<h3 id="_13">注册与选择流程</h3>
<p><strong>1. 基类：继承ChoiceRegistry并声明接口</strong>。如示例基类（如 RobotConfig）继承 draccus.ChoiceRegistry，作为所有子类的“公共接口”。它定义通用字段和方法，不包含具体实现细节。</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">draccus</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">RobotConfig</span><span class="p">(</span><span class="n">draccus</span><span class="o">.</span><span class="n">ChoiceRegistry</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>  <span class="c1"># 继承 ChoiceRegistry</span>
    <span class="c1"># 通用字段（所有子类共享）</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 机器人标识</span>
    <span class="n">calibration_dir</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 校准文件路径</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 获取当前子类的注册名称（核心方法）</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_choice_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
</code></pre></div>
<p><strong>2. 子类：注册为可选项</strong>。每个具体实现（如不同机器人型号）定义一个 RobotConfig 的子类，补充特有字段和逻辑。draccus 会自动将子类注册为一个可选选项，如下：</p>
<p>例如，so101_follower 机器人的配置子类：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># SO101FollowerConfig（so101_follower 型号）</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SO101FollowerConfig</span><span class="p">(</span><span class="n">RobotConfig</span><span class="p">):</span>
    <span class="n">port</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># 型号特有字段（通信端口）</span>
    <span class="n">disable_torque_on_disconnect</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># 型号特有字段（扭矩控制）</span>

<span class="c1"># KochFollowerConfig（koch_follower 型号）</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">KochFollowerConfig</span><span class="p">(</span><span class="n">RobotConfig</span><span class="p">):</span>
    <span class="n">ip_address</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># 型号特有字段（以太网通信地址）</span>
    <span class="n">timeout_ms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span>  <span class="c1"># 型号特有字段（通信超时）</span>
</code></pre></div>
<p>SO101FollowerConfig/KochFollowerConfig继承了RobotConfig，而RobotConfig继承了draccus.ChoiceRegistry。</p>
<p><strong>3. 动态选择：通过配置参数指定子类</strong>。用户通过配置参数（如命令行 --robot.type=so101_follower）指定要使用的子类。draccus 会：</p>
<ul>
<li>根据参数值（so101_follower）查找注册的子类；</li>
<li>实例化该子类，并将其他配置参数（如 --robot.port=/dev/ttyACM1）映射到子类字段；</li>
<li>返回实例化后的子类对象，作为业务逻辑的输入。</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c1"># 命令行参数示例</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">lerobot</span><span class="o">.</span><span class="n">record</span> \
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">type</span><span class="o">=</span><span class="n">so101_follower</span> \  <span class="c1"># 选择 SO101FollowerConfig 子类</span>
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">id</span><span class="o">=</span><span class="n">black</span> \             <span class="c1"># 设置通用字段 id</span>
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">port</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyACM0</span> \    <span class="c1"># 设置型号特有字段 port</span>
  <span class="o">--</span><span class="n">robot</span><span class="o">.</span><span class="n">disable_torque_on_disconnect</span><span class="o">=</span><span class="n">true</span>  <span class="c1"># 设置型号特有字段</span>
</code></pre></div>
<h2 id="_14">动作先行思维</h2>
<p>C语言的风格是写法是条件先行，再写动作。而python支持动作先行写法，再补充条件，主要是为了简写。请看下面示例。</p>
<h3 id="a-if-cond-else-b">A if cond else B</h3>
<div class="codehilite"><pre><span></span><code><span class="c1"># 简洁写法（条件表达式）</span>
<span class="n">teleop</span> <span class="o">=</span> <span class="n">make_teleoperator_from_config</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span><span class="p">)</span> <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

<span class="c1"># 等价传统写法（if-else 块）</span>
<span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">teleop</span> <span class="o">=</span> <span class="n">make_teleoperator_from_config</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">teleop</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">teleop</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div>
<p>使用的简洁方法是： A if cond else B。</p>
<h3 id="or">or短路运算</h3>
<div class="codehilite"><pre><span></span><code><span class="c1"># 例：若 config_path 为空，则默认使用 "./config.json"</span>
<span class="n">config_path</span> <span class="o">=</span> <span class="n">user_provided_path</span> <span class="ow">or</span> <span class="s2">"./config.json"</span>
</code></pre></div>
<h3 id="for">for循环</h3>
<p>C 的 for 循环强调“初始化→条件→增量”的控制流，而 Python 的 for 更关注“迭代对象→元素处理”，动作（循环体）直接跟在迭代逻辑后。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 例：遍历数据集并处理每个帧</span>
<span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
    <span class="n">process_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>  <span class="c1"># 动作（循环体）直接跟在迭代逻辑后</span>
</code></pre></div>
<p>Python 无需显式初始化索引、判断终止条件或手动增量（如 i++），迭代逻辑由“可迭代对象”（如列表、字典、生成器）内部处理。</p>
<h3 id="_15">列表推导式</h3>
<p>结构是列表推导式：[表达式 for 变量 in 可迭代对象 if 条件]</p>
<p>Python 的列表推导式将“对元素的处理动作”放在最前面，直接表达“要生成什么样的列表”，而非 C 中“如何生成列表”的步骤式逻辑。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 例：筛选偶数并计算平方（动作：x**2，条件：x%2==0）</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1"># 结果：[0, 4, 16, 36, 64]</span>
</code></pre></div>
<p>结构拆解：</p>
<ul>
<li>动作:（x**2）,定义每个元素的转换方式（先明确“要做什么”）；</li>
<li>迭代逻辑:（for x in range(10)）,从哪里获取元素；</li>
<li>条件:(if x\%2 =\= 0),筛选元素的规则,后补充限制条件。</li>
</ul>
<p>也可以直接做赋值，看下面例子</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Example</span><span class="p">:</span>
    <span class="n">src</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">tgt</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">收集列表直接赋值为data</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">Example</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">paris</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">等价于</span>

<span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">src_ids</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">tgt_idg</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Example</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
</code></pre></div>
<h3 id="_16">字典推导式</h3>
<p>核心逻辑是：{新键: 新值 for 键, 值 in 迭代器 if 条件}</p>
<p>先定义“键和值的生成动作”，再说明迭代范围和筛选规则，适用于快速构建字典。示例：将遥操作器原始动作（如 {"shoulder": 0.2, "gripper": 0.9}）转换为带前缀的数据集格式：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 原始遥操作动作</span>
<span class="n">teleop_action</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"shoulder"</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s2">"elbow"</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">"gripper"</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">}</span>

<span class="c1"># 字典推导式：先定义键值动作（添加前缀），再迭代</span>
<span class="n">dataset_action</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sa">f</span><span class="s2">"action.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">"</span><span class="p">:</span> <span class="n">value</span>  <span class="c1"># 动作：键添加前缀，值保持不变</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">teleop_action</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>  <span class="c1"># 迭代范围：遥操作动作字典</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">"gripper"</span>  <span class="c1"># 筛选条件：排除 gripper（假设无需记录）</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="n">dataset_action</span><span class="p">)</span> 
<span class="c1"># 输出：{"action.shoulder": 0.2, "action.elbow": 0.5}</span>
</code></pre></div>
<p>再来看看几个例子：</p>
<div class="codehilite"><pre><span></span><code>    <span class="n">features</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">joint_fts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">ftype</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">ftype</span> <span class="ow">in</span> <span class="n">hw_features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">ftype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">}</span>
</code></pre></div>
<p>遍历 hw_features 的所有键值对（key, ftype），仅保留 值为 float 类型 的键值对（即电机角度等浮点型特征）。若hw_features 含 {"shoulder.pos": float, "camera": (480,640,3)}，则 joint_fts 为 {"shoulder.pos": float}。函数的作用就是筛选电机特征。实际打印如下：</p>
<div class="codehilite"><pre><span></span><code><span class="n">joint_fts</span> <span class="p">:</span> <span class="p">{</span><span class="s1">'shoulder_pan.pos'</span><span class="p">:</span> <span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">float</span><span class="s1">'&gt;, '</span><span class="n">shoulder_lift</span><span class="o">.</span><span class="n">pos</span><span class="s1">': &lt;class '</span><span class="nb">float</span><span class="s1">'&gt;, '</span><span class="n">elbow_flex</span><span class="o">.</span><span class="n">pos</span><span class="s1">': &lt;class '</span><span class="nb">float</span><span class="s1">'&gt;, '</span><span class="n">wrist_flex</span><span class="o">.</span><span class="n">pos</span><span class="s1">': &lt;class '</span><span class="nb">float</span><span class="s1">'&gt;, '</span><span class="n">wrist_roll</span><span class="o">.</span><span class="n">pos</span><span class="s1">': &lt;class '</span><span class="nb">float</span><span class="s1">'&gt;, '</span><span class="n">gripper</span><span class="o">.</span><span class="n">pos</span><span class="s1">': &lt;class '</span><span class="nb">float</span><span class="s1">'&gt;}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code>    <span class="n">cam_fts</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">hw_features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)}</span>
</code></pre></div>
<p>遍历 hw_features，仅保留 值为元组类型 的键值对（即相机尺寸等元组特征，如 (高, 宽, 通道数)）。示例：若 hw_features 含 {"camera": (480,640,3)}，则 cam_fts 为 {"camera": (480,640,3)}。函数的作用就是筛选相机特征。</p>
<div class="codehilite"><pre><span></span><code><span class="n">cam_fts</span> <span class="p">:</span> <span class="p">{</span><span class="s1">'handeye'</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">'fixed'</span><span class="p">:</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span>
<span class="n">Action</span> <span class="n">Features</span><span class="p">:</span> <span class="p">{</span><span class="s1">'action'</span><span class="p">:</span> <span class="p">{</span><span class="s1">'dtype'</span><span class="p">:</span> <span class="s1">'float32'</span><span class="p">,</span> <span class="s1">'shape'</span><span class="p">:</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span> <span class="s1">'names'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'shoulder_pan.pos'</span><span class="p">,</span> <span class="s1">'shoulder_lift.pos'</span><span class="p">,</span> <span class="s1">'elbow_flex.pos'</span><span class="p">,</span> <span class="s1">'wrist_flex.pos'</span><span class="p">,</span> <span class="s1">'wrist_roll.pos'</span><span class="p">,</span> <span class="s1">'gripper.pos'</span><span class="p">]}}</span>
</code></pre></div></div>
  <div class="post-nav">
    <a class="prev" href="lerobot训练.html">← lerobot训练</a>
    <a class="next" href="lerobot录制.html">lerobot录制 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

