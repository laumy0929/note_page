<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>静态ftrace - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">首页</a></div>
          <div class="nav-item site-link">
            <a href="https://www.laumy.tech" target="_blank" title="访问主站">主站点:www.laumy.tech</a>
          </div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">基本原理</a><ul></ul></li><li><a href="#_2">编译完成插桩点</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>静态ftrace</h1>
  <div class="meta">
    <span class="meta-item">
      <i class="icon">🕒</i>
      2024-08-28
    </span>
    <span class="meta-item">
      <i class="icon">📂</i>
      linux
    </span>
    <span class="meta-item">
      <i class="icon">👤</i>
      laumy
    </span>
  </div>
  <div class="post-content"><p>上面章节主要描述的是动态ftrace，在早期还有静态ftrace。区别主要如下： - 动态ftrace与静态ftrace在编译参数方面静态编译使用的是参数“-pg”，而动态使用的是fpatchable-function-entry。 - 工具链使能“-pg”参数时，会在每个函数体前面插入_mcount函数。而动态ftrace会在函数入口（函数准备阶段前）插入nop指令。 - 静态ftrace插入的_mcout直到代码运行期间一直存在，而动态ftrace在不使能tracer是nop指令，动态ftrace可以动态的修改代码。 内核编译时，使能CONFIG_FUNCTION_TRACER时会启动该参数编译，在kernel目录下的Makefile可以看到。</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># The arch Makefiles can override CC_FLAGS_FTRACE. We may also append it later.</span>
<span class="n">ifdef</span><span class="w"> </span><span class="n">CONFIG_FUNCTION_TRACER</span>
<span class="w">  </span><span class="nl">CC_FLAGS_FTRACE</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">pg</span>
<span class="n">endif</span>
</code></pre></div>
<h2 id="_1">基本原理</h2>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ftrace_stub</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mcount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* save any bare state needed in order to do initial checking */</span>

<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ftrace_trace_function</span><span class="p">)(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ftrace_trace_function</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ftrace_stub</span><span class="p">)</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">do_trace</span><span class="p">;</span>
<span class="w">        </span><span class="n">①</span><span class="w"> </span><span class="n">如果用户定义了trace函数</span><span class="err">，</span><span class="n">那么就跳转到do_trace</span><span class="err">，</span><span class="n">执行ftrace_trace_function</span><span class="err">。</span><span class="n">否则什么都不做</span><span class="err">，</span><span class="n">直接返回</span><span class="err">。</span>
<span class="w">        </span><span class="cm">/* restore any bare state */</span>

<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="nl">do_trace</span><span class="p">:</span>

<span class="w">        </span><span class="cm">/* save all state needed by the ABI (see paragraph above) */</span>

<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">frompc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">selfpc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="k">return</span><span class="w"> </span><span class="n">address</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">MCOUNT_INSN_SIZE</span><span class="p">;</span>
<span class="w">        </span><span class="n">ftrace_trace_function</span><span class="p">(</span><span class="n">frompc</span><span class="p">,</span><span class="w"> </span><span class="n">selfpc</span><span class="p">);</span>
<span class="w">        </span><span class="n">②</span><span class="w"> </span><span class="n">跳转执行ftrace_trace_function</span>
<span class="w">        </span><span class="cm">/* restore all state needed by the ABI */</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<h2 id="_2">编译完成插桩点</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/08/wp_editor_md_0490cf5c14d6626155560b593b74cd17.jpg"><img alt="静态ftrace" src="assets/doc/01-linux/性能工具/静态ftrace/images/wp_editor_md_0490cf5c14d6626155560b593b74cd17.jpg"/></a></p>
<p>通过反汇编objdump -D vmlinux &gt; log后查看_mcount被插入到了vfs_read中，插入的位置在函数准备阶段之后，函数体内容之前。系统运行时，可以使用gdb 查看汇编指令，与上面基本一致。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/08/wp_editor_md_4341ac57b9fdc51f0a5b1d5ae3d435ff.jpg"><img alt="静态ftrace" src="assets/doc/01-linux/性能工具/静态ftrace/images/wp_editor_md_4341ac57b9fdc51f0a5b1d5ae3d435ff.jpg"/></a></p>
<p>我们接着再查看以下_mcount的实现，如下</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/08/wp_editor_md_a94e3ba70c9625257801cb18222e6387.jpg"><img alt="静态ftrace" src="assets/doc/01-linux/性能工具/静态ftrace/images/wp_editor_md_a94e3ba70c9625257801cb18222e6387.jpg"/></a></p></div>
  <div class="post-nav">
    <a class="prev" href="动态function-tracer原理.html">← 动态function tracer原理</a>
    <a class="next" href="ftrace-概述.html">ftrace-概述 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

