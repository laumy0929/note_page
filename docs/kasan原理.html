<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>kasan原理 - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#kasan">kasan是什么？（基本原理）</a><ul></ul></li><li><a href="#kasan_1">kasan何时设置影子区</a><ul><li><a href="#_1">申请内存</a></li><li><a href="#_2">释放内存</a></li></ul></li><li><a href="#kasan_2">kasan如何检查内存合法性</a><ul><li><a href="#_3">初始化</a></li><li><a href="#_4">影子区映射</a></li><li><a href="#__asan_loadstore">__asan_load/store定义</a></li><li><a href="#_5">检测</a></li></ul></li><li><a href="#kasan_3">kasan全局变量实现</a><ul><li><a href="#_6">全局变量影子区初始化</a></li></ul></li><li><a href="#kasan_4">kasan局部变量实现</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>kasan原理</h1>
  <div class="meta">2024-05-24 · 调试</div>
  <div class="post-content"><h2 id="kasan">kasan是什么？（基本原理）</h2>
<p>kasan是用于内存检测的工具，能够检测内存以下异常。</p>
<ul>
<li>buffer-overflow in heap,stack and globals</li>
<li>use-after-free</li>
<li>uninitialized-memory-read</li>
<li>user-memory-access</li>
</ul>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_54ee3f7bb483f2711bf976d7be7473a8.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_54ee3f7bb483f2711bf976d7be7473a8.jpg"/></a></p>
<p>如若要支持kasan需要多划分1/8的内存用于内存检测的管理，如上图所示。分配的内存地址都是按字节对齐的，这样做为了提高cpu的效率，本章默认是8字节对齐。</p>
<p>如何实现分配内存地址对齐了？首先在初始化内存时，会在前后舍弃一定的字节数，保证整个地址空间起始和结束地址是8字节对齐的，在分配内存时，分配的大小也按照字节对齐来分配，如分配3字节时，会自动补齐5字节，即实际分配到的空间是8字节，只是5字节对申请者不可见，这样就可以实现分配的内存地址是按8字节对齐的了。</p>
<p>因为内存分配都是按照8字节对齐的，而用户申请的空间并不是按照8字节来，正如上所说请求分配了3字节，实际分配到8字节，剩余5字节对用户不可见，当用户写到了该5字节的内存也是不合法，所以了对应内存的状态一共有以下9种，影子区1字节就可以记录这9种状态。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_5cf4456a5576a4100ac616284a6b8ea3.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_5cf4456a5576a4100ac616284a6b8ea3.jpg"/></a></p>
<ul>
<li>0字节可访问：说明这8字节内存都不可访问，影子区记录为-1。</li>
<li>前K字节可以访问：K值记录在影子区，如当K为2，表示0~1字节可访问。K取值为1~7。</li>
<li>全都可以访问：影子区写0。</li>
</ul>
<p>从上可知，对访问内存合法性的可以根据影子区的值来判断。判断公式如下：</p>
<p>（1） 对于分配的内存是8字节情况</p>
<div class="codehilite"><pre><span></span><code><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">shadow</span><span class="p">)</span>
<span class="w">    </span><span class="n">report_error</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">....</span>
</code></pre></div>
<p>（2）对于分配内存小于8字节情况</p>
<div class="codehilite"><pre><span></span><code><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Offset</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">shadow</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">shadow</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="w">    </span><span class="n">report_error</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_4725f29515a120e2f4a7157045d4e575.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_4725f29515a120e2f4a7157045d4e575.jpg"/></a></p>
<p>示例如上图，依旧是用户申请了3个字节空间，_shadow = 3。当客户从第2个空间访问2字节时，但是_shadow &lt; 1 + 2，条件不成立，因此合法。如果从2个空间访问3字节时，*shadow &lt; 1 + 3,条件成立，即为非法。</p>
<p>通过上面的方法可以解决use-after-free的问题，但是还不能解决buffer-overflow的问题。解决buffer-overflow，就是在分配内存的前后填充redzone，这段填区也将进行影子区映射，那么当访问越界时就会检查到影子区的内存，提示非法，实现原理参考下图所示。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_eb62adc16a86d0873c192cbb5106fe52.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_eb62adc16a86d0873c192cbb5106fe52.jpg"/></a></p>
<p>简单小结一下kasan的基本原理：</p>
<ul>
<li>内存分配地址和空间都是8n字节对齐的，本章默认8字节对齐。</li>
<li>总内存被分为n份，每份大小为8字节内存，每份用1字节内存标识，形成一一映射关系，标识区称为影子区域。</li>
<li>当请求字节不是8的整数倍时，如分配了3字节，实际分配的也是8字节，仅是另外5字节对分配者非法。因此8字节内存的访问权限一共有9种状态，其当前的状态在分配内存时记录到映射的影子区域中。</li>
<li>在分配内存时，为了支持越界访问操作，会在请求内存的前后填充red zone，red zone一般前后各8字节，也有对应的影子区域，该值填充0xfe。</li>
<li>编译器会在指令访问（读写）内存时，进行自动插桩代码，检查要访问的目标内存对应的影子区，判断是否合法，当检查非法时就会报错。</li>
</ul>
<h2 id="kasan_1">kasan何时设置影子区</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_63679c7321621b44f5b0e88fcbe03cd3.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_63679c7321621b44f5b0e88fcbe03cd3.jpg"/></a></p>
<p>（1）malloc的时候会分配2* redsize + wantsize，并对内存进行映射填充值。 redzone映射区域填充0xfe,读写区若8字节对齐则全填充0x0;若不对齐，余下不足8字节的实际值填充到最后1字节的影子区域。内存实际分配的还是8字节对齐的，只是对应应用来说，可访问的不足8字节，剩下的当redzone。 （2）free的时候对齐对应的影子区填充0xff。</p>
<h3 id="_1">申请内存</h3>
<div class="codehilite"><pre><span></span><code><span class="n">malloc</span><span class="w"> </span>
<span class="w">    </span><span class="n">_malloc_r</span>
<span class="w">        </span><span class="n">pvPortMalloc</span>
<span class="w">            </span><span class="n">__internal_malloc</span>
<span class="w">                </span><span class="n">kasan_malloc_small</span><span class="w"> </span><span class="c1">//addr = 0xc178938, size = 16</span>
<span class="w">                    </span><span class="n">kasan_unpoison_shadow</span>
<span class="w">                        </span><span class="n">kasan_poison_shadow</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">//分配空间对应的地址设置为0</span>
<span class="w">                            </span><span class="n">shadow_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kasan_mem_to_shadow</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="w">                            </span><span class="n">shadow_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kasan_mem_to_shadow</span><span class="p">(</span><span class="n">address</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">                            </span><span class="n">memset</span><span class="p">(</span><span class="n">shadow_start</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">shadow_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">shadow_start</span><span class="p">);</span>
<span class="w">                        </span><span class="n">kasan_poison_shadow</span><span class="p">(</span><span class="n">left_rz</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">debug_magic</span><span class="p">.</span><span class="n">redzone</span><span class="p">),</span><span class="w"> </span><span class="n">KASAN_KMALLOC_REDZONE</span><span class="p">);</span>
<span class="w">                        </span><span class="c1">//设置内存左redzone</span>
<span class="w">                        </span><span class="n">kasan_poison_shadow</span><span class="p">(</span><span class="n">right_rz</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">debug_magic</span><span class="p">.</span><span class="n">redzone</span><span class="p">),</span><span class="w"> </span><span class="n">KASAN_KMALLOC_REDZONE</span><span class="p">);</span>
<span class="w">                        </span><span class="c1">//设置内存右redzone</span>
<span class="w">                        </span><span class="c1">//实际分配内存左右预留一个空间，然后这预留的空间对应的shadow区域也要填充值，假设分配了16字节，实际分配了8+16+8=32字节空间。然后对应的shadow区域是1+2+1字节大小。在heap4中malloc函数中，会多分配16字节长度，如下。</span>
<span class="w">                    </span><span class="n">_internal_malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">xWanteSize</span><span class="p">)</span>
<span class="w">                        </span><span class="n">xWantSize</span><span class="w"> </span><span class="o">+=</span><span class="mi">2</span><span class="o">*</span><span class="n">xSlabDegbuMgicSize</span><span class="p">;</span>
</code></pre></div>
<p>申请内存，前后的内存redzone对应的shadow区域写0xFE,表示表示红区。实际内存对应的shadow区域写0，表示内存已经被申请，表示可写。</p>
<h3 id="_2">释放内存</h3>
<div class="codehilite"><pre><span></span><code><span class="n">free</span>
<span class="w">    </span><span class="n">__internal_free</span><span class="w"> </span>
<span class="w">        </span><span class="n">kasan_free_large</span>
<span class="w">            </span><span class="n">kasan_poison_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">KASAN_FREE_PAGE</span><span class="p">);</span>
<span class="w">            </span><span class="c1">//设置0xff到对应的shadow区域，表示该内存已经释放。不能再写了。</span>
</code></pre></div>
<h2 id="kasan_2">kasan如何检查内存合法性</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_a2a6515514e5256811518902d5b0ec53.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_a2a6515514e5256811518902d5b0ec53.jpg"/></a></p>
<h3 id="_3">初始化</h3>
<div class="codehilite"><pre><span></span><code><span class="n">初始化部分kasan_early_init</span><span class="o">/</span><span class="n">kasan_init</span><span class="o">/</span><span class="n">do_ctors</span>

<span class="n">kasan_early_init</span>
<span class="w">    </span><span class="n">kasan_shadow_init_nommu</span>
<span class="w">        </span><span class="k">for</span><span class="p">()</span>
<span class="w">            </span><span class="o">*</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="n">将所有的shadaow</span><span class="w"> </span><span class="n">memory设置为0</span>

<span class="n">kasan_init</span>
<span class="w">    </span><span class="n">kasan_init_nommu</span>
<span class="w">        </span><span class="n">kasan_init_report</span>
<span class="w">            </span><span class="n">kasan_flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">KASAN_REPORT_INIT_FLAG</span><span class="p">;</span><span class="w"> </span><span class="c1">//设置kasan标志位</span>
<span class="w">        </span><span class="n">kasan_enable_report</span>
<span class="w">            </span><span class="n">kasan_flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">KASAN_REPORT_SHOW_FLAG</span><span class="p">;</span>
<span class="w">        </span><span class="n">rt_malloc_small_sethook</span><span class="p">(</span><span class="n">rt_malloc_small_func_hook</span><span class="p">);</span>
<span class="w">            </span><span class="n">rt_malloc_small_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hook</span><span class="p">;</span><span class="w"> </span><span class="c1">//设置回调函数，heap4 __internal_malloc的时候调用</span>
<span class="w">        </span><span class="n">rt_free_small_sethook</span><span class="p">(</span><span class="n">rt_free_small_func_hook</span><span class="p">);</span>
<span class="w">            </span><span class="n">rt_free_small_hook</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hook</span><span class="p">;</span><span class="w">   </span><span class="c1">//设置回调函数，heap4 __internal_free的时候调用</span>
</code></pre></div>
<h3 id="_4">影子区映射</h3>
<div class="codehilite"><pre><span></span><code><span class="nl">adress</span><span class="p">:</span><span class="mi">0</span><span class="o">+</span><span class="n">CONFIG_ARCH_MEM_LENGTH</span><span class="w">   </span><span class="o">-------------------</span><span class="w"> </span>
<span class="w">                                  </span><span class="o">|</span><span class="n">XXXXXXXXXXXXXXXXXX</span><span class="o">|</span>
<span class="nl">adress</span><span class="p">:</span><span class="mi">0</span><span class="o">+</span><span class="n">x</span><span class="w">                        </span><span class="o">--------------------</span><span class="w"> </span><span class="n">KASAN_SHADOW_START</span>
<span class="w">                                  </span><span class="o">|</span><span class="w">                  </span><span class="o">|</span>
<span class="w">                                  </span><span class="o">|</span><span class="w">                  </span><span class="o">|</span><span class="w"> </span>
<span class="w">                                  </span><span class="o">|</span><span class="w">                  </span><span class="o">|</span>
<span class="nl">adress</span><span class="p">:</span><span class="mi">0</span><span class="w">                          </span><span class="o">-------------------</span><span class="w"> </span><span class="n">CONFIG_ARCH_START_ADDRESS</span>

<span class="cp">#define KASAN_SHADOW_SIZE   (CONFIG_ARCH_MEM_LENGTH&gt;&gt;3) </span><span class="c1">// 相当于除以8</span>
<span class="cp">#define KASAN_SHADOW_START  (CONFIG_ARCH_START_ADDRESS + CONFIG_ARCH_MEM_LENGTH - KASAN_SHADOW_SIZE)</span>
<span class="cp">#define KASAN_SHADOW_OFFSET   (KASAN_SHADOW_START - (CONFIG_ARCH_START_ADDRESS&gt;&gt;3))</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kasan_mem_to_shadow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">KASAN_SHADOW_SCALE_SHIFT</span><span class="p">)</span>
<span class="w">           </span><span class="o">+</span><span class="w"> </span><span class="n">KASAN_SHADOW_OFFSET</span><span class="p">;</span>
<span class="w">    </span><span class="n">实际</span><span class="o">=</span><span class="w"> </span><span class="n">KASAN_SHADOW_START</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">KASAN_SHADOW_SCALE_SHIFT</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">CONFIG_ARCH_START_ADDRESS</span><span class="o">&gt;&gt;</span><span class="mi">3</span>
<span class="w">    </span><span class="n">addr肯定比CONFIG_ARCH_START_ADDRESS要大</span><span class="err">，</span><span class="n">也就是说</span><span class="err">，</span><span class="n">shadow的开始地址要先减掉</span>
<span class="w">    </span><span class="n">arch_start之前的地址</span><span class="err">，</span><span class="n">这样避免浪费空间</span><span class="err">。</span>
<span class="p">}</span>

<span class="n">通过分配的地址查找对应shadow地址</span><span class="err">，</span><span class="n">内存分配是8字节对齐分配</span><span class="err">，</span><span class="n">如分配3字节</span><span class="err">，</span><span class="n">实际也是8字节空间</span><span class="err">。</span>
</code></pre></div>
<h3 id="__asan_loadstore">__asan_load/store定义</h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#define DEFINE_ASAN_LOAD_STORE(size)                    \\</span>
<span class="cp">    void __asan_load##size(unsigned long addr)          \\</span>
<span class="cp">    {                               \\</span>
<span class="cp">    KASAN_CHECK_ADDR_FILTER(addr);\\</span>
<span class="cp">        check_memory_region_inline(addr, size, false, _RET_IP_);\\</span>
<span class="cp">    }                               \\</span>
<span class="cp">    __alias(__asan_load##size)                  \\</span>
<span class="cp">    void __asan_load##size##_noabort(unsigned long);        \\</span>
<span class="cp">    void __asan_store##size(unsigned long addr)         \\</span>
<span class="cp">    {                               \\</span>
<span class="cp">    KASAN_CHECK_ADDR_FILTER(addr);\\</span>
<span class="cp">        check_memory_region_inline(addr, size, true, _RET_IP_); \\</span>
<span class="cp">    }                               \\</span>
<span class="cp">    __alias(__asan_store##size)                 \\</span>
<span class="cp">    void __asan_store##size##_noabort(unsigned long);       \\</span>

<span class="n">DEFINE_ASAN_LOAD_STORE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">DEFINE_ASAN_LOAD_STORE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">DEFINE_ASAN_LOAD_STORE</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">DEFINE_ASAN_LOAD_STORE</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">DEFINE_ASAN_LOAD_STORE</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
</code></pre></div>
<p>上面的函数展开后得到</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">__asan_load1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_load1</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_load1_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_store1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_store1</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_store1_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_load2</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_load2</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_load2_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_store2</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_store2</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_store2_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_load4</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_load4</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_load4_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_store4</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_store4</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_store4_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_load8</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_load8</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_load8_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_store8</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_store8</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_store8_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_load16</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_load16</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_load16_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_store16</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__alias</span><span class="p">(</span><span class="n">__asan_store16</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__asan_store16_noabort</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
</code></pre></div>
<p>__alias是给函数起一个别名，从上可知，定义了如下几个函数的实现。</p>
<div class="codehilite"><pre><span></span><code><span class="n">__asan_loadx</span>

<span class="n">__asan_loadx</span>
<span class="n">__asan_loadx_noabort</span>

<span class="n">其中x为1</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mi">4</span><span class="o">/</span><span class="mi">8</span><span class="o">/</span><span class="mi">16</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">__asan_loadx</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CONFIG_ARCH_START_ADDRESS</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">CONFIG_ARCH_START_ADDRESS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">CONFIG_ARCH_MEM_LENGTH</span><span class="p">)))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">;</span>
<span class="w">    </span><span class="n">上面代码的意思就是</span><span class="err">，</span><span class="n">只对特定范围的地址做检测</span><span class="err">，</span><span class="n">不再该范围的不检查</span><span class="err">，</span><span class="n">比如XIP的代码</span><span class="err">，</span><span class="n">没必要检测</span><span class="err">。</span>
<span class="w">    </span><span class="n">check_memory_region_inline</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_5">检测</h3>
<h4 id="124816">1/2/4/8/16字节</h4>
<p>以4字节的来做示例分析，其他的类似。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">memory_is_poisoned_4</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">shadow_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kasan_mem_to_shadow</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//获取影子区的值</span>
<span class="w">    </span><span class="c1">//如果影子区的值不等于继续检查，可能是不对齐的情况，比如分配了3字节，有5字节属于redzone</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">shadow_addr</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//判断第4个字节是否可访问，如果不可访问说明非法。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memory_is_poisoned_1</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * If single shadow byte covers 4-byte access, we don't</span>
<span class="cm">         * need to do anything more. Otherwise, test the first</span>
<span class="cm">         * shadow byte.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="c1">//如果第4字节为合法，满足*shadow &gt;= (addr &amp; 7) + N 则合法，否则非法。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">likely</span><span class="p">(((</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KASAN_SHADOW_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">shadow_addr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">memory_is_poisoned_1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">shadow_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kasan_mem_to_shadow</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//获取影子区的值</span>
<span class="w">    </span><span class="c1">//如果影子区的值不等于0，即进一步判断</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">shadow_value</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//判断原理与前面算法一致： *shadow &lt; (addr &amp; 7) + N为非法，否则为合法。</span>
<span class="w">        </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">last_accessible_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KASAN_SHADOW_MASK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">unlikely</span><span class="p">(</span><span class="n">last_accessible_byte</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">shadow_value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="n">N字节</h4>
<div class="codehilite"><pre><span></span><code><span class="o">*</span><span class="w"> </span><span class="n">判断内存对应的影子内存中</span><span class="err">，</span><span class="n">起始和结束shadow值是否都为</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span>
<span class="w">  </span><span class="n">结束地址是对应地址长度的影子地址的下一个影子地址</span><span class="w"> </span><span class="o">*/</span>
<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_is_zero</span><span class="p">(</span><span class="n">kasan_mem_to_shadow</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">),</span>
<span class="w">              </span><span class="n">kasan_mem_to_shadow</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">last_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="n">last_shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kasan_mem_to_shadow</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">last_byte</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/*如果ret!=last_shadow 那么在连续的内存检测过程中，就已经检测到了</span>
<span class="cm">    一个非法权限，即有问题 */</span>
<span class="w">    </span><span class="cm">/* ||后面的检测方案和 memory_is_poisoned_1 实现是相同的 */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">last_shadow</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">last_byte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">KASAN_SHADOW_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="o">*</span><span class="n">last_shadow</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="kasan_3">kasan全局变量实现</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_387e97af1705c9901836896aa4d1d771.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_387e97af1705c9901836896aa4d1d771.jpg"/></a></p>
<p>（1）当使能使能了asan-globals=1参数后，编译器会自动为每个全局变量填充red_zone。 redzone的大小为63-(size-1)%32，为了保证与32字节对齐。 （2）填充redzone后，编译器会为每个变量自动生成一个xxx_name的构造函数，该构造函数会调用__asan_register_globals进行注册，将全局变量的内存区域与影子区域建立映射并填充影子区的值，填充方法与heap一致。</p>
<p>以上操作全是编译器自动行为，应用层最终调用do_ctors回调调用构造函数即可。访问时判断内存合法性与前面算法一致。</p>
<h3 id="_6">全局变量影子区初始化</h3>
<div class="codehilite"><pre><span></span><code><span class="n">do_ctors</span>
<span class="w">    </span><span class="o">*</span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_ctors_start</span>
<span class="w">    </span><span class="k">for</span><span class="p">(;</span><span class="n">fn</span><span class="o">&lt;</span><span class="w"> </span><span class="n">_ctors_end</span><span class="p">;</span><span class="n">fn</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)();</span>
<span class="w">    </span><span class="n">调用_ctors_start和_ctors_end直接的回调函数</span><span class="err">，</span><span class="n">用于初始化全局变量的shadow</span>
<span class="w">    </span><span class="n">上面的地址在链接脚本的</span>
<span class="cp">#if (defined(CONFIG_KASAN))</span>
<span class="w">        </span><span class="cm">/* .ctors */</span>
<span class="w">        </span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="w">    </span><span class="n">__ctors_start__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">    </span><span class="n">KEEP</span><span class="p">(</span><span class="o">*</span><span class="p">(.</span><span class="n">ctors</span><span class="p">))</span>
<span class="w">    </span><span class="n">KEEP</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">SORT</span><span class="p">(.</span><span class="n">init_array</span><span class="p">.</span><span class="o">*</span><span class="p">)))</span>
<span class="w">    </span><span class="n">KEEP</span><span class="p">(</span><span class="o">*</span><span class="p">(.</span><span class="n">init_array</span><span class="p">))</span>
<span class="w">    </span><span class="n">__ctors_end__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>先调用do_ctors，调用每个工具链为每个变量生成的构造函数，构造函数调用__asan_register_globals。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_global</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kasan_global</span><span class="w"> </span><span class="o">*</span><span class="n">global</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">KASAN_CHECK_ADDR_FILTER</span><span class="p">(</span><span class="n">global</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">);</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">aligned_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">round_up</span><span class="p">(</span><span class="n">global</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">KASAN_SHADOW_SCALE_SIZE</span><span class="p">);</span>

<span class="w">    </span><span class="n">kasan_unpoison_shadow</span><span class="p">(</span><span class="n">global</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">,</span><span class="w"> </span><span class="n">global</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="n">kasan_poison_shadow</span><span class="p">(</span><span class="n">global</span><span class="o">-&gt;</span><span class="n">beg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">aligned_size</span><span class="p">,</span>
<span class="w">                        </span><span class="n">global</span><span class="o">-&gt;</span><span class="n">size_with_redzone</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">aligned_size</span><span class="p">,</span>
<span class="w">                        </span><span class="n">KASAN_GLOBAL_REDZONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__asan_register_globals</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kasan_global</span><span class="w"> </span><span class="o">*</span><span class="n">globals</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">register_global</span><span class="p">(</span><span class="o">&amp;</span><span class="n">globals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="kasan_4">kasan局部变量实现</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_04e317ed980539fbc6aa6a9d75b6e2f8.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_04e317ed980539fbc6aa6a9d75b6e2f8.jpg"/></a></p>
<ul>
<li>左边填充32字节，右边填充63-(size-1)% 32 字节。</li>
<li>shadow区域计算公式： shadow = (addr &gt;&gt;3) +koffset。</li>
<li>koffset由编译参数-fasan-shadow-offset=xxx指定。</li>
<li>shadow区域 KSAN_STACK_可读写区 0x00 KASAN_STACK_LEFT 0xF1 KASAN_STACK_MID 0xF2 --只有一个变量且是32字节对齐的，不会填充 KASAN_STACK_RIGHT 0xF3 KASAN_STACK_PARTAL 0xF4</li>
</ul>
<p>示例： （int *) (0xc18a6d0 &gt;&gt; 3 + 0xaf00000) = KASAN_STACK_LEFT 以上操作全是编译器自动行为，用户只需要使能编译参数即可。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">rz1</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span><span class="w"> </span><span class="c1">// 32-byte aligned</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">328</span><span class="p">];</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">rz2</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">rz3</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">rz1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kOffset</span><span class="p">;</span><span class="w">   </span><span class="c1">//计算变量映射shadow区的起始地址</span>
<span class="w">    </span><span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"> </span><span class="c1">// poison rz1</span>
<span class="w">    </span><span class="n">shadow</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffff00</span><span class="p">;</span><span class="w"> </span><span class="c1">// poison rz2</span>
<span class="w">    </span><span class="n">shadow</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"> </span><span class="c1">// poison rz3</span>
<span class="w">    </span><span class="o">&lt;-------------</span><span class="w"> </span><span class="n">CODE</span><span class="w"> </span><span class="o">-------------&gt;</span>
<span class="w">    </span><span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadow</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadow</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
<p>官方解释算法如上，当工具链接加上--param asan-stack=1，局部变量redzone填充以及shadow映射填充值全工具链自动完成。对应局部变量需要左右都需要填充redzone，所以可以划分为以下4个部分。</p>
<ul>
<li>left redzone： 32字节。</li>
<li>变量长度：实际的变量长度</li>
<li>mid redzone：该区域有两个用途①是补齐变量长度，让其32字节对齐。②是当存在多个变量时，用于中间区域的隔离。当变量长度不是32字节对齐的，填充长度是变量长度+mid redzone长度能够32字节对齐。mid redzone= 63-(size-1)%32 -32。当存在多个变量中，变量与变量之间至少要有32字节用于隔离。</li>
<li>right redzone:32字节。</li>
</ul>
<p>对于上面4个内存区域，也可以将shadow映射区划分为4个部分</p>
<ul>
<li>left redzone shadow: 填充0xF1</li>
<li>变量长度：都填充0x0;</li>
<li>mid redzone: 填充0xF2</li>
<li>right redzone: 填充0xF3；</li>
</ul>
<p>注意： 当只有一个变量且该变量长度是32字节对齐，则没有mid redzone区域。 <a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_87f6f4408686414982d8cc31ae1f23c4.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_87f6f4408686414982d8cc31ae1f23c4.jpg"/></a></p>
<p>下面来段实验，定义了这么一段代码。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">test_asan_xxx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">328</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">328</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>下面是反汇编的结果</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">test_asan_xxx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="nl">c0efd34</span><span class="p">:</span><span class="w">   </span><span class="mi">7121</span><span class="w">                    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">-448</span><span class="w">   </span><span class="c1">//开辟448空间内存</span>
<span class="w"> </span><span class="nl">c0efd36</span><span class="p">:</span><span class="w">   </span><span class="n">f1f1f7b7</span><span class="w">            </span><span class="n">lui</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="mh">0xf1f1f</span><span class="w">           </span><span class="c1">//a5=0xf1f1f&lt;&lt;12</span>
<span class="w"> </span><span class="nl">c0efd3a</span><span class="p">:</span><span class="w">   </span><span class="n">fb22</span><span class="w">                    </span><span class="n">sd</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="mi">432</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">       </span><span class="c1">//将s0存储到sp+432位置</span>
<span class="w"> </span><span class="nl">c0efd3c</span><span class="p">:</span><span class="w">   </span><span class="n">f726</span><span class="w">                    </span><span class="n">sd</span><span class="w">  </span><span class="n">s1</span><span class="p">,</span><span class="mi">424</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">       </span><span class="c1">//将s1存储到sp+424位置</span>
<span class="w"> </span><span class="nl">c0efd3e</span><span class="p">:</span><span class="w">   </span><span class="n">f34a</span><span class="w">                    </span><span class="n">sd</span><span class="w">  </span><span class="n">s2</span><span class="p">,</span><span class="mi">416</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">       </span><span class="c1">//将s2存储到sp+416位置</span>
<span class="w"> </span><span class="nl">c0efd40</span><span class="p">:</span><span class="w">   </span><span class="n">ff06</span><span class="w">                    </span><span class="n">sd</span><span class="w">  </span><span class="n">ra</span><span class="p">,</span><span class="mi">440</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w">       </span><span class="c1">//将ra存储到sp+440位置</span>
<span class="w"> </span><span class="c1">//开辟一个栈空间为448字节，并且将a5=0xf1f1f000</span>
<span class="w"> </span><span class="c1">//将s0,s1,s2,ra压入栈中。</span>

<span class="w"> </span><span class="nl">c0efd42</span><span class="p">:</span><span class="w">   </span><span class="mi">840</span><span class="n">a</span><span class="w">                    </span><span class="n">mv</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="n">sp</span><span class="w">            </span><span class="c1">//s0指向sp，即填充32字节的地址</span>
<span class="w"> </span><span class="nl">c0efd44</span><span class="p">:</span><span class="w">   </span><span class="mf">1f</span><span class="mi">17879</span><span class="n">b</span><span class="w">            </span><span class="n">addiw</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="n">a5</span><span class="p">,</span><span class="mi">497</span><span class="w">        </span><span class="c1">//a5 = 0xf1f1f1f1</span>
<span class="w"> </span><span class="nl">c0efd48</span><span class="p">:</span><span class="w">   </span><span class="mi">800</span><span class="n">d</span><span class="w">                    </span><span class="n">srli</span><span class="w">    </span><span class="n">s0</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="mh">0x3</span><span class="w">    </span><span class="c1">//s0 = s0 &gt;&gt; 3</span>
<span class="w"> </span><span class="nl">c0efd4a</span><span class="p">:</span><span class="w">   </span><span class="mi">0</span><span class="n">af00937</span><span class="w">            </span><span class="n">lui</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="mh">0xaf00</span><span class="w">            </span><span class="c1">//s2 = 0xaf00000,即koffset</span>
<span class="w"> </span><span class="nl">c0efd4e</span><span class="p">:</span><span class="w">   </span><span class="mi">4089578</span><span class="n">b</span><span class="w">            </span><span class="n">srw</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="w">           </span><span class="c1">//*(s0&gt;&gt;0 + s2)=a5</span>
<span class="w"> </span><span class="c1">//写KASAN_STACK_LEFT</span>
<span class="w"> </span><span class="c1">//对变量的前32字节 shadow映射区填充0xf1f1f1f1(8字节映射1字节)</span>
<span class="w"> </span><span class="c1">//int *shadow = (sp &gt;&gt; 3) + koffset;</span>
<span class="w"> </span><span class="c1">//shadow区域是按照4字节对齐存储，对应的变量就是32字节。</span>
<span class="w"> </span><span class="c1">// shadow[0] = 0xf1f1f1f1</span>

<span class="w"> </span><span class="nl">c0efd52</span><span class="p">:</span><span class="w">   </span><span class="n">f2f2f7b7</span><span class="w">            </span><span class="n">lui</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="mh">0xf2f2f</span><span class="w">    </span><span class="c1">//a5 = 0xf2f2f000</span>
<span class="w"> </span><span class="nl">c0efd56</span><span class="p">:</span><span class="w">   </span><span class="mi">2007879</span><span class="n">b</span><span class="w">            </span><span class="n">addiw</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="n">a5</span><span class="p">,</span><span class="mi">512</span><span class="w"> </span><span class="c1">//a5 = 0xf2f2f200</span>
<span class="w"> </span><span class="nl">c0efd5a</span><span class="p">:</span><span class="w">   </span><span class="mo">00</span><span class="mi">8904</span><span class="n">b3</span><span class="w">            </span><span class="n">add</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s0</span><span class="w">      </span><span class="c1">//s1 = s2 +s0，即32字节映射区地址</span>
<span class="w"> </span><span class="nl">c0efd5e</span><span class="p">:</span><span class="w">   </span><span class="n">d4dc</span><span class="w">                    </span><span class="n">sw</span><span class="w">  </span><span class="n">a5</span><span class="p">,</span><span class="mi">44</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="w"> </span><span class="c1">//从32字节映射区偏移44字节写入0xf2f2f200</span>
<span class="c1">//写KASAN_STACK_MID（包含数据区对齐32字节后剩余部分的shadow）</span>
<span class="c1">//因为数组长度是328字节，对应的shadow是41字节，shodow是每4字节存储，所以剩余1字节</span>
<span class="c1">//就随着REDZONE映射shadow区域一起填充，余下的3字节就填充f2。</span>
<span class="c1">//所以STACK_MID就是偏移44的位置。</span>

<span class="w"> </span><span class="nl">c0efd60</span><span class="p">:</span><span class="w">   </span><span class="n">f3f3f7b7</span><span class="w">            </span><span class="n">lui</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="mh">0xf3f3f</span>
<span class="w"> </span><span class="nl">c0efd64</span><span class="p">:</span><span class="w">   </span><span class="mf">3f</span><span class="mi">37879</span><span class="n">b</span><span class="w">            </span><span class="n">addiw</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="n">a5</span><span class="p">,</span><span class="mi">1011</span>
<span class="w"> </span><span class="nl">c0efd68</span><span class="p">:</span><span class="w">   </span><span class="n">d89c</span><span class="w">                    </span><span class="n">sw</span><span class="w">  </span><span class="n">a5</span><span class="p">,</span><span class="mi">48</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="w">       </span><span class="c1">//0xc73150a地址内容=0xf3f3f3f3</span>
<span class="c1">//写KASAN_STACK_RIGHT</span>
<span class="c1">//最后余下32字节redzone，对应4字节填充f3</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">328</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">328</span><span class="p">);</span>
<span class="w"> </span><span class="nl">c0efd6a</span><span class="p">:</span><span class="w">   </span><span class="mi">1008</span><span class="w">                    </span><span class="n">addi</span><span class="w">    </span><span class="n">a0</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">32</span>
<span class="w"> </span><span class="nl">c0efd6c</span><span class="p">:</span><span class="w">   </span><span class="mi">14800613</span><span class="w">            </span><span class="n">li</span><span class="w">  </span><span class="n">a2</span><span class="p">,</span><span class="mi">328</span>
<span class="w"> </span><span class="nl">c0efd70</span><span class="p">:</span><span class="w">   </span><span class="mi">4581</span><span class="w">                    </span><span class="n">li</span><span class="w">  </span><span class="n">a1</span><span class="p">,</span><span class="mi">0</span>
<span class="w"> </span><span class="nl">c0efd72</span><span class="p">:</span><span class="w">   </span><span class="n">acfc20ef</span><span class="w">            </span><span class="n">jal</span><span class="w"> </span><span class="n">ra</span><span class="p">,</span><span class="n">c0b2840</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memset</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w"> </span><span class="nl">c0efd76</span><span class="p">:</span><span class="w">   </span><span class="mi">4089500</span><span class="n">b</span><span class="w">            </span><span class="n">srw</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="mi">0</span>
<span class="p">}</span>
<span class="w"> </span><span class="nl">c0efd7a</span><span class="p">:</span><span class="w">   </span><span class="mf">70f</span><span class="n">a</span><span class="w">                    </span><span class="n">ld</span><span class="w">  </span><span class="n">ra</span><span class="p">,</span><span class="mi">440</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w"> </span><span class="nl">c0efd7c</span><span class="p">:</span><span class="w">   </span><span class="mi">745</span><span class="n">a</span><span class="w">                    </span><span class="n">ld</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="mi">432</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w"> </span><span class="nl">c0efd7e</span><span class="p">:</span><span class="w">   </span><span class="mo">0204</span><span class="n">b623</span><span class="w">            </span><span class="n">sd</span><span class="w">  </span><span class="n">zero</span><span class="p">,</span><span class="mi">44</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="p">}</span>
<span class="w"> </span><span class="nl">c0efd82</span><span class="p">:</span><span class="w">   </span><span class="mi">791</span><span class="n">a</span><span class="w">                    </span><span class="n">ld</span><span class="w">  </span><span class="n">s2</span><span class="p">,</span><span class="mi">416</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w"> </span><span class="nl">c0efd84</span><span class="p">:</span><span class="w">   </span><span class="mi">74</span><span class="n">ba</span><span class="w">                    </span><span class="n">ld</span><span class="w">  </span><span class="n">s1</span><span class="p">,</span><span class="mi">424</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="w"> </span><span class="nl">c0efd86</span><span class="p">:</span><span class="w">   </span><span class="mi">6139</span><span class="w">                    </span><span class="n">addi</span><span class="w">    </span><span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">448</span>
<span class="w"> </span><span class="nl">c0efd88</span><span class="p">:</span><span class="w">   </span><span class="mi">8082</span><span class="w">                    </span><span class="n">ret</span>
</code></pre></div>
<p>当定义两个变量时示例</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">test_asan_xxx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">328</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">144</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">328</span><span class="p">);</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">128</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_1fd4bc82227ef211884a3cba3f0b61c4.jpg"><img alt="" src="assets/doc/07-调试/kasan原理/images/wp_editor_md_1fd4bc82227ef211884a3cba3f0b61c4.jpg"/></a></p>
<p>left值依旧是32字节没有变化，在a数组和b数组中间填充了48字节的mid redzone，其中mid[16]字节是为了对齐b数组让其32字节对齐的，而mid[32]是用于隔离a[328]和b[144]数组的。</p></div>
  <div class="post-nav">
    <a class="prev" href="道德经.html">← 道德经</a>
    <a class="next" href="freertos栈溢出检测原理.html">freertos栈溢出检测原理 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

